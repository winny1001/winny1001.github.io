<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"winny1001.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":"ture","version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"fold":{"enable":true,"height":400},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="这学期在学操作系统，记录一下操作系统实验中遇到的问题。">
<meta property="og:type" content="article">
<meta property="og:title" content="OS实验之玩转linux内核">
<meta property="og:url" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/index.html">
<meta property="og:site_name" content="Winny的一亩三分地">
<meta property="og:description" content="这学期在学操作系统，记录一下操作系统实验中遇到的问题。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1570889446612.png">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571221714061.png">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571218157936.png">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1570874109940.png">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1570874224027.png">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571228835055.png">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1570874893440.png">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571229039863.png">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571234059525.png">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571234171381.png">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571322664930.png">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571235696127.png">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571239942149.png">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571273096443.png">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571292905251.png">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571293144531.png">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571322903655.png">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571294764926.png">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571290497284.png">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571324205319.png">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571320179038.png">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571817038619.png">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/2019-10-23_172003.png">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571822845749.png">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571498488155.png">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571806269316.png">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1572248369602.png">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1572252482068.png">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1572248861081.png">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1572249333433.png">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/%E5%9B%BE%E7%89%871.png">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/image-20191029155551912.png">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/lockf.gif">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/close.gif">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/image-20191107220233737.png">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/image-20191106233254914.png">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/image-20191107001256301.png">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/image-20191107001446943.png">
<meta property="og:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/image-20191107145711780.png">
<meta property="article:published_time" content="2019-10-17T13:26:57.000Z">
<meta property="article:modified_time" content="2024-06-11T06:15:12.079Z">
<meta property="article:author" content="Winny">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1570889446612.png">


<link rel="canonical" href="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/","path":"2019/10/17/Lecture/OS实验之玩转linux内核/","title":"OS实验之玩转linux内核"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>OS实验之玩转linux内核 | Winny的一亩三分地</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Winny的一亩三分地</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description"> Imagination will take you everywhere</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#linux%E5%86%85%E6%A0%B8%E7%9A%84%E7%BC%96%E8%AF%91%E5%88%9D%E4%BD%93%E9%AA%8C"><span class="nav-number">1.</span> <span class="nav-text">linux内核的编译初体验~</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="nav-number">1.1.</span> <span class="nav-text">实验环境准备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91linux%E5%86%85%E6%A0%B8"><span class="nav-number">1.2.</span> <span class="nav-text">编译linux内核</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E9%87%87%E5%9D%91"><span class="nav-number">1.3.</span> <span class="nav-text">避免采坑</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">2.</span> <span class="nav-text">设计一个系统调用！</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%95%A5%E5%8F%AB%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">2.1.</span> <span class="nav-text">啥叫系统调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E5%85%A5%E8%87%AA%E5%B7%B1%E7%9A%84hello-world%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">2.2.</span> <span class="nav-text">加入自己的Hello
World系统调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E9%87%87%E5%9D%91-1"><span class="nav-number">2.3.</span> <span class="nav-text">避免采坑</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%8A%A8%E6%80%81%E8%B0%83%E7%94%A8%E6%A8%A1%E5%9D%97"><span class="nav-number">3.</span> <span class="nav-text">设计一个动态调用模块！</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%95%A5%E5%8F%AB%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97"><span class="nav-number">3.1.</span> <span class="nav-text">啥叫动态模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E5%85%A5%E8%87%AA%E5%B7%B1%E7%9A%84hello-module%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97"><span class="nav-number">3.2.</span> <span class="nav-text">加入自己的Hello
Module动态模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E9%87%87%E5%9D%91-2"><span class="nav-number">3.3.</span> <span class="nav-text">避免采坑</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E7%AD%BE%E5%90%8D"><span class="nav-number">3.3.1.</span> <span class="nav-text">模块签名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section"><span class="nav-number">3.3.2.</span> <span class="nav-text">！！！</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">4.</span> <span class="nav-text">实验一——设计一个系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9"><span class="nav-number">4.1.</span> <span class="nav-text">实验内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E5%AF%BC%E7%9F%A5%E8%AF%86"><span class="nav-number">4.2.</span> <span class="nav-text">前导知识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E6%80%9D%E8%B7%AF"><span class="nav-number">4.3.</span> <span class="nav-text">实验思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.4.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E9%87%87%E5%9D%91-3"><span class="nav-number">4.5.</span> <span class="nav-text">避免采坑</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#vfs_read"><span class="nav-number">4.5.1.</span> <span class="nav-text">vfs_read……</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%92%8C%E7%B3%BB%E7%BB%9F%E7%A9%BA%E9%97%B4"><span class="nav-number">4.5.2.</span> <span class="nav-text">用户空间和系统空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sys_call_table%E5%9C%B0%E5%9D%80"><span class="nav-number">4.5.3.</span> <span class="nav-text">sys_call_table地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F"><span class="nav-number">4.5.4.</span> <span class="nav-text">获取文件大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for_each_process"><span class="nav-number">4.5.5.</span> <span class="nav-text">for_each_process</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C2-1%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BD%AF%E4%B8%AD%E6%96%AD%E9%80%9A%E4%BF%A1"><span class="nav-number">5.</span> <span class="nav-text">实验2-1——进程的软中断通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9-1"><span class="nav-number">5.1.</span> <span class="nav-text">实验内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E5%AF%BC%E7%9F%A5%E8%AF%86-1"><span class="nav-number">5.2.</span> <span class="nav-text">前导知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fork"><span class="nav-number">5.2.1.</span> <span class="nav-text">fork()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#signal"><span class="nav-number">5.2.2.</span> <span class="nav-text">signal()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kill"><span class="nav-number">5.2.3.</span> <span class="nav-text">kill()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E6%80%9D%E8%B7%AF-1"><span class="nav-number">5.3.</span> <span class="nav-text">实验思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">5.4.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E9%87%87%E5%9D%91-4"><span class="nav-number">5.5.</span> <span class="nav-text">避免采坑</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#while%E8%AF%AD%E5%8F%A5"><span class="nav-number">5.5.1.</span> <span class="nav-text">while语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E5%BF%BD%E7%95%A5sig_ign"><span class="nav-number">5.5.2.</span> <span class="nav-text">信号忽略SIG_IGN</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C2-2%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1"><span class="nav-number">6.</span> <span class="nav-text">实验2-2——进程的管道通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9-2"><span class="nav-number">6.1.</span> <span class="nav-text">实验内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E5%AF%BC%E7%9F%A5%E8%AF%86-2"><span class="nav-number">6.2.</span> <span class="nav-text">前导知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E9%81%93"><span class="nav-number">6.2.1.</span> <span class="nav-text">管道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#read"><span class="nav-number">6.2.2.</span> <span class="nav-text">read()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#write"><span class="nav-number">6.2.3.</span> <span class="nav-text">write()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sprintf"><span class="nav-number">6.2.4.</span> <span class="nav-text">sprintf()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lockf"><span class="nav-number">6.2.5.</span> <span class="nav-text">lockf()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="nav-number">6.3.</span> <span class="nav-text">实现思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="nav-number">6.4.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E9%87%87%E5%9D%91-5"><span class="nav-number">6.5.</span> <span class="nav-text">避免采坑</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C2-3%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="nav-number">7.</span> <span class="nav-text">实验2-3——内存的分配与回收</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9-3"><span class="nav-number">7.1.</span> <span class="nav-text">实验内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E5%AF%BC%E7%9F%A5%E8%AF%86-3"><span class="nav-number">7.2.</span> <span class="nav-text">前导知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ffbfwf%E7%AE%97%E6%B3%95"><span class="nav-number">7.2.1.</span> <span class="nav-text">FF、BF、WF算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">7.2.2.</span> <span class="nav-text">链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF-1"><span class="nav-number">7.3.</span> <span class="nav-text">实现思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3"><span class="nav-number">7.4.</span> <span class="nav-text">代码实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">7.4.1.</span> <span class="nav-text">主要数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B2%E5%88%86%E5%8C%BA%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="nav-number">7.4.1.1.</span> <span class="nav-text">内存空闲分区的描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%B2%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E5%9D%97%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="nav-number">7.4.1.2.</span> <span class="nav-text">已分配内存块的描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E5%AE%9A%E4%B9%89"><span class="nav-number">7.4.1.3.</span> <span class="nav-text">常量定义</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E5%9D%97"><span class="nav-number">7.4.2.</span> <span class="nav-text">函数模块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E5%87%BD%E6%95%B0%E5%8F%8A%E8%8F%9C%E5%8D%95"><span class="nav-number">7.4.2.1.</span> <span class="nav-text">主函数及菜单</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BB%E5%87%BD%E6%95%B0"><span class="nav-number">7.4.2.1.1.</span> <span class="nav-text">主函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA%E8%8F%9C%E5%8D%95"><span class="nav-number">7.4.2.1.2.</span> <span class="nav-text">显示菜单</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%86%85%E5%AD%98"><span class="nav-number">7.4.2.2.</span> <span class="nav-text">初始化内存</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E7%A9%BA%E9%97%B2%E5%9D%97"><span class="nav-number">7.4.2.2.1.</span> <span class="nav-text">初始化空闲块</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F"><span class="nav-number">7.4.2.2.2.</span> <span class="nav-text">设置内存大小</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%86%85%E5%AD%98%E7%AE%97%E6%B3%95"><span class="nav-number">7.4.2.3.</span> <span class="nav-text">设置内存算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA%E8%AE%BE%E7%BD%AE%E8%8F%9C%E5%8D%95"><span class="nav-number">7.4.2.3.1.</span> <span class="nav-text">显示设置菜单</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%89%E6%8C%87%E5%AE%9A%E7%AE%97%E6%B3%95%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E7%A9%BA%E9%97%B2%E5%8C%BA%E9%93%BE%E8%A1%A8"><span class="nav-number">7.4.2.3.2.</span> <span class="nav-text">按指定算法重新排列空闲区链表</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E8%BD%BD%E5%85%A5%E5%86%85%E5%AD%98"><span class="nav-number">7.4.2.4.</span> <span class="nav-text">创建进程载入内存</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B0%E8%BF%9B%E7%A8%8B%E8%8E%B7%E5%8F%96%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7%E6%95%B0%E9%87%8F"><span class="nav-number">7.4.2.4.1.</span> <span class="nav-text">创建新进程，获取内存申请数量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E6%A8%A1%E5%9D%97"><span class="nav-number">7.4.2.4.2.</span> <span class="nav-text">分配内存模块</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B4%A7%E7%BC%A9%E5%A4%84%E7%90%86"><span class="nav-number">7.4.2.4.3.</span> <span class="nav-text">紧缩处理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E8%BF%9B%E7%A8%8B%E7%A7%BB%E5%87%BA%E5%86%85%E5%AD%98"><span class="nav-number">7.4.2.5.</span> <span class="nav-text">删除进程移出内存</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E8%BF%9B%E7%A8%8B"><span class="nav-number">7.4.2.5.1.</span> <span class="nav-text">删除进程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%BE%E5%88%B0%E8%BF%9B%E7%A8%8B"><span class="nav-number">7.4.2.5.2.</span> <span class="nav-text">找到进程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BD%92%E8%BF%98%E5%88%86%E9%85%8D%E5%8C%BA%E5%B9%B6%E5%90%88%E5%B9%B6"><span class="nav-number">7.4.2.5.3.</span> <span class="nav-text">归还分配区并合并</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8A%E6%94%BEab%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%8A%82%E7%82%B9"><span class="nav-number">7.4.2.5.4.</span> <span class="nav-text">释放ab数据结构节点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA%E5%86%85%E5%AD%98%E7%8A%B6%E6%80%81"><span class="nav-number">7.4.2.6.</span> <span class="nav-text">显示内存状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E7%AE%97%E6%B3%95"><span class="nav-number">7.4.2.7.</span> <span class="nav-text">三种算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ff%E7%AE%97%E6%B3%95"><span class="nav-number">7.4.2.7.1.</span> <span class="nav-text">FF算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bf%E7%AE%97%E6%B3%95"><span class="nav-number">7.4.2.7.2.</span> <span class="nav-text">BF算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#wf%E7%AE%97%E6%B3%95"><span class="nav-number">7.4.2.7.3.</span> <span class="nav-text">WF算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%80%E5%87%BA%E7%A8%8B%E5%BA%8F"><span class="nav-number">7.4.2.8.</span> <span class="nav-text">退出程序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E9%87%87%E5%9D%91-6"><span class="nav-number">7.5.</span> <span class="nav-text">避免采坑</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Winny</p>
  <div class="site-description" itemprop="description">因为热爱，所以折腾</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/winny1001" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;winny1001" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="Back to top">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://winny1001.github.io/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Winny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Winny的一亩三分地">
      <meta itemprop="description" content="因为热爱，所以折腾">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="OS实验之玩转linux内核 | Winny的一亩三分地">
      <meta itemprop="description" content="这学期在学操作系统，记录一下操作系统实验中遇到的问题。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          OS实验之玩转linux内核
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-10-17 22:26:57" itemprop="dateCreated datePublished" datetime="2019-10-17T22:26:57+09:00">2019-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-06-11 15:15:12" itemprop="dateModified" datetime="2024-06-11T15:15:12+09:00">2024-06-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Study/" itemprop="url" rel="index"><span itemprop="name">Study</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Study/Lecture/" itemprop="url" rel="index"><span itemprop="name">Lecture</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">这学期在学操作系统，记录一下操作系统实验中遇到的问题。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>虽然用过linux系统，但是内核却一直没接触过。正好这学期的操作系统有实验课，要玩内核，就通过这门课好好学习一下内核相关的知识。在这里记录一下自己的linux内核学习过程和遇到的各种坑。如果写的有什么问题欢迎各位大佬指正。我会把源代码放到<a
target="_blank" rel="noopener" href="https://github.com/winny1001/Operating-System-Experiment">GitHub</a>上，有些代码（例如内存分配）比较长，因此可以直接从GitHub上下载下来，便于阅读。如果这篇博客帮助到你，可以在文章末尾点一个喜欢或者分享给他人，也可以给我的项目点一个star哦~</p>
<h1 id="linux内核的编译初体验">linux内核的编译初体验~</h1>
<p>编译实验第一个题目是要添加一个系统调用。但是不管什么题目，都得重新编译内核，所以首先我得学习如何编译linux内核。</p>
<h2 id="实验环境准备">实验环境准备</h2>
<p>我用的环境是VM Ware + <a
target="_blank" rel="noopener" href="https://ubuntu.com/download/server">Ubuntu Server18.04.3
LTS</a>（没有图形化界面，操作方便且占用内存较小）。给的配置为4GB内存，50GB硬盘，4核处理器。</p>
<p>声明：我所有的命令没有特殊说明都是在root用户下执行的，因此没有<code>sudo</code>，如果你在非root用户下执行可能需要<code>sudo</code>。</p>
<p>首先查看当前使用的linux版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> -r</span><br></pre></td></tr></table></figure>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1570889446612.png" class="" width="1570889446612">
<p>可以看到我初始的版本是4.15.0-66，然后下载你想要的内核，在
https://mirrors.edge.kernel.org/pub/linux/kernel/
上找到你想要的内核并下载，例如我下载的是linux-4.16.10.tar.xz：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.16.10.tar.xz</span><br></pre></td></tr></table></figure>
<p>下载完成后解压到linux-4.16.10文件夹：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xvJf linux-4.16.10.tar.xz</span><br></pre></td></tr></table></figure>
<p>解压完成后就是修改并编译linux啦。</p>
<h2 id="编译linux内核">编译linux内核</h2>
<p>编译linux内核前首先我们要配置相应的环境。要求至少给虚拟机50G的磁盘空间（没有50G也尽量越多越好），不然编四五个小时最后提示你没有空间了要重新编译那直接原地裂开。</p>
<p>然后安装相应的依赖包和软件工具：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install libncurses5-dev libssl-dev zlibc minizip build-essential openssl libidn11-dev libidn11 </span><br><span class="line">apt-get install git fakeroot ncurses-dev xz-utils bc flex libelf-dev bison</span><br></pre></td></tr></table></figure>
<p>安装完之后<code>cd linux-4.16.10</code>进入文件夹内，如果你是第一次编译，那么使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>
<p>进行配置，这个命令打开一个配置工具，允许我们定制自己的内核。</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571221714061.png" class="" width="1571221714061">
<p>如果不是第一次编译，那么首先要清除之前编译产生的中间文件。输入以下指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make mrproper</span><br></pre></td></tr></table></figure>
<p>mrproper是清除编译过程中产生的所有文件、配置和备份文件（Remove all
generated files + config + various backup files）或者你也可以用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br></pre></td></tr></table></figure>
<p>这是清除编译过程中产生的大多数文件，但会保留内核的配置文件，同时还有足够的编译支持来建立扩展模块（
Remove most generated files but keep the config and enough build support
to build external modules）。</p>
<p>由于是第一次并且是以学习编译为目的，因此我们使用默认配置就好。直接save-&gt;ok-&gt;exit-&gt;exit。</p>
<p>配置完了之后就可以开始编译了</p>
<p>直接输入<code>make</code>就可以开始编译。当然，你可以采用多线程编译，这样速度会快一点。命令是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j8</span><br></pre></td></tr></table></figure>
<p><code>-jx</code>中的x是make并行编译的线程数，给多少随意，一般这个数值为内核数*2比较合适，比如说我给了虚拟机4核，那么我就-j8。</p>
<p><strong>但是需要注意的是</strong>：如果你修改了内核，而且不知道对不对，那么最好不要多线程编译。因为如果一个线程出错了的话，编译不会停止，其他线程会继续编译，其他线程编译的内容就会把出错的信息刷掉，这样一来你就无法知道自己编译的是否正确以及出错的位置在哪（血的教训）。</p>
<p>由于是编译整个内核，因此编译时间很长，接下来就是耐心的等待了。</p>
<p>编译过程如图：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571218157936.png" class="" width="1571218157936">
<p>编译完成后开始安装之前启用的模块：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make modules_install</span><br></pre></td></tr></table></figure>
<p>安装完成之后接着安装内核：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>安装完内核之后我们需要启用编译好的内核，打开<code>/etc/default/grub</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/default/grub</span><br></pre></td></tr></table></figure>
<p>按<code>i</code>进行编辑，找到并注释掉GRUB_TIMEOUT_STYLE=hidden和GRUB_TIMEOUT=0，如图所示：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1570874109940.png" class="" width="1570874109940">
<p>修改完成后先按<code>esc</code>退出编辑模式，再按<code>:wq</code>保存退出，然后更新配置并重新启动：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update-grub</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>
<p>重启后出现菜单：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1570874224027.png" class="" width="1570874224027">
<p>直接进入就启用了我们编译好的内核了。如果想要切换内核，就选Advanced
options for Ubuntu，这一栏就可以选择想要使用的内核了：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571228835055.png" class="" width="1571228835055">
<h2 id="避免采坑">避免采坑</h2>
<p>正常操作到这就完成了。但是这时候我遇到了问题，我在编译完成之后发现无法使用新内核进入系统，如图：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1570874893440.png" class="" width="1570874893440">
<p>后来在网上查找发现造成这种错误的一个可能的原因是内存太小，我本来的配置是2GB（我寻思也不小啊），改成4GB之后就能正常启动了。</p>
<p>打开之后用<code>uname -r</code>看看内核版本：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571229039863.png" class="" width="1571229039863">
<p>是4.16.10，我们成功了！至此，我们第一个内核就算正是编译完成了，撒花！</p>
<p>下面我们就可以对新鲜出炉的内核动手动脚啦hiahiahia。</p>
<h1 id="设计一个系统调用">设计一个系统调用！</h1>
<p>光会编译内核，还不能算入门，只能算看到了门。真正想要“玩”内核，就必须要学会修改内核，让内核变得更加个性化。一开始我们举一个最简单的例子，也是编译实验原理课的第一个实验，设计一个系统调用！</p>
<h2 id="啥叫系统调用">啥叫系统调用</h2>
<p>系统调用，听着很高大上，但千万不要被它的名字吓到，其实简单理解它就是一内核调用的函数，而不是用户调用的。</p>
<p>维基百科是这样定义的：系统调用（英语：system
call），指运行在用户空间的程序向操作系统内核请求需要更高权限运行的服务。系统调用提供用户程序与操作系统之间的接口。</p>
<p>举个简单的例子，我去别人家做客，我想玩他家的乐低，但是乐高在人家卧室里，我没有权限进去，那咋办嘞？我就给主人说，“我想玩你的乐低，请帮我拿一下。”主人说没问题，起身进去帮我拿了出来，然后我开心的玩起了乐低。这时候，“我”就是用户，“主人”就是内核，而“玩乐低”是需要更高权限运行的服务，“帮我拿乐低”就是一个接口，由于这个动作是“主人”发出的（这个函数是内核调用的），那么这就是一个系统调用。</p>
<h2 id="加入自己的hello-world系统调用">加入自己的Hello
World系统调用</h2>
<p>参考《<a
target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41175905/article/details/80529245">操作系统作业：给linux系统增加一个系统调用</a>》。</p>
<p>首先在系统调用表<code>linux-4.16.10/arch/x86/entry/syscalls/syscall_64_tbl</code>中定义自己的系统调用的调用号和系统调用函数的映射。</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571234059525.png" class="" width="1571234059525">
<p>然后在头文件<code>linux-4.16.10/arch/x86/include/asm/syscalls.h</code>中声明自己的系统调用</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571234171381.png" class="" width="1571234171381">
<p>然后在把具体调用的实现函数写在linux-4.16.10/kernel/sys.c里：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571322664930.png" class="" width="1571322664930">
<p>然后重新编译内核，不要忘了重启。编译好了之后我们写一个测试代码<code>test.c</code>来看看能否成功执行我们的系统调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> a = syscall(<span class="number">333</span>);	<span class="comment">//333是我们自己的系统调用的调用号</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;System call sys_helloworld return %ld\n&quot;</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用<code>gcc -o test test.c</code>来编译，编译完成后用<code>./test</code>来运行：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571235696127.png" class="" width="1571235696127">
<p>可以看到输出了22，证明我们的系统调用成功的被执行了！</p>
<p>但是为什么没有“Hello
World!!!”呢？是因为printk函数输出的信息具有日志级别，简单来说就是printk输出的内容输出到了内核日志里，我们可以通过<code>dmesg</code>命令查看内核日志：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571239942149.png" class="" width="1571239942149">
<p>可以看到最后一行就是我们输出的信息“Hello
World!!!”，也同样证明我们的系统调用成功实现了！</p>
<p>那如果我们就想让它输出到终端可以吗？也是可以的，这就涉及到printk的知识点了。</p>
<p>内核通过 printk()
输出的信息具有日志级别，内核中共提供了八种不同的日志级别，在
linux/kernel.h 中有相应的宏对应。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_EMERG   <span class="string">&quot;&lt;0&gt;&quot;</span>   <span class="comment">/* system is unusable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_ALERT   <span class="string">&quot;&lt;1&gt;&quot;</span>   <span class="comment">/* action must be taken immediately */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_CRIT   <span class="string">&quot;&lt;2&gt;&quot;</span>   <span class="comment">/* critical conditions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_ERR   <span class="string">&quot;&lt;3&gt;&quot;</span>   <span class="comment">/* error conditions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_WARNING <span class="string">&quot;&lt;4&gt;&quot;</span>   <span class="comment">/* warning conditions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_NOTICE  <span class="string">&quot;&lt;5&gt;&quot;</span>   <span class="comment">/* normal but significant */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_INFO   <span class="string">&quot;&lt;6&gt;&quot;</span>   <span class="comment">/* informational */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_DEBUG  <span class="string">&quot;&lt;7&gt;&quot;</span>   <span class="comment">/* debug-level messages */</span></span></span><br></pre></td></tr></table></figure>
<p>未指定日志级别的 printk() 采用的默认级别是
DEFAULT_MESSAGE_LOGLEVEL，这个宏在 kernel/printk.c 中被定义为整数
4，即对应KERN_WARNING。</p>
<p><strong>当printk中指定的级别（级别越小优先级越高）小于当前控制台日志级别时，printk的信息就会在控制台上显示。</strong></p>
<p>所以如果我们想把Hello
World打印到控制台上，可以在输出的文本前加上<code>KERN_ALERT</code>（其他也可以只要优先级大于控制台日志级别）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printk(KERN_ALERT <span class="string">&quot;Hello World!\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>但是这种方法要求每次输出前都要加上，比较麻烦。还有一种一劳永逸的方法，输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 4 3 &gt; /proc/sys/kernel/printk</span><br></pre></td></tr></table></figure>
<p>如果你不是root用户，那么使用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 4 3 | sudo <span class="built_in">dd</span> of=/proc/sys/kernel/printk</span><br></pre></td></tr></table></figure>
<p>在 <code>/proc/sys/kernel/printk</code>中会显示4个数值（可由 echo
修改），分别表示：</p>
<ul>
<li>当前控制台日志级别；</li>
<li>未明确指定日志级别的默认消息日志级别；</li>
<li>最小（最高）允许设置的控制台日志级别；</li>
<li>引导时默认的日志级别；</li>
</ul>
<p>上述命令就将默认消息日志级别改为了3，而控制台日志级别为4，这样就可以输出到屏幕了。</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571273096443.png" class="" width="1571273096443">
<p><strong>注意</strong>：修改用echo修改，不能用vim（但好像个别可以），否则会报Fsync
failed错。因为vim编辑文件是首先创建该文件的一个副本，当保存的时候就用这个副本替换掉原文件。而proc文件系统下的文件并不是真的文件，都是内存中的影像，因此不支持这种编辑方式，所以不能用vim。</p>
<h2 id="避免采坑-1">避免采坑</h2>
<p>我的实验是基于4.16.10版本的。内核版本不同，系统调用的修改可能也略有不同。</p>
<p>缩进最好使用tab键（就是键盘q左边的那个），不要用空格，否则可能有不可预料的错误。</p>
<h1 id="设计一个动态调用模块">设计一个动态调用模块！</h1>
<p>相信很多初学者和我一样，每次修改一下系统调用就要重新编译整个内核，这样做既耗费时间，效率也非常非常低。所以我们现在来一起学习一下动态模块，这样以后我们想加什么功能就直接以动态模块的形式加入到内核，修改之后只用编译我们这个模块就行了。</p>
<h2 id="啥叫动态模块">啥叫动态模块</h2>
<p>维基百科是这样定义的：可加载内核模块（英语：Loadable kernel
module，缩写为
LKM）,又译为加载式核心模块、可装载模块、可加载内核模块，或直接称为内核模块，是一种目标文件（object
file），在其中包含了能在操作系统内核空间运行的代码。它们运行在核心基底（base
kernel），通常是用来支持新的硬件，新的文件系统，或是新增的系统调用（system
calls）。当不需要时，它们也能从存储器中被卸载，清出可用的存储器空间。</p>
<p>由于
Linux属于单内核，单内核扩展性与维护性都很差（大家编译了这么多次内核应该已经深有体会），所以就引入了这么个动态模块，这样一来就大大方便我们添加和修改自己想要的功能。一般动态模块主要是用来写驱动的。</p>
<h2 id="加入自己的hello-module动态模块">加入自己的Hello
Module动态模块</h2>
<p>那么废话少说，现在就让我们来写一个动态模块吧。</p>
<p>首先<code>mkdir mod_hello</code>新建一个文件夹，然后在里面创建我们的动态模块源码mod_a.c：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mod_a.c</span></span><br><span class="line"><span class="comment">//动态模块必须要的三个头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_mymod</span><span class="params">(<span class="type">void</span>)</span>	<span class="comment">//声明是一个模块以及加载时初始化的动作</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;Hello Module!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit_mymod</span><span class="params">(<span class="type">void</span>)</span>	<span class="comment">//卸载模块时的动作</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;Goodbye Module!\n:&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(init_mymod); </span><br><span class="line">module_exit(exit_mymod);</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明模块相关的信息，第一条声明模块的许可证是必要的，2.4.10之后的版本必须声明</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;WPX&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>现在我们就写好了一个模块。这个模块的功能就是在安装的时候输出“Hello
Module!”，卸载的时候输出“Goodbye Module!”。下面我们开始写Makefile：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_MODULE_SIG=n</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(KERNELRELEASE)</span>,)</span><br><span class="line">        obj-m :=mod_a.o</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        KERNELDIR := /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build</span><br><span class="line">PWD := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">modules:</span></span><br><span class="line">        <span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        <span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(PWD)</span> clean</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>关于Makefile的语法这里就不细讲了，有兴趣的同学可以自己学习一下，不难。写好了之后就可以<code>make</code>编译啦：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571292905251.png" class="" width="1571292905251">
<p>生成<code>mod_a.ko</code>文件就说明成功啦。下面就是如何装载和卸载模块了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insmod mod_a.ko	//装载模块</span><br><span class="line"></span><br><span class="line">rmmod mod_a	//卸载模块</span><br></pre></td></tr></table></figure>
<p>装载模块之后我们可以通过<code>lsmod</code>查看系统已装载的模块：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571293144531.png" class="" width="1571293144531">
<p>可以看到我们的模块已经加载到了系统中。现在看看系统日志测试一下我们的语句有没有输出：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571322903655.png" class="" width="1571322903655">
<p>可以看到已经成功输出了，说明我们成功的完成了动态模块的加载！</p>
<p>如果你在加载模块的时候出现以下错误：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571294764926.png" class="" width="1571294764926">
<p>那是因为你之前已经装载过了该模块，所以先卸载这个模块再重新装载就可以了。</p>
<h2 id="避免采坑-2">避免采坑</h2>
<h3 id="模块签名">模块签名</h3>
<p>我刚开始测试的时候，发现日志中报错，然后没有输出：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571290497284.png" class="" width="1571290497284">
<p>这个报错是因为在3.7版本后内核有了模块签名机制，如果模块没有签名在加载的时候就会报这个错。这个有两种解决办法，一种是给模块签名，一种是关掉签名检查机制。这里给出第二种。</p>
<p>关掉签名检查机制一种说法是在Makefile的开头加上<code>CONFIG_MODULE_SIG=n</code>，但是在我测试的时候发现好像没啥用。第二种方法是直接修改内核配置文件，在<code>make menuconfig</code>后修改<code>linux-4.16.10/.config</code>（这是一个隐藏文件）:</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571324205319.png" class="" width="1571324205319">
<p>将CONFIG_MODULE_SIG=y、CONFIG_MODULE_SIG_ALL=y和CONFIG_MODULE_SIG_SHA512=y的y都改成n，然后重新编译内核，经过测试这种方法可以解决问题。</p>
<p>但是经过测试我发现这个签名的报错好像也没什么影响，还是可以正常的输出“Hello
Module!”……有点迷，不是很懂。</p>
<h3 id="section">！！！</h3>
<p>在我还没有解决上面报错的问题时，我又发现一个很奇怪的现象：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571320179038.png" class="" width="1571320179038">
<p>我加载内核的时候输出的是Goodbye我卸载内核的时候输出的是Hello。</p>
<p>我百思不得其解，查了大量的资料，都没找到答案。后来发现……</p>
<p>原因竟然是的因为我printk中没有换行符<code>\n</code>所以实际上输出了但是没有显示在日志里，所以看不见。等到我再加载的时候hello就把goodbye顶上来了所以我只能看见hello。</p>
<p>我就说为啥测试的时候第一遍加载没有输出，卸载输出hello，然后加载输出goodbye，卸载输出hello开始循环。我在这个<code>\n</code>上吃了不少苦头，在上面设计系统调用的时候我一开始也没有加<code>\n</code>，上面那个图加了换行符是我做到这才反应过来换上去的，实际上上面那个图中输出的“Hello
World!!!”是我在截图之前测试了两次，把第一次的顶上来了，我当时以为是输出了，写的时候我还纳闷怎么突然又输出来了。</p>
<p>这个换行符坑了我不知道多少时间，来来回回我因为测试结果有问题又重新编译了好几次内核。</p>
<h1 id="实验一设计一个系统调用">实验一——设计一个系统调用</h1>
<p>知道了如何设计系统调用，我们就可以开始做第一个实验了。</p>
<h2 id="实验内容">实验内容</h2>
<p>设计一个系统调用，功能是将系统的相关信息（CPU型号、操作系统的版本号、系统中的进程等类似于Windows的任务管理器的信息）以文本形式列表显示于屏幕，并编写用户程序予以验证。</p>
<h2 id="前导知识">前导知识</h2>
<p>要输出CPU型号，操作系统的版本号和系统中的进程，首先得知道我们去哪里找这些信息。</p>
<p>CPU型号和操作系统我们可以在<code>/proc</code>文件夹下找到：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cpuinfo	<span class="comment">#cpu信息</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> /proc/version 	<span class="comment">#系统版本信息</span></span><br></pre></td></tr></table></figure>
<p>关于<code>/proc</code>文件夹，在“加入自己的Hello
Module动态模块”的最后我提到了一下。实际上<code>/proc</code>是一个位于内存的<strong>伪文件系统</strong>，通过<code>/proc</code>我们可以运行时访问内核内部数据结构、改变内核设置的机制。用户和应用程序可以通过<code>/proc</code>得到系统的信息，并可以改变内核的某些参数。由于系统的信息，如进程，是动态改变的，所以用户或应用程序读取<code>/proc</code>文件时，<code>/proc</code>文件系统是动态从系统内核读出所需信息并提交的。
注意<code>/proc</code>里面的文件不是真的存在于硬盘中的文件，它们只是内存中的映像。</p>
<p>系统中的进程相关信息记录在<code>task_struct</code>结构体中。<code>task_struct</code>是Linux内核的一种数据结构，它会被装载到RAM中并且包含着进程的信息。每个进程都把它的信息放在
<code>task_struct</code>这个数据结构体。具体使用在代码中就可以看到。</p>
<p>这两部分内容这里都只是简单提了一下，如果要是深入讲解那又可以写两篇文章了，秉着知识屏蔽的原则，这里不展开讲了。各位读者感兴趣可以自学一下。</p>
<h2 id="实验思路">实验思路</h2>
<p>我们要设计一个系统调用，如果直接修改内核添加系统调用然后编译内核进行调试，那效率实在是太低（一次写成的大佬当我没说），因此我首先用动态模块把程序写好，然后再添加到系统调用里并重新编译，这样就大大提高了效率。</p>
<p>实际上，也可以用动态模块直接写一个钩子来修改系统调用（注意是修改不是添加，动态模块没法添加系统调用，但是可以修改现有的系统调用），但是由于要利用sys_call_table表，而在实验过程中发现4.16.10版本中获取sys_call_table表的地址存在许多问题，由于我目前水平太菜还没有解决，所以这种方法先暂时不用，以后应该会更新这个方法。</p>
<p>这个实验思路很直接，就是找到所需要的信息并打印出来。</p>
<h2 id="代码实现">代码实现</h2>
<p>知道了信息的位置，那剩下的就是代码实现了。这里给出我的动态模块源代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/sched/signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> buf[<span class="number">41</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> buf1[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_mymod</span><span class="params">(<span class="type">void</span>)</span>    <span class="comment">//声明是一个模块以及加载时初始化的动作</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">fp</span>;</span></span><br><span class="line">    <span class="type">mm_segment_t</span> fs;</span><br><span class="line">    <span class="type">loff_t</span> pos;</span><br><span class="line"></span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;Hello Module!\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//准备打印CPU型号</span></span><br><span class="line">    printk(<span class="string">&quot;/***************cpu info****************/\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fp = filp_open(<span class="string">&quot;/proc/cpuinfo&quot;</span>,O_RDONLY,<span class="number">0</span>);<span class="comment">//打开文件并存到结构体中，准备进行后续操作</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(IS_ERR(fp)) <span class="comment">//判断文件是否正常打开</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;create file error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fs = get_fs();</span><br><span class="line">    set_fs(KERNEL_DS);</span><br><span class="line"></span><br><span class="line">    pos = <span class="number">79</span>;	<span class="comment">//文件操作的起始位置</span></span><br><span class="line">    kernel_read(fp,buf,<span class="keyword">sizeof</span>(buf),&amp;pos);</span><br><span class="line">	printk(KERN_ALERT <span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">    </span><br><span class="line">    filp_close(fp,<span class="literal">NULL</span>);</span><br><span class="line">    set_fs(fs);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//准备打印系统版本信息</span></span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;/***************system version****************/\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	fp = filp_open(<span class="string">&quot;/proc/version&quot;</span>,O_RDONLY,<span class="number">0</span>);<span class="comment">//open file</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(IS_ERR(fp)) </span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;create file error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fs = get_fs();</span><br><span class="line">    set_fs(KERNEL_DS);</span><br><span class="line"></span><br><span class="line">    pos = <span class="number">0</span>;</span><br><span class="line">    kernel_read(fp,buf1,<span class="keyword">sizeof</span>(buf1),&amp;pos);</span><br><span class="line">	printk(KERN_ALERT <span class="string">&quot;%s\n&quot;</span>,buf1);</span><br><span class="line">    </span><br><span class="line">    filp_close(fp,<span class="literal">NULL</span>);</span><br><span class="line">    set_fs(fs);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//准备打印进程信息</span></span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;/*************processes information**************/\n&quot;</span>);</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;%-20s%-10s%-15s%-15s%-10s\n&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;pid&quot;</span>,<span class="string">&quot;time(userM)&quot;</span>,<span class="string">&quot;time(kernelM)&quot;</span>,<span class="string">&quot;state&quot;</span>);</span><br><span class="line">    for_each_process(p)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;%-20s%-10d%-15lld%-15lld%-5ld\n&quot;</span>,p-&gt;comm,p-&gt;pid,(p-&gt;utime)/<span class="number">60</span>,(p-&gt;stime)/<span class="number">60</span>,p-&gt;state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit_mymod</span><span class="params">(<span class="type">void</span>)</span>   <span class="comment">//卸载模块时的动作</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;Goodbye Module!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(init_mymod);</span><br><span class="line">module_exit(exit_mymod);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;WPX&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>需要注意的是第一个输出CPU型号的buf和pos需要自己设置成适合自己的，因为每个人的CPU型号不同，我设置测试的最终结果如图，正好把我的型号输出出来：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571817038619.png" class="" width="1571817038619">
<p>现在加载我们的模块看看效果（长图预警）：</p>
<p><img src="/2019/10/17/Lecture/OS实验之玩转linux内核/2019-10-23_172003.png"  alt="2019-10-23_172003" style="zoom:60%;" /></p>
<p>看上去还不错！那么现在我们就可以把它添加到系统调用里去了，添加方法上文已经说了。（修改sys.c的时候不要忘了添加头文件哦！）</p>
<p>最终添加的系统调用号为334，调用具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_getinfo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> buf[<span class="number">41</span>];</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> buf1[<span class="number">1024</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">fp</span>;</span></span><br><span class="line">    <span class="type">mm_segment_t</span> fs;</span><br><span class="line">    <span class="type">loff_t</span> pos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备打印CPU型号</span></span><br><span class="line">    printk(<span class="string">&quot;/***************cpu info****************/\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fp = filp_open(<span class="string">&quot;/proc/cpuinfo&quot;</span>,O_RDONLY,<span class="number">0</span>);<span class="comment">//打开文件并存到结构体中，准备进行后续操作</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(IS_ERR(fp)) <span class="comment">//判断文件是否正常打开</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;create file error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fs = get_fs();</span><br><span class="line">    set_fs(KERNEL_DS);</span><br><span class="line"></span><br><span class="line">    pos = <span class="number">79</span>;	<span class="comment">//文件操作的起始位置</span></span><br><span class="line">    kernel_read(fp,buf,<span class="keyword">sizeof</span>(buf),&amp;pos);</span><br><span class="line">	printk(KERN_ALERT <span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">    </span><br><span class="line">    filp_close(fp,<span class="literal">NULL</span>);</span><br><span class="line">    set_fs(fs);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//准备打印系统版本信息</span></span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;/***************system version****************/\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	fp = filp_open(<span class="string">&quot;/proc/version&quot;</span>,O_RDONLY,<span class="number">0</span>);<span class="comment">//open file</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(IS_ERR(fp)) </span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;create file error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fs = get_fs();</span><br><span class="line">    set_fs(KERNEL_DS);</span><br><span class="line"></span><br><span class="line">    pos = <span class="number">0</span>;</span><br><span class="line">    kernel_read(fp,buf1,<span class="keyword">sizeof</span>(buf1),&amp;pos);</span><br><span class="line">	printk(KERN_ALERT <span class="string">&quot;%s\n&quot;</span>,buf1);</span><br><span class="line">    </span><br><span class="line">    filp_close(fp,<span class="literal">NULL</span>);</span><br><span class="line">    set_fs(fs);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//准备打印进程信息</span></span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;/*************processes information**************/\n&quot;</span>);</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;%-20s%-10s%-15s%-15s%-10s\n&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;pid&quot;</span>,<span class="string">&quot;time(userM)&quot;</span>,<span class="string">&quot;time(kernelM)&quot;</span>,<span class="string">&quot;state&quot;</span>);</span><br><span class="line">    for_each_process(p)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;%-20s%-10d%-15lld%-15lld%-5ld\n&quot;</span>,p-&gt;comm,p-&gt;pid,(p-&gt;utime)/<span class="number">60</span>,(p-&gt;stime)/<span class="number">60</span>,p-&gt;state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">334</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用上次测试系统调用的程序测试一下：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571822845749.png" class="" width="1571822845749">
<p>输出到了控制台中，系统调用成功！</p>
<p>注意：我使用的是ubuntu
server，使用的终端是物理终端，而printk输出的位置就是物理终端，如果你使用的是图形化界面，那么你可能会发现信息没有输出到你的终端上，因为图形化界面使用的不是物理终端，需要用户更改为物理终端，更改方法可以在网上查找资料。</p>
<h2 id="避免采坑-3">避免采坑</h2>
<h3 id="vfs_read">vfs_read……</h3>
<p>我看网上说内核用vfs_read、vfs_write等函数来操作文件，但是我写的时候报错说未定义的函数。我找了半天最后发现是在4.14版本以后，内核不再支持vfs_read、vfs_write等函数，而是改用kernel_read、kernel_write等函数。如果使用vfs_read、vfs_write等函数会报错。把vfs改成kernel就好了。</p>
<h3 id="用户空间和系统空间">用户空间和系统空间</h3>
<p>在对文件进行操作的时候，我直接使用了kernel_read函数，然后报错了。后来发现是因为kernel_read等函数它们默认的参数（buf）是指向用户空间的内存地址，而现在buf在内核空间，因此会出错。这个可以通过get_fs和set_fs修改。简单来说就是这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">mm_segment_t</span> fs = get_fs();</span><br><span class="line">set_fs(KERNEL_DS);</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后开始文件操作例如kernel_read()</span></span><br><span class="line"></span><br><span class="line">filp_close(fp,<span class="literal">NULL</span>);</span><br><span class="line">set_fs(fs);</span><br></pre></td></tr></table></figure>
<p>具体的知识点这里不讲了，有兴趣的可以自行上网学习，这里给一篇参考文章：<a
target="_blank" rel="noopener" href="https://blog.csdn.net/Tommy_wxie/article/details/8194276">《在linux内核中读写文件》</a>。</p>
<h3 id="sys_call_table地址">sys_call_table地址</h3>
<p>本来我想直接用动态模块写个钩子修改系统调用，结果获得地址之后运行发现永远不对，后来发现在linux2.6版本之后，出于保护系统的目的，不能直接导出sys_call_table的地址，因此使用如下命令得到的地址不是真实的物理地址，不能直接使用：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571498488155.png" class="" width="1571498488155">
<p>否则会报错，而且模块无法通过<code>rmmod</code>命令卸载，会显示正在使用，非常棘手（有解决办法，但很麻烦，所以我每次都是直接恢复快照）。</p>
<h3 id="获取文件大小">获取文件大小</h3>
<p>在写代码的时候因为cpuinfo太长了打印不完，我一开始想动态获取文件大小然后再打印整个文件。在网上找了很多办法，看到别人用f-&gt;f_dentry-&gt;d_inode，但是我每次都报错，后来发现是在3.19版本之后内核不支持f-&gt;f_dentry-&gt;d_inode了，需要使用file_inode(f)替换掉f-&gt;f_dentry-&gt;d_inode。具体如下：</p>
<p>Linux 3.19 compat: file_inode was added</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct access f-&gt;f_dentry-&gt;d_inode was replaced by accessor function</span><br><span class="line">file_inode(f)</span><br><span class="line"></span><br><span class="line">Signed-off-by: Joerg Thalheim &lt;joerg@higgsboson.tk&gt;</span><br><span class="line">Signed-off-by: Brian Behlendorf &lt;behlendorf1@llnl.gov&gt;</span><br></pre></td></tr></table></figure>
<p>修改之后编译成功了发现获取的大小是0，后来才反应过来<code>/proc</code>中的文件不是真的文件因此没有大小可言……再后来反应过来要求不是要CPU型号嘛，那我直接光输出个型号不就可以了吗！</p>
<h3 id="for_each_process">for_each_process</h3>
<p>在使用
for_each_process时，有很多资料显示需要添加的头文件为<code>linux/sched.h</code>，但我编译的时候发现报错：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1571806269316.png" class="" width="1571806269316">
<p>后来发现在
4.11以后，该方法都放在了<code>include/linux/sched/signal.h</code>中
,因此需要修改头文件，修改之后就好了。</p>
<h1 id="实验2-1进程的软中断通信">实验2-1——进程的软中断通信</h1>
<h2 id="实验内容-1">实验内容</h2>
<p>编制实现软中断通信的程序。使用系统调用fork()创建两个子进程，再用系统调用signal()让父进程捕捉键盘上发出的中断信号（即按delete键），当父进程接收到这两个软中断的某一个后，父进程用系统调用kill()向两个子进程分别发出整数值为16和17软中断信号，子进程获得对应软中断信号，然后分别输出下列信息后终止：</p>
<ul>
<li>Child process 1 is killed by parent !!<br />
</li>
<li>Child process 2 is killed by parent !!</li>
</ul>
<p>父进程调用wait()函数等待两个子进程终止后，输出以下信息，结束进程执行：</p>
<ul>
<li>Parent process is killed!!</li>
</ul>
<p>多运行几次编写的程序，简略分析出现不同结果的原因。</p>
<h2 id="前导知识-1">前导知识</h2>
<h3 id="fork">fork()</h3>
<p>这里简单说一下，fork()的作用就是创建一个子进程，fork把父进程复制一份给子进程，需要注意的是fork返回值是两个。在子进程中返回0，父进程中返回子进程的pid，还有一种情况是创建失败时会返回-1。</p>
<p>如果想深入了解推荐一个大佬的博客，写的有多好呢？这么说吧，我第一次见到CSDN光评论就几百条的（可能是我见识太少）：<a
target="_blank" rel="noopener" href="https://blog.csdn.net/jason314/article/details/5640969">《linux中fork（）函数详解（原创！！实例讲解）》</a></p>
<h3 id="signal">signal()</h3>
<p>捕捉中断信号sig后执行function规定的操作。就有点像if语句，捕获到信号之后就调用指定的函数。</p>
<p>用法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span>	<span class="comment">//头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sig;</span><br><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">signal(sig,function)	<span class="comment">//参数定义</span></span><br></pre></td></tr></table></figure>
<p>sig一个有19个值：</p>
<table>
<thead>
<tr class="header">
<th>值</th>
<th>名字</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>01</td>
<td>SIGHUP</td>
<td>挂起</td>
</tr>
<tr class="even">
<td>02</td>
<td>SIGINT</td>
<td>中断，当用户从键盘键入“del”键时</td>
</tr>
<tr class="odd">
<td>03</td>
<td>SIGQUIT</td>
<td>退出，当用户从键盘键入“quit”键时</td>
</tr>
<tr class="even">
<td>04</td>
<td>SIGILL</td>
<td>非法指令</td>
</tr>
<tr class="odd">
<td>05</td>
<td>SIGTRAP</td>
<td>断点或跟踪指令</td>
</tr>
<tr class="even">
<td>06</td>
<td>SIGIOT</td>
<td>IOT指令</td>
</tr>
<tr class="odd">
<td>07</td>
<td>SIGEMT</td>
<td>EMT指令</td>
</tr>
<tr class="even">
<td>08</td>
<td>SIGFPE</td>
<td>浮点运算溢出</td>
</tr>
<tr class="odd">
<td>09</td>
<td>SIGKILL</td>
<td>要求终止进程</td>
</tr>
<tr class="even">
<td>10</td>
<td>SIGBUS</td>
<td>总线错误</td>
</tr>
<tr class="odd">
<td>11</td>
<td>SIGSEGV</td>
<td>段违例，即进程试图去访问其地址空间以外的地址</td>
</tr>
<tr class="even">
<td>12</td>
<td>SIGSYS</td>
<td>系统调用错</td>
</tr>
<tr class="odd">
<td>13</td>
<td>SIGPIPE</td>
<td>向无读者的管道中写数据</td>
</tr>
<tr class="even">
<td>14</td>
<td>SIGALARM</td>
<td>闹钟</td>
</tr>
<tr class="odd">
<td>15</td>
<td>SIGTERM</td>
<td>软件终止</td>
</tr>
<tr class="even">
<td>16</td>
<td>SIGUSR1</td>
<td>用户自定义信号</td>
</tr>
<tr class="odd">
<td>17</td>
<td>SIGUSR2</td>
<td>用户自定义信号</td>
</tr>
<tr class="even">
<td>18</td>
<td>SIGCLD</td>
<td>子进程死</td>
</tr>
<tr class="odd">
<td>19</td>
<td>SIGPWR</td>
<td>电源故障</td>
</tr>
</tbody>
</table>
<h3 id="kill">kill()</h3>
<p>一个进程向同一用户的其他进程pid发送信号。</p>
<p>用法为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"><span class="type">int</span> sig;</span><br><span class="line"></span><br><span class="line">kill(pid,sig);</span><br></pre></td></tr></table></figure>
<p>pid：可能选择有以下四种</p>
<ol type="1">
<li>pid大于零时，pid是信号欲送往的进程的标识。</li>
<li>pid等于零时，信号将送往所有与调用kill()的那个进程属同一个组的进程。</li>
<li>pid等于-1时，信号将送往所有调用进程有权给其发送信号的进程，除了进程1(init)。</li>
<li>pid小于-1时，信号将送往以-pid为组标识的进程。</li>
</ol>
<p>sig：准备发送的信号代码，假如其值为零则没有任何信号送出，但是系统会执行错误检查，通常会利用sig值为零来检验某个进程是否仍在执行。</p>
<p>返回值说明： 成功执行时，返回0；失败返回-1。</p>
<h2 id="实验思路-1">实验思路</h2>
<p>要求很明确，很直接。需要注意的就是在代码实现的时候注意写父进程和子进程的运行语句的位置，有的时候很容易把人绕进去。</p>
<h2 id="代码实现-1">代码实现</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*	ex2.c</span></span><br><span class="line"><span class="comment"> *	Copyright (c) wpx</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> wait_flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;wait_flag = <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> p1,p2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>((p1 = fork()) == <span class="number">-1</span>);	<span class="comment">//创建子进程1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>((p2 = fork()) == <span class="number">-1</span>);	<span class="comment">//创建子进程2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p2)	<span class="comment">//父进程执行语句</span></span><br><span class="line">        &#123;</span><br><span class="line">            signal(SIGQUIT,stop);</span><br><span class="line">            <span class="keyword">while</span>(wait_flag);	<span class="comment">//等待软中断Quit信号(Ctrl + \)</span></span><br><span class="line">            </span><br><span class="line">            kill(p1,<span class="number">16</span>);</span><br><span class="line">            kill(p2,<span class="number">17</span>);</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">            sleep(<span class="number">3</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\nParent process is killed !!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span>	<span class="comment">//子进程2执行语句</span></span><br><span class="line">        &#123;</span><br><span class="line">            signal(SIGQUIT,SIG_IGN);	<span class="comment">//忽略Quit信号</span></span><br><span class="line">            wait_flag = <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            signal(<span class="number">17</span>,stop);</span><br><span class="line">            <span class="keyword">while</span>(wait_flag);</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\nChild process 2 is killed by parent !!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span>	<span class="comment">//子进程1执行语句</span></span><br><span class="line">    &#123;</span><br><span class="line">        signal(SIGQUIT,SIG_IGN);</span><br><span class="line">       	wait_flag = <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">        signal(<span class="number">16</span>,stop);</span><br><span class="line">        <span class="keyword">while</span>(wait_flag);</span><br><span class="line">            </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nChild process 1 is killed by parent !!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，键盘输入Quit信号（ctrl+），子进程12退出，父进程等待3秒后退出：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1572248369602.png" class="" width="1572248369602">
<p>多次执行会发现子进程结束时间不确定：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1572252482068.png" class="" width="1572252482068">
<p>原因可能是因为子进程之间是彼此并行的，两个子进程同时获得信号，因此结束时间不确定。</p>
<h2 id="避免采坑-4">避免采坑</h2>
<h3 id="while语句">while语句</h3>
<p>我在创建子进程的时候少加了一个括号，我是这样写的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(p1 = fork() == <span class="number">-1</span>);</span><br></pre></td></tr></table></figure>
<p>在运行程序的时候死活没结果，输入啥也不行，ctrl++c强制退出</p>
<p>后来发现其实我在这一步就有问题了，正确的写法是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>((p1 = fork()) == <span class="number">-1</span>);</span><br></pre></td></tr></table></figure>
<p>加个括号之后，程序就成功运行了。</p>
<h3 id="信号忽略sig_ign">信号忽略SIG_IGN</h3>
<p>我的代码在子进程中有一句<code>signal(SIGQUIT,SIG_IGN)</code>，实际上在一开始我并没有加这句代码。在我运行的过程中我发现，不管我试了多少次，子进程都没有输出，只有父进程输出了：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1572248861081.png" class="" width="1572248861081">
<p>后来我发现如果我不用键盘输入quit，而是在一个新的终端中用kill命令给父进程quit信号，那么就能正常输出。</p>
<p>先通过<code>ps -a</code>获取父进程pid号（pid最小的就是父进程），然后使用<code>kill -QUIT 父进程pid号</code>给进程发送信号：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/1572249333433.png" class="" width="1572249333433">
<p>可以看到通过这种方式成功输出了我们想要的结果。我想了半天，但是还是没懂到底是怎么回事。我猜测可能是因为键盘直接输入的方式同时作用于三个进程，直接杀死了剩下两个子进程导致没有输出。所以在子进程中加上忽略Quit信号，这样quit只作用于父进程，子进程就可以收到父进程的信号打印语句了。</p>
<h1 id="实验2-2进程的管道通信">实验2-2——进程的管道通信</h1>
<h2 id="实验内容-2">实验内容</h2>
<p>创建一条管道完成下述工作：</p>
<ol type="1">
<li>分配一个隶属于root文件系统的磁盘和内存索引结点inode.</li>
<li>在系统打开文件表中分别分配一读管道文件表项和一写管道文件表项。</li>
<li>在创建管道的进程控制块的文件描述表（进程打开文件表u-ofile）
中分配二表项，表项中的偏移量filedes[0]和filedes[1]分别指向系统打开文件表的读和写管道文件表项。</li>
</ol>
<p>系统调用所涉及的数据结构如下图所示：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/%E5%9B%BE%E7%89%871.png" class="" title="图片1">
<h2 id="前导知识-2">前导知识</h2>
<h3 id="管道">管道</h3>
<p>所谓“管道”，是指用于连接一个读进程和一个写进程以实现他们之间通信的一个共享文件，又名pipe文件。管道分为匿名管道和命名管道。向管道(共享文件)提供输入的发送进程(即写进程)，以字符流形式将大量的数据送入管道；而接受管道输出的接收进程(即读进程)，则从管道中接收(读)数据。由于发送进程和接收进程是利用管道进行通信的，故又称为管道通信。</p>
<p>管道分为匿名管道和命名管道，匿名管道只能用于有亲缘关系的进程（这是由管道利用fork的实现机制所决定的），而命名管道可以用于任意两个进程。由于本实验不涉及命名管道，所以暂且不提，有兴趣的读者可以自行学习。</p>
<p>匿名管道通过<code>int pipe(int fd[2])</code>创建。管道通过read和write函数进行读写。fd[0]是读端，fd[1]是写端。两个进程分别使用读和写端，就可以实现通信。注意在读或写的时候需要用lockf锁定当前端，或者用close关闭另一端</p>
<h3 id="read">read()</h3>
<p>头文件：#include &lt;unistd.h&gt;</p>
<p>函数定义： ssize_t read(int fd, void * buf, size_t count);</p>
<p>函数说明：read从fd中读取count个字节存入buf中。</p>
<h3 id="write">write()</h3>
<p>头文件：#include &lt;unistd.h&gt;</p>
<p>函数定义：ssize_t write(int fd, void * buf, size_t count);</p>
<p>函数说明：write把buf中的count个字节写入fd中。</p>
<h3 id="sprintf">sprintf()</h3>
<p>和printf类似，只不过printf把格式化内容打印到屏幕上，而sprintf把格式化的内容保存到字符串中。例如：sprintf(s,"%d",123);
//把123保存在s中</p>
<h3 id="lockf">lockf()</h3>
<p>头文件：#include &lt;unistd.h&gt;</p>
<p>函数定义： int lockf(int fd, int function, long size)</p>
<p>函数说明：fd是文件描述符，function表示锁状态，1表示锁定，0表示解锁，size是锁定或解锁的字节数，若为0则表示整个文件。</p>
<h2 id="实现思路">实现思路</h2>
<p>这个实验实际上意思就是父进程创建两个子进程，子进程分别通过管道给父进程发送一条信息“Child
process 1 is sending message!”、“Child process 2 is sending
message!”，父进程获取并打印消息然后退出。</p>
<h2 id="代码实现-2">代码实现</h2>
<p>使用lockf，如果要用close的话就把lockf删了，然后把close的注释符删掉</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> p1,p2;</span><br><span class="line">    <span class="type">char</span> outpipe[<span class="number">50</span>],inpipe[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    pipe(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>((p1 == fork()) == <span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p1)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">while</span>((p2 = fork()) == <span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p2)	<span class="comment">//父进程执行语句</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//close(fd[1]);</span></span><br><span class="line">            wait(<span class="number">0</span>);	<span class="comment">//等待子进程1结束</span></span><br><span class="line">            read(fd[<span class="number">0</span>],inpipe,<span class="number">50</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,inpipe);</span><br><span class="line">            </span><br><span class="line">            wait(<span class="number">0</span>);	<span class="comment">//等待子进程2结束</span></span><br><span class="line">            read(fd[<span class="number">0</span>],inpipe,<span class="number">50</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,inpipe);</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span>	<span class="comment">//子进程2执行语句</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//close(fd[0]);</span></span><br><span class="line">            lockf(fd[<span class="number">1</span>],<span class="number">1</span>,<span class="number">0</span>);	<span class="comment">//锁定管道</span></span><br><span class="line">			</span><br><span class="line">            <span class="built_in">sprintf</span>(outpipe,<span class="string">&quot;\nChild process 2 is sending message!\n&quot;</span>);</span><br><span class="line">            write(fd[<span class="number">1</span>],outpipe,<span class="number">50</span>);</span><br><span class="line">            </span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            </span><br><span class="line">            lockf(fd[<span class="number">1</span>],<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span>	<span class="comment">//子进程1执行语句</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//close(fd[0]);</span></span><br><span class="line">        lockf(fd[<span class="number">1</span>],<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">sprintf</span>(outpipe,<span class="string">&quot;\nChild process 1 is sending message!\n&quot;</span>);</span><br><span class="line">        write(fd[<span class="number">1</span>],outpipe,<span class="number">50</span>);</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        lockf(fd[<span class="number">1</span>],<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实验结果如图：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/image-20191029155551912.png" class="" title="image-20191029155551912">
<p>但有趣的是，使用lockf和close的运行结果有些许差异，使用lockf是先输出p1再输出p2，而使用close则几乎同时输出。</p>
<p>使用lockf：</p>
<p><img src="/2019/10/17/Lecture/OS实验之玩转linux内核/lockf.gif"  alt="lockf" style="zoom:150%;" /></p>
<p>使用close：</p>
<p><img src="/2019/10/17/Lecture/OS实验之玩转linux内核/close.gif"  alt="close" style="zoom: 162%;" /></p>
<p>具体原因不是很懂，如果有知道的大佬请教教小弟。</p>
<h2 id="避免采坑-5">避免采坑</h2>
<p>这个实验比较简单，我在做的时候没有什么困扰我很久的坑。就是注意几个函数的用法、参数的位置就行了。</p>
<h1 id="实验2-3内存的分配与回收">实验2-3——内存的分配与回收</h1>
<h2 id="实验内容-3">实验内容</h2>
<p>通过深入理解内存分配管理的三种算法，定义相应的数据结构，编写具体代码。
充分模拟三种算法的实现过程，并通过对比，分析三种算法的优劣。
（1）掌握内存分配FF，BF，WF策略及实现的思路；
（2）掌握内存回收过程及实现思路；
（3）参考给出的代码思路，实现内存的申请、释放的管理程序，调试运行，总结程序设计中出现的问题并找出原因，写出实验报告。</p>
<p>主要功能：</p>
<p>1 - Set memory size (default=1024) 设置内存的大小 2 - Select memory
allocation algorithm 设置当前的分配算法 3 - New process
创建新的进程，主要是获取内存的申请数量 4 - Terminate a process
删除进程，归还分配的存储空间，并删除描述该进程内存分配的节点 5 - Display
memory usage 显示当前内存的使用情况，包括空闲区的情况和已经分配的情况 0
- Exit</p>
<h2 id="前导知识-3">前导知识</h2>
<h3 id="ffbfwf算法">FF、BF、WF算法</h3>
<p>这三个算法是这次实验的核心。具体的东西课上都讲过，网上也一大堆。简单说一下。FF就是把进程分给第一个匹配的内存块；BF就是把进程分给能容纳进程的最小的内存块，WF和BF相反，就是把进程分给能容纳进程的最大的内存块。</p>
<h3 id="链表">链表</h3>
<p>这次实验中内存的数据结构使用的是链表（更准确的说是单链表），因此需要对链表以及链表的操作有一定了解。链表的操作很多，鉴于篇幅问题这里不赘述了，网上很多相关资料，不熟悉的童鞋可以自行搜索。</p>
<h2 id="实现思路-1">实现思路</h2>
<p>这个实验涉及的模块很多，结果比较复杂，我在编写的过程中经常把自己绕晕，因此我画了一张思维导图，便于理解：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/image-20191107220233737.png" class="" title="image-20191107220233737">
<p>下面我们就按照这个结构来依次实现各个模块。</p>
<h2 id="代码实现-3">代码实现</h2>
<p>程序在windows平台使用VS
2019编写，经测试windows和linux平台均可正常运行</p>
<p>注意：</p>
<ol type="1">
<li>如果使用VS编写scanf会报错，这是VS的安全检查机制导致的，取消报错的方法网上很多，这里就不赘述了。</li>
<li>函数之间可能存在调用关系，因此注意函数之间的顺序或者提前进行函数声明。</li>
</ol>
<p>友情提示：有的模块代码较长，如果看着不方便可点击代码块全屏浏览哦</p>
<h3 id="主要数据结构">主要数据结构</h3>
<h4 id="内存空闲分区的描述">内存空闲分区的描述</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//描述每一个空闲块的数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_block_type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> start_addr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">free_block_type</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//指向内存中空闲块链表的首指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_block_type</span>* <span class="title">free_block_head</span> =</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<h4 id="已分配内存块的描述">已分配内存块的描述</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">allocated_block</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> start_addr;</span><br><span class="line">    <span class="type">char</span> process_name[PROCESS_NAME_LEN];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">allocated_block</span>* <span class="title">next</span></span></span><br><span class="line"><span class="class">&#125;;</span></span><br><span class="line"><span class="comment">//进程分配内存块链表的首指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">allocated_block</span>* <span class="title">allocated_block_head</span> =</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<h4 id="常量定义">常量定义</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>	PROCESS_NAME_LEN	32	<span class="comment">//进程名长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MIN_SLICE	10	<span class="comment">//最小碎片大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	DEFAULT_MEM_SIZE	1024	<span class="comment">//默认内存大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MEM_START	0	<span class="comment">//内存起始位置</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MA_FF	1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MA_BF	2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MA_WF	3</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mem_size = DEFAULT_MEM_SIZE;	<span class="comment">//可用内存大小，初始化为默认内存大小</span></span><br><span class="line"><span class="type">int</span> mem_size_total = DEFAULT_MEM_SIZE;	<span class="comment">//总共内存大小，初始化为默认大小</span></span><br><span class="line"><span class="type">int</span> ma_algorithm = MA_FF;	<span class="comment">//当前内存分配算法，初始化为FF</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> pid = <span class="number">0</span>;	<span class="comment">//进程pid号，初始值为0</span></span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;	<span class="comment">//设置内存大小标志，防止重新设置</span></span><br></pre></td></tr></table></figure>
<h3 id="函数模块">函数模块</h3>
<h4 id="主函数及菜单">主函数及菜单</h4>
<h5 id="主函数">主函数</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> choice;</span><br><span class="line">	free_block_head = init_free_block(mem_size);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		display_menu();	<span class="comment">//显示菜单</span></span><br><span class="line">		fflush(<span class="built_in">stdin</span>);	<span class="comment">//清空缓冲区，防止误选</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choice);	<span class="comment">//获取用户输入</span></span><br><span class="line">		<span class="keyword">if</span> (choice &lt;= <span class="number">5</span> &amp;&amp; choice &gt;= <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">switch</span> (choice)</span><br><span class="line">			&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>: set_mem_size(); <span class="keyword">break</span>;	<span class="comment">//设置内存大小</span></span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>: set_algorithm(); flag = <span class="number">1</span>; <span class="keyword">break</span>;	<span class="comment">//设置算法</span></span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>: new_process(); flag = <span class="number">1</span>; <span class="keyword">break</span>;	<span class="comment">//创建新进程</span></span><br><span class="line">			<span class="keyword">case</span> <span class="number">4</span>: kill_process(); flag = <span class="number">1</span>; <span class="keyword">break</span>;	<span class="comment">//删除进程</span></span><br><span class="line">			<span class="keyword">case</span> <span class="number">5</span>: display_mem_usage(); flag = <span class="number">1</span>; <span class="keyword">break</span>;	<span class="comment">//显示内存使用</span></span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>: do_exit(); <span class="built_in">exit</span>(<span class="number">0</span>);	<span class="comment">//释放链表并退出</span></span><br><span class="line">			<span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\nInvalid choice, please select again!\n\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="显示菜单">显示菜单</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">display_menu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;----------------------------------------\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;      Memory Management Experiment\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;          (c) WPX 2176112425\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;               2019.11.3\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;----------------------------------------\n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;current algo: %d\tcurrent mem_size: %d\n\n&quot;</span>, ma_algorithm, mem_size_total);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Please enter a number to select the appropriate function:\n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1 -- Set memory size(default=%d)\n&quot;</span>, DEFAULT_MEM_SIZE);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;2 -- Select memory allocation algorithm\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;3 -- New process\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;4 -- Terminate a process\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;5 -- Display memory usage\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0 -- Exit\n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="初始化内存">初始化内存</h4>
<h5 id="初始化空闲块">初始化空闲块</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> free_block_type* <span class="title function_">init_free_block</span><span class="params">(<span class="type">int</span> mem_size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_block_type</span>* <span class="title">fb</span>;</span></span><br><span class="line">	fb = (<span class="keyword">struct</span> free_block_type*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> free_block_type));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fb == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;No memory!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fb-&gt;size = mem_size;</span><br><span class="line">	fb-&gt;start_addr = DEFAULT_MEM_START;</span><br><span class="line">	fb-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> fb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="设置内存大小">设置内存大小</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">set_mem_size</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flag)	<span class="comment">//检查是否重复设置</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Cannot set memory size again!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nTotal memory size = &quot;</span>);</span><br><span class="line">	fflush(<span class="built_in">stdin</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;size);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (size &gt;= <span class="number">0</span>)	<span class="comment">//检查内存大小是否合法</span></span><br><span class="line">	&#123;</span><br><span class="line">		mem_size = size;</span><br><span class="line">		mem_size_total = size;</span><br><span class="line">		free_block_head-&gt;size = mem_size;</span><br><span class="line">		flag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Memory size is not valid!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="设置内存算法">设置内存算法</h4>
<h5 id="显示设置菜单">显示设置菜单</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">set_algorithm</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> algorithm;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Please enter a number to select the appropriate algorithm:\n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1 -- First Fit\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;2 -- Best Fit\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;3 -- Worst Fit\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt; &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;algorithm);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (algorithm &gt;= <span class="number">1</span> &amp;&amp; algorithm &lt;= <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ma_algorithm = algorithm;</span><br><span class="line">		rearrange(ma_algorithm);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Invalid choice!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="按指定算法重新排列空闲区链表">按指定算法重新排列空闲区链表</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rearrange</span><span class="params">(<span class="type">int</span> algorithm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (algorithm)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> MA_FF: rearrange_FF(); <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> MA_BF:	rearrange_BF(); <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> MA_WF: rearrange_WF(); <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建进程载入内存">创建进程载入内存</h4>
<h5 id="创建新进程获取内存申请数量">创建新进程，获取内存申请数量</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">new_process</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">allocated_block</span>* <span class="title">ab</span>;</span></span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">	<span class="comment">//给进程分配内存的结果</span></span><br><span class="line">	<span class="type">int</span> allocate_ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建一个进程</span></span><br><span class="line">	ab = (<span class="keyword">struct</span> allocated_block*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> allocated_block));</span><br><span class="line">	<span class="keyword">if</span> (!ab)	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//确定进程属性</span></span><br><span class="line">	ab-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	pid++;</span><br><span class="line">	<span class="built_in">sprintf</span>(ab-&gt;process_name, <span class="string">&quot;PROCESS-%02d&quot;</span>, pid);</span><br><span class="line">	ab-&gt;pid = pid;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nPlease input the memory for PROCESS-%02d: &quot;</span>, pid);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;size);</span><br><span class="line">	<span class="keyword">if</span> (size &gt; <span class="number">0</span>)	ab-&gt;size = size;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\nInvalid memory size!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从空闲区分配内存，返回分配结果。1表示分配成功，-1表示分配失败</span></span><br><span class="line">	allocate_ret = allocate_mem(ab);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((allocate_ret == <span class="number">1</span>) &amp;&amp; (allocated_block_head == <span class="literal">NULL</span>))	<span class="comment">//如果是第一个节点</span></span><br><span class="line">	&#123;</span><br><span class="line">		allocated_block_head = ab;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ((allocate_ret == <span class="number">1</span>) &amp;&amp; (allocated_block_head != <span class="literal">NULL</span>))	<span class="comment">//如果不是第一个节点</span></span><br><span class="line">	&#123;</span><br><span class="line">		ab-&gt;next = allocated_block_head;</span><br><span class="line">		allocated_block_head = ab;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (allocate_ret == <span class="number">-1</span>)	<span class="comment">//如果分配失败</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\nAllocation failed!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">free</span>(ab);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nAllocation success!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="分配内存模块">分配内存模块</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">allocate_mem</span><span class="params">(<span class="keyword">struct</span> allocated_block* ab)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_block_type</span>* <span class="title">fbt</span>, * <span class="title">pre</span>, * <span class="title">ne</span>, * <span class="title">p1</span>, * <span class="title">p2</span>;</span></span><br><span class="line">	<span class="type">int</span> request_size = ab-&gt;size;</span><br><span class="line">	fbt = pre = ne = p1 = p2 = free_block_head;</span><br><span class="line">	<span class="type">int</span> allocate_flag = <span class="number">0</span>;	<span class="comment">//判断是否已经找到匹配空闲块</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//根据当前算法在空闲分区链表中搜索合适空闲分区进行分配，分配时注意以下情况：</span></span><br><span class="line">	<span class="comment">// 1. 找到可满足空闲分区且分配后剩余空间足够大，则分割</span></span><br><span class="line">	<span class="comment">// 2. 找到可满足空闲分区且但分配后剩余空间比较小，则一起分配</span></span><br><span class="line">	<span class="comment">// 3. 找不到可满足需要的空闲分区但空闲分区之和能满足需要，则采用内存紧缩技术，进行空闲分区的合并，然后再分配</span></span><br><span class="line">	<span class="comment">// 4. 在成功分配内存后，应保持空闲分区按照相应算法有序</span></span><br><span class="line">	<span class="comment">// 5. 分配成功则返回1，否则返回-1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mem_size &lt;= <span class="number">0</span>)	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//遍历查找匹配空闲块</span></span><br><span class="line">	<span class="keyword">if</span> (ne-&gt;next)	<span class="comment">//如果空闲块不止一个	</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (ma_algorithm == <span class="number">1</span>)	<span class="comment">//如果是FF算法，遍历每一个空闲块</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span> (ne)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (ne != free_block_head)	p2 = p1;</span><br><span class="line">				p1 = ne;</span><br><span class="line">				ne = ne-&gt;next;</span><br><span class="line">				<span class="keyword">if</span> (request_size &lt;= p1-&gt;size)</span><br><span class="line">				&#123;</span><br><span class="line">					fbt = p2;</span><br><span class="line">					pre = p1;</span><br><span class="line">					allocate_flag = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ma_algorithm == <span class="number">2</span>)	<span class="comment">//如果是BF算法，则遍历每一个大小满足要求的空闲块</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span> ((ne != <span class="literal">NULL</span>) &amp;&amp; (request_size &lt;= ne-&gt;size))	</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (allocate_flag)	fbt = pre;</span><br><span class="line">				pre = ne;</span><br><span class="line">				ne = ne-&gt;next;</span><br><span class="line">				allocate_flag = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ma_algorithm == <span class="number">3</span>)	<span class="comment">//如果是WF算法，则直接查找最后一个空闲块</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span> (ne)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (ne != free_block_head)	fbt = pre;</span><br><span class="line">				pre = ne;</span><br><span class="line">				ne = ne-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (pre-&gt;size &gt;= request_size)	allocate_flag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (request_size &lt;= pre-&gt;size)</span><br><span class="line">			allocate_flag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (allocate_flag)	<span class="comment">//找到可用空闲区，判断需不需要一起分配剩余内存空间</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((pre-&gt;size - request_size) &gt;= MIN_SLICE)	<span class="comment">//找到可满足空闲分区且分配后剩余空间比较大，则正常分配</span></span><br><span class="line">		&#123;</span><br><span class="line">			pre-&gt;size = pre-&gt;size - request_size;</span><br><span class="line">			ab-&gt;start_addr = pre-&gt;start_addr;</span><br><span class="line">			pre-&gt;start_addr += ab-&gt;size;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">else</span>	<span class="comment">//找到可满足空闲分区且分配后剩余空间比较小，则一起分配，删除该节点</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (fbt == pre)	<span class="comment">//如果头块满足条件</span></span><br><span class="line">			&#123;</span><br><span class="line">				fbt = pre-&gt;next;</span><br><span class="line">				free_block_head = fbt;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>	<span class="comment">//中间空闲块满足条件</span></span><br><span class="line">				fbt-&gt;next = pre-&gt;next;</span><br><span class="line"></span><br><span class="line">			ab-&gt;start_addr = pre-&gt;start_addr;</span><br><span class="line">			ab-&gt;size = pre-&gt;size;</span><br><span class="line">			<span class="built_in">free</span>(pre);	<span class="comment">//释放节点</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		mem_size -= ab-&gt;size;</span><br><span class="line">		rearrange(ma_algorithm);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span>	<span class="comment">//找不到空闲区，则进行内存紧缩</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (mem_size &gt;= request_size)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (mem_size &gt;= request_size + MIN_SLICE)	<span class="comment">//分配完内存后还留有空闲内存</span></span><br><span class="line">				free_memory_rearrange(mem_size - request_size, request_size);</span><br><span class="line">			<span class="keyword">else</span>	<span class="comment">//分配完内存后无空闲内存</span></span><br><span class="line">				free_memory_rearrange(<span class="number">0</span>, mem_size);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="紧缩处理">紧缩处理</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free_memory_rearrange</span><span class="params">(<span class="type">int</span> memory_reduce_size, <span class="type">int</span> allocated_size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_block_type</span>* <span class="title">f1</span>, * <span class="title">f2</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">allocated_block</span>* <span class="title">a1</span>, * <span class="title">a2</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//空闲块处理</span></span><br><span class="line">	<span class="keyword">if</span> (memory_reduce_size != <span class="number">0</span>)	<span class="comment">//分配完剩余空间大于最小内存碎片</span></span><br><span class="line">	&#123;</span><br><span class="line">		f1 = free_block_head;</span><br><span class="line">		f2 = f1-&gt;next;</span><br><span class="line"></span><br><span class="line">		f1-&gt;start_addr = mem_size_total - memory_reduce_size;</span><br><span class="line">		f1-&gt;size = memory_reduce_size;</span><br><span class="line">		f1-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		mem_size = memory_reduce_size;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		f2 = free_block_head;</span><br><span class="line">		free_block_head = <span class="literal">NULL</span>;</span><br><span class="line">		mem_size = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (f2 != <span class="literal">NULL</span>)	<span class="comment">//逐一释放空闲内存块节点</span></span><br><span class="line">	&#123;</span><br><span class="line">		f1 = f2;</span><br><span class="line">		f2 = f2-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(f1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//加载块处理</span></span><br><span class="line">	a1 = (<span class="keyword">struct</span> allocated_block*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> allocated_block));</span><br><span class="line">	a1-&gt;pid = pid;</span><br><span class="line">	a1-&gt;size = allocated_size;</span><br><span class="line">	a1-&gt;start_addr = mem_size_total - memory_reduce_size - a1-&gt;size;</span><br><span class="line">	<span class="built_in">sprintf</span>(a1-&gt;process_name, <span class="string">&quot;PROCESS-%02d&quot;</span>, pid);</span><br><span class="line"></span><br><span class="line">	a1-&gt;next = allocated_block_head;</span><br><span class="line">	a2 = allocated_block_head;</span><br><span class="line">	allocated_block_head = a1;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (a2 != <span class="literal">NULL</span>)	<span class="comment">//逐一将加载块相邻放置</span></span><br><span class="line">	&#123;</span><br><span class="line">		a2-&gt;start_addr = a1-&gt;start_addr - a2-&gt;size;</span><br><span class="line">		a1 = a2;</span><br><span class="line">		a2 = a2-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除进程移出内存">删除进程移出内存</h4>
<h5 id="删除进程">删除进程</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kill_process</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">allocated_block</span>* <span class="title">ab</span>;</span></span><br><span class="line">	<span class="type">int</span> pid;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nKill Process, pid = &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;pid);</span><br><span class="line">	ab = find_process(pid);	<span class="comment">//找到要删除的块</span></span><br><span class="line">	<span class="keyword">if</span> (ab != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		free_mem(ab);	<span class="comment">//释放ab所表示的分配区</span></span><br><span class="line">		dispose(ab);	<span class="comment">//释放ab数据结构节点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="找到进程">找到进程</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> allocated_block* <span class="title function_">find_process</span><span class="params">(<span class="type">int</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">allocated_block</span>* <span class="title">p</span>;</span></span><br><span class="line">	p = allocated_block_head;</span><br><span class="line">	<span class="keyword">while</span> (p)	<span class="comment">//遍历链表找pid对应进程</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;pid == pid)</span><br><span class="line">			<span class="keyword">return</span> p;	<span class="comment">//找到则返回struct</span></span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nProcess not found!\n&quot;</span>);	<span class="comment">//没有找到则报错并返回NULL</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="归还分配区并合并">归还分配区并合并</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">free_mem</span><span class="params">(<span class="keyword">struct</span> allocated_block* ab)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> algorithm = ma_algorithm;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_block_type</span>* <span class="title">fbt</span>, * <span class="title">left</span>, * <span class="title">right</span>;</span>	<span class="comment">//链表结构认为从左指向右，fbt存储要释放的分区</span></span><br><span class="line">    	<span class="comment">//left为插入后左边（靠近表头）的空闲分区、right为插入后右边（远离表头）的空闲分区</span></span><br><span class="line">	mem_size += ab-&gt;size;</span><br><span class="line"></span><br><span class="line">	fbt = (<span class="keyword">struct</span> free_block_type*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> free_block_type));</span><br><span class="line">	<span class="keyword">if</span> (!fbt)	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//回收内存4种情况：</span></span><br><span class="line">	<span class="comment">// 1. 当前空闲分区和右边空闲分区相邻，合并为同一个分区，且释放右边分区 </span></span><br><span class="line">	<span class="comment">// 2. 当前空闲分区和左边空闲分区相邻，合并为同一个分区，且释放当前分区</span></span><br><span class="line">	<span class="comment">// 3. 当前空闲分区和左右空闲分区都相邻，合并为同一个分区，且释放当前和右边分区</span></span><br><span class="line">	<span class="comment">// 4. 无相邻空闲分区，则插入一个新表项</span></span><br><span class="line"></span><br><span class="line">	fbt-&gt;size = ab-&gt;size;</span><br><span class="line">	fbt-&gt;start_addr = ab-&gt;start_addr;</span><br><span class="line">	fbt-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	rearrange(MA_FF);</span><br><span class="line"></span><br><span class="line">	left = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//从头开始按照起始地址顺序遍历，判断插入链表的位置</span></span><br><span class="line">	right = free_block_head;</span><br><span class="line">	<span class="keyword">while</span> ((right != <span class="literal">NULL</span>) &amp;&amp; (fbt-&gt;start_addr &lt; right-&gt;start_addr))</span><br><span class="line">	&#123;</span><br><span class="line">		left = right;</span><br><span class="line">		right = right-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!left)	<span class="comment">//插入位置为链表头</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!right)	<span class="comment">//如果释放内存前已经没有空闲分区</span></span><br><span class="line">			free_block_head = fbt;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			fbt-&gt;next = right;</span><br><span class="line">			free_block_head = fbt;</span><br><span class="line">			<span class="keyword">if</span> (right-&gt;start_addr + right-&gt;size == fbt-&gt;start_addr)	<span class="comment">//判断释放的空闲区间和右边空闲分区是否相邻，是则合并</span></span><br><span class="line">			&#123;</span><br><span class="line">				fbt-&gt;next = right-&gt;next;</span><br><span class="line">				fbt-&gt;start_addr = right-&gt;start_addr;</span><br><span class="line">				fbt-&gt;size = fbt-&gt;size + right-&gt;size;</span><br><span class="line">				<span class="built_in">free</span>(right);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span>	</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!right)	<span class="comment">//如果插入的位置在链表尾</span></span><br><span class="line">		&#123;</span><br><span class="line">			left-&gt;next = fbt;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (fbt-&gt;start_addr + fbt-&gt;size == left-&gt;start_addr)	<span class="comment">//判断释放的空闲区间和左边空闲分区是否相邻，是则合并</span></span><br><span class="line">			&#123;</span><br><span class="line">				left-&gt;next = right;</span><br><span class="line">				left-&gt;size = fbt-&gt;size + left-&gt;size;</span><br><span class="line">				left-&gt;start_addr = fbt-&gt;start_addr;</span><br><span class="line">				<span class="built_in">free</span>(fbt);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">else</span>	<span class="comment">//如果插入的位置在链表中间</span></span><br><span class="line">		&#123;</span><br><span class="line">			fbt-&gt;next = right;</span><br><span class="line">			left-&gt;next = fbt;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> ((fbt-&gt;start_addr + fbt-&gt;size == left-&gt;start_addr) &amp;&amp; (right-&gt;start_addr + right-&gt;size == fbt-&gt;start_addr))	<span class="comment">//和左右都相邻</span></span><br><span class="line">			&#123;</span><br><span class="line">				left-&gt;next = right-&gt;next;</span><br><span class="line">				left-&gt;size += fbt-&gt;size + right-&gt;size;</span><br><span class="line">				left-&gt;start_addr = right-&gt;start_addr;</span><br><span class="line">				<span class="built_in">free</span>(fbt);</span><br><span class="line">				<span class="built_in">free</span>(right);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (fbt-&gt;start_addr + fbt-&gt;size == left-&gt;start_addr)	<span class="comment">//和左边相邻</span></span><br><span class="line">			&#123;</span><br><span class="line">				left-&gt;next = right;</span><br><span class="line">				left-&gt;size = fbt-&gt;size + left-&gt;size;</span><br><span class="line">				left-&gt;start_addr = fbt-&gt;start_addr;</span><br><span class="line">				<span class="built_in">free</span>(fbt);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (right-&gt;start_addr + right-&gt;size == fbt-&gt;start_addr)	<span class="comment">//和右边相邻</span></span><br><span class="line">			&#123;</span><br><span class="line">				fbt-&gt;next = right-&gt;next;</span><br><span class="line">				fbt-&gt;start_addr = right-&gt;start_addr;</span><br><span class="line">				fbt-&gt;size = fbt-&gt;size + right-&gt;size;</span><br><span class="line">				<span class="built_in">free</span>(right);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rearrange(ma_algorithm);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="释放ab数据结构节点">释放ab数据结构节点</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dispose</span><span class="params">(<span class="keyword">struct</span> allocated_block* free_ab)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">allocated_block</span>* <span class="title">pre</span>, * <span class="title">ab</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (free_ab == allocated_block_head)	<span class="comment">//如果释放头节点</span></span><br><span class="line">	&#123;</span><br><span class="line">		allocated_block_head = allocated_block_head-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(free_ab);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pre = allocated_block_head;</span><br><span class="line">	ab = allocated_block_head-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (ab != free_ab)	<span class="comment">//遍历链表找到要释放的节点</span></span><br><span class="line">	&#123;</span><br><span class="line">		pre = ab;</span><br><span class="line">		ab = ab-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	pre-&gt;next = ab-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(ab);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="显示内存状态">显示内存状态</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">display_mem_usage</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_block_type</span>* <span class="title">fbt</span> =</span> free_block_head;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">allocated_block</span>* <span class="title">ab</span> =</span> allocated_block_head;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-------------------------------------------------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//显示空闲区</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Free Memory:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%20s %20s\n&quot;</span>, <span class="string">&quot;start_addr&quot;</span>, <span class="string">&quot;size&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (fbt != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%20d %20d\n&quot;</span>, fbt-&gt;start_addr, fbt-&gt;size);</span><br><span class="line">		fbt = fbt-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//显示已分配区</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nUsed Memory:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%10s %20s %10s %10s\n&quot;</span>, <span class="string">&quot;PID&quot;</span>, <span class="string">&quot;Process Name&quot;</span>, <span class="string">&quot;start_addr&quot;</span>, <span class="string">&quot;size&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (ab != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%10d %20s %10d %10d\n&quot;</span>, ab-&gt;pid, ab-&gt;process_name, ab-&gt;start_addr, ab-&gt;size);</span><br><span class="line">		ab = ab-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-------------------------------------------------------------\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="三种算法">三种算法</h4>
<h5 id="ff算法">FF算法</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rearrange_FF</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_block_type</span>* <span class="title">p</span>, * <span class="title">p1</span>, * <span class="title">p2</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_block_type</span>* <span class="title">last_block</span>;</span></span><br><span class="line">	p1 = (<span class="keyword">struct</span> free_block_type*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> free_block_type));</span><br><span class="line">	p1-&gt;next = free_block_head;</span><br><span class="line">	free_block_head = p1;</span><br><span class="line">	<span class="keyword">if</span> (free_block_head != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (last_block = <span class="literal">NULL</span>; last_block != free_block_head; last_block = p)	<span class="comment">//冒泡排序，按起始地址从大到小排</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (p = p1 = free_block_head; p1-&gt;next != <span class="literal">NULL</span> &amp;&amp; p1-&gt;next-&gt;next != <span class="literal">NULL</span> &amp;&amp; p1-&gt;next-&gt;next != last_block; p1 = p1-&gt;next)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (p1-&gt;next-&gt;start_addr &lt; p1-&gt;next-&gt;next-&gt;start_addr)</span><br><span class="line">				&#123;</span><br><span class="line">					p2 = p1-&gt;next-&gt;next;</span><br><span class="line">					p1-&gt;next-&gt;next = p2-&gt;next;</span><br><span class="line"></span><br><span class="line">					p2-&gt;next = p1-&gt;next;</span><br><span class="line">					p1-&gt;next = p2;</span><br><span class="line"></span><br><span class="line">					p = p1-&gt;next-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p1 = free_block_head;</span><br><span class="line">	free_block_head = free_block_head-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(p1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="bf算法">BF算法</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rearrange_BF</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_block_type</span>* <span class="title">p</span>, * <span class="title">p1</span>, * <span class="title">p2</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_block_type</span>* <span class="title">last_block</span>;</span></span><br><span class="line">	p1 = (<span class="keyword">struct</span> free_block_type*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> free_block_type));</span><br><span class="line">	p1-&gt;next = free_block_head;</span><br><span class="line">	free_block_head = p1;</span><br><span class="line">	<span class="keyword">if</span> (free_block_head != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (last_block = <span class="literal">NULL</span>; last_block != free_block_head; last_block = p)	<span class="comment">//冒泡排序，按块大小从大到小排</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (p = p1 = free_block_head; p1-&gt;next != <span class="literal">NULL</span> &amp;&amp; p1-&gt;next-&gt;next != <span class="literal">NULL</span> &amp;&amp; p1-&gt;next-&gt;next != last_block; p1 = p1-&gt;next)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (p1-&gt;next-&gt;size &lt; p1-&gt;next-&gt;next-&gt;size)</span><br><span class="line">				&#123;</span><br><span class="line">					p2 = p1-&gt;next-&gt;next;</span><br><span class="line">					p1-&gt;next-&gt;next = p2-&gt;next;</span><br><span class="line"></span><br><span class="line">					p2-&gt;next = p1-&gt;next;</span><br><span class="line">					p1-&gt;next = p2;</span><br><span class="line"></span><br><span class="line">					p = p1-&gt;next-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	p1 = free_block_head;</span><br><span class="line">	free_block_head = free_block_head-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(p1);</span><br><span class="line">	p1 = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="wf算法">WF算法</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rearrange_WF</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_block_type</span>* <span class="title">p</span>, * <span class="title">p1</span>, * <span class="title">p2</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_block_type</span>* <span class="title">last_block</span>;</span></span><br><span class="line">	p1 = (<span class="keyword">struct</span> free_block_type*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> free_block_type));</span><br><span class="line">	p1-&gt;next = free_block_head;</span><br><span class="line">	free_block_head = p1;</span><br><span class="line">	<span class="keyword">if</span> (free_block_head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (last_block = <span class="literal">NULL</span>; last_block != free_block_head; last_block = p)	<span class="comment">//冒泡排序，按块大小从小到大排</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (p = p1 = free_block_head; p1-&gt;next != <span class="literal">NULL</span> &amp;&amp; p1-&gt;next-&gt;next != <span class="literal">NULL</span> &amp;&amp; p1-&gt;next-&gt;next != last_block; p1 = p1-&gt;next)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (p1-&gt;next-&gt;size &gt; p1-&gt;next-&gt;next-&gt;size)</span><br><span class="line">				&#123;</span><br><span class="line">					p2 = p1-&gt;next-&gt;next;</span><br><span class="line">					p1-&gt;next-&gt;next = p2-&gt;next; </span><br><span class="line"></span><br><span class="line">					p2-&gt;next = p1-&gt;next;</span><br><span class="line">					p1-&gt;next = p2;</span><br><span class="line"></span><br><span class="line">					p = p1-&gt;next-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p1 = free_block_head;</span><br><span class="line">	free_block_head = free_block_head-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(p1);</span><br><span class="line">	p1 = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="退出程序">退出程序</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_exit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_block_type</span>* <span class="title">p1</span>, * <span class="title">p2</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">allocated_block</span>* <span class="title">a1</span>, * <span class="title">a2</span>;</span></span><br><span class="line">	p1 = free_block_head;</span><br><span class="line">	<span class="keyword">if</span> (p1 != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		p2 = p1-&gt;next;</span><br><span class="line">		<span class="keyword">for</span> (; p2 != <span class="literal">NULL</span>; p1 = p2, p2 = p2-&gt;next)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">free</span>(p1);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">free</span>(p1);</span><br><span class="line">	&#125;</span><br><span class="line">	a1 = allocated_block_head;</span><br><span class="line">	<span class="keyword">if</span> (a1 != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		a2 = a1-&gt;next;</span><br><span class="line">		<span class="keyword">for</span> (; a2 != <span class="literal">NULL</span>; a1 = a2, a2 = a2-&gt;next)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">free</span>(a1);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">free</span>(a1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="避免采坑-6">避免采坑</h2>
<p>写了好几天，调了无数的bug，很多都由于当时沉迷分析调试改bug忘了记录了，只记几个问题吧。</p>
<p>给了个测试用例发现相邻空闲内存没有合并，如图：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/image-20191106233254914.png" class="" title="image-20191106233254914">
<p>经过调试发现是我排序算法写反了，本来FF排完序之后应该是从头开始起始地址从大到小排列，结果我写成从小到大排列了，而我合并的时候又是把起始地址按照从大到小的顺序插入，这样就导致相邻比较的时候是大的比小的，所以出错，改正之后就好了。</p>
<p>可是改正了之后又发现FF算法实际输出的效果是WF算法，经过分析发现是分配内存的时候出现了问题。我在遍历空闲块的时候直接找的是第一个满足条件的空闲块，而我的链表是从大到小排的，所以出现了问题。修改之后就发现程序一创建进程就崩溃，后来发现我的条件是pre!=NULL，当我所以空闲块都满足条件的时候最终的pre就越界，所以改成pre-&gt;next!=NULL就避免了越界。但是这样又发现程序报错。后来发现这样写的话，在一开始只有一个头结点的时候就会出错，因此又加了一个判断是否只有一个节点，这样就解决了问题。</p>
<p>再次调试的时候又发现内存紧缩模块有问题。</p>
<p>本来内存状态如下：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/image-20191107001256301.png" class="" title="image-20191107001256301">
<p>加了一个大小为800的PROCESS-06，结果如下：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/image-20191107001446943.png" class="" title="image-20191107001446943">
<p>调试发现是内存紧缩模块中处理加载块的时候把起始地址填错了</p>
<p><code>a1-&gt;start_addr = mem_size_total - memory_reduce_size</code>改成<code>a1-&gt;start_addr = mem_size_total - memory_reduce_size - a1-&gt;size</code>就对了</p>
<p>再次调试发现在内存紧缩后，显示内存状态程序就会崩溃，后来发现我在释放节点的时候把f1、f2写反了，这样导致在释放后free_block_head也被释放了，所以显示的时候就会出现问题。修改后就可以了。</p>
<p>后来发现内存紧缩在合并左右两个相邻块时会出问题，调试发现内存大小写错了，<code>left-&gt;size = fbt-&gt;size + right-&gt;size</code>;这样少了左边节点自身的大小，所以出问题。写成<code>left-&gt;size += fbt-&gt;size + right-&gt;size</code>;就没有问题了。</p>
<p>后来又发现内存紧缩的时候出现问题，算法是WF，状态如下：</p>
<img src="/2019/10/17/Lecture/OS%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%8E%A9%E8%BD%AClinux%E5%86%85%E6%A0%B8/image-20191107145711780.png" class="" title="image-20191107145711780">
<p>我给了一个200的进程发现触发了内存紧缩。经过调试发现在分配内存的时候便利空闲块出现了问题，在WF算法下空闲块链表的排序为size从小到大排，而我在遍历的时候由于第一个小于200，所以程序认为没有合适的空闲块。所以为WF算法设置一个专门的分配方式，直接判断最后一个空闲块是否满足要求。再次调试发现FF算法又出问题了，所以干脆给每个算法都写出特定的空闲块查找算法。最终解决问题。</p>
<p>写完了之后我想了一下，好像如果我把内存的结构改成按照内存大小从小到大排会简单很多，在分配算法的时候直接找头结点就行了……</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/OS/" rel="tag"># OS</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/10/10/Lecture/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="prev" title="计组学习笔记">
                  <i class="fa fa-angle-left"></i> 计组学习笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/01/31/PDF%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E7%9B%AE%E5%BD%95/" rel="next" title="PDF如何添加目录">
                  PDF如何添加目录 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Winny</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
